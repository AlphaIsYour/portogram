
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectFeature
 * 
 */
export type ProjectFeature = $Result.DefaultSelection<Prisma.$ProjectFeaturePayload>
/**
 * Model ProjectTechStack
 * 
 */
export type ProjectTechStack = $Result.DefaultSelection<Prisma.$ProjectTechStackPayload>
/**
 * Model ProjectCollaborator
 * 
 */
export type ProjectCollaborator = $Result.DefaultSelection<Prisma.$ProjectCollaboratorPayload>
/**
 * Model ProjectLearning
 * 
 */
export type ProjectLearning = $Result.DefaultSelection<Prisma.$ProjectLearningPayload>
/**
 * Model WorkExperience
 * 
 */
export type WorkExperience = $Result.DefaultSelection<Prisma.$WorkExperiencePayload>
/**
 * Model WorkResponsibility
 * 
 */
export type WorkResponsibility = $Result.DefaultSelection<Prisma.$WorkResponsibilityPayload>
/**
 * Model WorkTechnology
 * 
 */
export type WorkTechnology = $Result.DefaultSelection<Prisma.$WorkTechnologyPayload>
/**
 * Model WorkAchievement
 * 
 */
export type WorkAchievement = $Result.DefaultSelection<Prisma.$WorkAchievementPayload>
/**
 * Model Education
 * 
 */
export type Education = $Result.DefaultSelection<Prisma.$EducationPayload>
/**
 * Model EducationAchievement
 * 
 */
export type EducationAchievement = $Result.DefaultSelection<Prisma.$EducationAchievementPayload>
/**
 * Model Certification
 * 
 */
export type Certification = $Result.DefaultSelection<Prisma.$CertificationPayload>
/**
 * Model CertificationSkill
 * 
 */
export type CertificationSkill = $Result.DefaultSelection<Prisma.$CertificationSkillPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model BlogTag
 * 
 */
export type BlogTag = $Result.DefaultSelection<Prisma.$BlogTagPayload>
/**
 * Model Testimonial
 * 
 */
export type Testimonial = $Result.DefaultSelection<Prisma.$TestimonialPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model SocialMedia
 * 
 */
export type SocialMedia = $Result.DefaultSelection<Prisma.$SocialMediaPayload>
/**
 * Model DevStats
 * 
 */
export type DevStats = $Result.DefaultSelection<Prisma.$DevStatsPayload>
/**
 * Model ContributionData
 * 
 */
export type ContributionData = $Result.DefaultSelection<Prisma.$ContributionDataPayload>
/**
 * Model ContributionDay
 * 
 */
export type ContributionDay = $Result.DefaultSelection<Prisma.$ContributionDayPayload>
/**
 * Model TimelineEvent
 * 
 */
export type TimelineEvent = $Result.DefaultSelection<Prisma.$TimelineEventPayload>
/**
 * Model ProjectTestimonial
 * 
 */
export type ProjectTestimonial = $Result.DefaultSelection<Prisma.$ProjectTestimonialPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectFeature`: Exposes CRUD operations for the **ProjectFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectFeatures
    * const projectFeatures = await prisma.projectFeature.findMany()
    * ```
    */
  get projectFeature(): Prisma.ProjectFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectTechStack`: Exposes CRUD operations for the **ProjectTechStack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTechStacks
    * const projectTechStacks = await prisma.projectTechStack.findMany()
    * ```
    */
  get projectTechStack(): Prisma.ProjectTechStackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectCollaborator`: Exposes CRUD operations for the **ProjectCollaborator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectCollaborators
    * const projectCollaborators = await prisma.projectCollaborator.findMany()
    * ```
    */
  get projectCollaborator(): Prisma.ProjectCollaboratorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectLearning`: Exposes CRUD operations for the **ProjectLearning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectLearnings
    * const projectLearnings = await prisma.projectLearning.findMany()
    * ```
    */
  get projectLearning(): Prisma.ProjectLearningDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workExperience`: Exposes CRUD operations for the **WorkExperience** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkExperiences
    * const workExperiences = await prisma.workExperience.findMany()
    * ```
    */
  get workExperience(): Prisma.WorkExperienceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workResponsibility`: Exposes CRUD operations for the **WorkResponsibility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkResponsibilities
    * const workResponsibilities = await prisma.workResponsibility.findMany()
    * ```
    */
  get workResponsibility(): Prisma.WorkResponsibilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workTechnology`: Exposes CRUD operations for the **WorkTechnology** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkTechnologies
    * const workTechnologies = await prisma.workTechnology.findMany()
    * ```
    */
  get workTechnology(): Prisma.WorkTechnologyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workAchievement`: Exposes CRUD operations for the **WorkAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkAchievements
    * const workAchievements = await prisma.workAchievement.findMany()
    * ```
    */
  get workAchievement(): Prisma.WorkAchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.education`: Exposes CRUD operations for the **Education** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Educations
    * const educations = await prisma.education.findMany()
    * ```
    */
  get education(): Prisma.EducationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.educationAchievement`: Exposes CRUD operations for the **EducationAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EducationAchievements
    * const educationAchievements = await prisma.educationAchievement.findMany()
    * ```
    */
  get educationAchievement(): Prisma.EducationAchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certification`: Exposes CRUD operations for the **Certification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certifications
    * const certifications = await prisma.certification.findMany()
    * ```
    */
  get certification(): Prisma.CertificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificationSkill`: Exposes CRUD operations for the **CertificationSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CertificationSkills
    * const certificationSkills = await prisma.certificationSkill.findMany()
    * ```
    */
  get certificationSkill(): Prisma.CertificationSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogTag`: Exposes CRUD operations for the **BlogTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogTags
    * const blogTags = await prisma.blogTag.findMany()
    * ```
    */
  get blogTag(): Prisma.BlogTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testimonial`: Exposes CRUD operations for the **Testimonial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testimonials
    * const testimonials = await prisma.testimonial.findMany()
    * ```
    */
  get testimonial(): Prisma.TestimonialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialMedia`: Exposes CRUD operations for the **SocialMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialMedias
    * const socialMedias = await prisma.socialMedia.findMany()
    * ```
    */
  get socialMedia(): Prisma.SocialMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.devStats`: Exposes CRUD operations for the **DevStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DevStats
    * const devStats = await prisma.devStats.findMany()
    * ```
    */
  get devStats(): Prisma.DevStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contributionData`: Exposes CRUD operations for the **ContributionData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContributionData
    * const contributionData = await prisma.contributionData.findMany()
    * ```
    */
  get contributionData(): Prisma.ContributionDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contributionDay`: Exposes CRUD operations for the **ContributionDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContributionDays
    * const contributionDays = await prisma.contributionDay.findMany()
    * ```
    */
  get contributionDay(): Prisma.ContributionDayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timelineEvent`: Exposes CRUD operations for the **TimelineEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimelineEvents
    * const timelineEvents = await prisma.timelineEvent.findMany()
    * ```
    */
  get timelineEvent(): Prisma.TimelineEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectTestimonial`: Exposes CRUD operations for the **ProjectTestimonial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTestimonials
    * const projectTestimonials = await prisma.projectTestimonial.findMany()
    * ```
    */
  get projectTestimonial(): Prisma.ProjectTestimonialDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Skill: 'Skill',
    Project: 'Project',
    ProjectFeature: 'ProjectFeature',
    ProjectTechStack: 'ProjectTechStack',
    ProjectCollaborator: 'ProjectCollaborator',
    ProjectLearning: 'ProjectLearning',
    WorkExperience: 'WorkExperience',
    WorkResponsibility: 'WorkResponsibility',
    WorkTechnology: 'WorkTechnology',
    WorkAchievement: 'WorkAchievement',
    Education: 'Education',
    EducationAchievement: 'EducationAchievement',
    Certification: 'Certification',
    CertificationSkill: 'CertificationSkill',
    Achievement: 'Achievement',
    BlogPost: 'BlogPost',
    BlogTag: 'BlogTag',
    Testimonial: 'Testimonial',
    Contact: 'Contact',
    SocialMedia: 'SocialMedia',
    DevStats: 'DevStats',
    ContributionData: 'ContributionData',
    ContributionDay: 'ContributionDay',
    TimelineEvent: 'TimelineEvent',
    ProjectTestimonial: 'ProjectTestimonial'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "skill" | "project" | "projectFeature" | "projectTechStack" | "projectCollaborator" | "projectLearning" | "workExperience" | "workResponsibility" | "workTechnology" | "workAchievement" | "education" | "educationAchievement" | "certification" | "certificationSkill" | "achievement" | "blogPost" | "blogTag" | "testimonial" | "contact" | "socialMedia" | "devStats" | "contributionData" | "contributionDay" | "timelineEvent" | "projectTestimonial"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectFeature: {
        payload: Prisma.$ProjectFeaturePayload<ExtArgs>
        fields: Prisma.ProjectFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFeaturePayload>
          }
          findFirst: {
            args: Prisma.ProjectFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFeaturePayload>
          }
          findMany: {
            args: Prisma.ProjectFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFeaturePayload>[]
          }
          create: {
            args: Prisma.ProjectFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFeaturePayload>
          }
          createMany: {
            args: Prisma.ProjectFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFeaturePayload>[]
          }
          delete: {
            args: Prisma.ProjectFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFeaturePayload>
          }
          update: {
            args: Prisma.ProjectFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFeaturePayload>
          }
          deleteMany: {
            args: Prisma.ProjectFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFeaturePayload>[]
          }
          upsert: {
            args: Prisma.ProjectFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFeaturePayload>
          }
          aggregate: {
            args: Prisma.ProjectFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectFeature>
          }
          groupBy: {
            args: Prisma.ProjectFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectFeatureCountAggregateOutputType> | number
          }
        }
      }
      ProjectTechStack: {
        payload: Prisma.$ProjectTechStackPayload<ExtArgs>
        fields: Prisma.ProjectTechStackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectTechStackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTechStackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectTechStackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTechStackPayload>
          }
          findFirst: {
            args: Prisma.ProjectTechStackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTechStackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectTechStackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTechStackPayload>
          }
          findMany: {
            args: Prisma.ProjectTechStackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTechStackPayload>[]
          }
          create: {
            args: Prisma.ProjectTechStackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTechStackPayload>
          }
          createMany: {
            args: Prisma.ProjectTechStackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectTechStackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTechStackPayload>[]
          }
          delete: {
            args: Prisma.ProjectTechStackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTechStackPayload>
          }
          update: {
            args: Prisma.ProjectTechStackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTechStackPayload>
          }
          deleteMany: {
            args: Prisma.ProjectTechStackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectTechStackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectTechStackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTechStackPayload>[]
          }
          upsert: {
            args: Prisma.ProjectTechStackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTechStackPayload>
          }
          aggregate: {
            args: Prisma.ProjectTechStackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectTechStack>
          }
          groupBy: {
            args: Prisma.ProjectTechStackGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectTechStackGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectTechStackCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectTechStackCountAggregateOutputType> | number
          }
        }
      }
      ProjectCollaborator: {
        payload: Prisma.$ProjectCollaboratorPayload<ExtArgs>
        fields: Prisma.ProjectCollaboratorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectCollaboratorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectCollaboratorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          findFirst: {
            args: Prisma.ProjectCollaboratorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectCollaboratorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          findMany: {
            args: Prisma.ProjectCollaboratorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>[]
          }
          create: {
            args: Prisma.ProjectCollaboratorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          createMany: {
            args: Prisma.ProjectCollaboratorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCollaboratorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>[]
          }
          delete: {
            args: Prisma.ProjectCollaboratorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          update: {
            args: Prisma.ProjectCollaboratorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          deleteMany: {
            args: Prisma.ProjectCollaboratorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectCollaboratorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectCollaboratorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>[]
          }
          upsert: {
            args: Prisma.ProjectCollaboratorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          aggregate: {
            args: Prisma.ProjectCollaboratorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectCollaborator>
          }
          groupBy: {
            args: Prisma.ProjectCollaboratorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectCollaboratorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCollaboratorCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCollaboratorCountAggregateOutputType> | number
          }
        }
      }
      ProjectLearning: {
        payload: Prisma.$ProjectLearningPayload<ExtArgs>
        fields: Prisma.ProjectLearningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectLearningFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLearningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectLearningFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLearningPayload>
          }
          findFirst: {
            args: Prisma.ProjectLearningFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLearningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectLearningFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLearningPayload>
          }
          findMany: {
            args: Prisma.ProjectLearningFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLearningPayload>[]
          }
          create: {
            args: Prisma.ProjectLearningCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLearningPayload>
          }
          createMany: {
            args: Prisma.ProjectLearningCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectLearningCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLearningPayload>[]
          }
          delete: {
            args: Prisma.ProjectLearningDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLearningPayload>
          }
          update: {
            args: Prisma.ProjectLearningUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLearningPayload>
          }
          deleteMany: {
            args: Prisma.ProjectLearningDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectLearningUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectLearningUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLearningPayload>[]
          }
          upsert: {
            args: Prisma.ProjectLearningUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLearningPayload>
          }
          aggregate: {
            args: Prisma.ProjectLearningAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectLearning>
          }
          groupBy: {
            args: Prisma.ProjectLearningGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectLearningGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectLearningCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectLearningCountAggregateOutputType> | number
          }
        }
      }
      WorkExperience: {
        payload: Prisma.$WorkExperiencePayload<ExtArgs>
        fields: Prisma.WorkExperienceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkExperienceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkExperienceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>
          }
          findFirst: {
            args: Prisma.WorkExperienceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkExperienceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>
          }
          findMany: {
            args: Prisma.WorkExperienceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>[]
          }
          create: {
            args: Prisma.WorkExperienceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>
          }
          createMany: {
            args: Prisma.WorkExperienceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkExperienceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>[]
          }
          delete: {
            args: Prisma.WorkExperienceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>
          }
          update: {
            args: Prisma.WorkExperienceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>
          }
          deleteMany: {
            args: Prisma.WorkExperienceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkExperienceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkExperienceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>[]
          }
          upsert: {
            args: Prisma.WorkExperienceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkExperiencePayload>
          }
          aggregate: {
            args: Prisma.WorkExperienceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkExperience>
          }
          groupBy: {
            args: Prisma.WorkExperienceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkExperienceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkExperienceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkExperienceCountAggregateOutputType> | number
          }
        }
      }
      WorkResponsibility: {
        payload: Prisma.$WorkResponsibilityPayload<ExtArgs>
        fields: Prisma.WorkResponsibilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkResponsibilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkResponsibilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkResponsibilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkResponsibilityPayload>
          }
          findFirst: {
            args: Prisma.WorkResponsibilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkResponsibilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkResponsibilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkResponsibilityPayload>
          }
          findMany: {
            args: Prisma.WorkResponsibilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkResponsibilityPayload>[]
          }
          create: {
            args: Prisma.WorkResponsibilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkResponsibilityPayload>
          }
          createMany: {
            args: Prisma.WorkResponsibilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkResponsibilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkResponsibilityPayload>[]
          }
          delete: {
            args: Prisma.WorkResponsibilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkResponsibilityPayload>
          }
          update: {
            args: Prisma.WorkResponsibilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkResponsibilityPayload>
          }
          deleteMany: {
            args: Prisma.WorkResponsibilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkResponsibilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkResponsibilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkResponsibilityPayload>[]
          }
          upsert: {
            args: Prisma.WorkResponsibilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkResponsibilityPayload>
          }
          aggregate: {
            args: Prisma.WorkResponsibilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkResponsibility>
          }
          groupBy: {
            args: Prisma.WorkResponsibilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkResponsibilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkResponsibilityCountArgs<ExtArgs>
            result: $Utils.Optional<WorkResponsibilityCountAggregateOutputType> | number
          }
        }
      }
      WorkTechnology: {
        payload: Prisma.$WorkTechnologyPayload<ExtArgs>
        fields: Prisma.WorkTechnologyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkTechnologyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTechnologyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkTechnologyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTechnologyPayload>
          }
          findFirst: {
            args: Prisma.WorkTechnologyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTechnologyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkTechnologyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTechnologyPayload>
          }
          findMany: {
            args: Prisma.WorkTechnologyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTechnologyPayload>[]
          }
          create: {
            args: Prisma.WorkTechnologyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTechnologyPayload>
          }
          createMany: {
            args: Prisma.WorkTechnologyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkTechnologyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTechnologyPayload>[]
          }
          delete: {
            args: Prisma.WorkTechnologyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTechnologyPayload>
          }
          update: {
            args: Prisma.WorkTechnologyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTechnologyPayload>
          }
          deleteMany: {
            args: Prisma.WorkTechnologyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkTechnologyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkTechnologyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTechnologyPayload>[]
          }
          upsert: {
            args: Prisma.WorkTechnologyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTechnologyPayload>
          }
          aggregate: {
            args: Prisma.WorkTechnologyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkTechnology>
          }
          groupBy: {
            args: Prisma.WorkTechnologyGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkTechnologyGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkTechnologyCountArgs<ExtArgs>
            result: $Utils.Optional<WorkTechnologyCountAggregateOutputType> | number
          }
        }
      }
      WorkAchievement: {
        payload: Prisma.$WorkAchievementPayload<ExtArgs>
        fields: Prisma.WorkAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkAchievementPayload>
          }
          findFirst: {
            args: Prisma.WorkAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkAchievementPayload>
          }
          findMany: {
            args: Prisma.WorkAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkAchievementPayload>[]
          }
          create: {
            args: Prisma.WorkAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkAchievementPayload>
          }
          createMany: {
            args: Prisma.WorkAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkAchievementPayload>[]
          }
          delete: {
            args: Prisma.WorkAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkAchievementPayload>
          }
          update: {
            args: Prisma.WorkAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkAchievementPayload>
          }
          deleteMany: {
            args: Prisma.WorkAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkAchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkAchievementPayload>[]
          }
          upsert: {
            args: Prisma.WorkAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkAchievementPayload>
          }
          aggregate: {
            args: Prisma.WorkAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkAchievement>
          }
          groupBy: {
            args: Prisma.WorkAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<WorkAchievementCountAggregateOutputType> | number
          }
        }
      }
      Education: {
        payload: Prisma.$EducationPayload<ExtArgs>
        fields: Prisma.EducationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          findFirst: {
            args: Prisma.EducationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          findMany: {
            args: Prisma.EducationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          create: {
            args: Prisma.EducationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          createMany: {
            args: Prisma.EducationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EducationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          delete: {
            args: Prisma.EducationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          update: {
            args: Prisma.EducationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          deleteMany: {
            args: Prisma.EducationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EducationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          upsert: {
            args: Prisma.EducationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          aggregate: {
            args: Prisma.EducationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducation>
          }
          groupBy: {
            args: Prisma.EducationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EducationCountArgs<ExtArgs>
            result: $Utils.Optional<EducationCountAggregateOutputType> | number
          }
        }
      }
      EducationAchievement: {
        payload: Prisma.$EducationAchievementPayload<ExtArgs>
        fields: Prisma.EducationAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationAchievementPayload>
          }
          findFirst: {
            args: Prisma.EducationAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationAchievementPayload>
          }
          findMany: {
            args: Prisma.EducationAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationAchievementPayload>[]
          }
          create: {
            args: Prisma.EducationAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationAchievementPayload>
          }
          createMany: {
            args: Prisma.EducationAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EducationAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationAchievementPayload>[]
          }
          delete: {
            args: Prisma.EducationAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationAchievementPayload>
          }
          update: {
            args: Prisma.EducationAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationAchievementPayload>
          }
          deleteMany: {
            args: Prisma.EducationAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EducationAchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationAchievementPayload>[]
          }
          upsert: {
            args: Prisma.EducationAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationAchievementPayload>
          }
          aggregate: {
            args: Prisma.EducationAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducationAchievement>
          }
          groupBy: {
            args: Prisma.EducationAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EducationAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<EducationAchievementCountAggregateOutputType> | number
          }
        }
      }
      Certification: {
        payload: Prisma.$CertificationPayload<ExtArgs>
        fields: Prisma.CertificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          findFirst: {
            args: Prisma.CertificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          findMany: {
            args: Prisma.CertificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>[]
          }
          create: {
            args: Prisma.CertificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          createMany: {
            args: Prisma.CertificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>[]
          }
          delete: {
            args: Prisma.CertificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          update: {
            args: Prisma.CertificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          deleteMany: {
            args: Prisma.CertificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CertificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>[]
          }
          upsert: {
            args: Prisma.CertificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          aggregate: {
            args: Prisma.CertificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertification>
          }
          groupBy: {
            args: Prisma.CertificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificationCountArgs<ExtArgs>
            result: $Utils.Optional<CertificationCountAggregateOutputType> | number
          }
        }
      }
      CertificationSkill: {
        payload: Prisma.$CertificationSkillPayload<ExtArgs>
        fields: Prisma.CertificationSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificationSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificationSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationSkillPayload>
          }
          findFirst: {
            args: Prisma.CertificationSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificationSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationSkillPayload>
          }
          findMany: {
            args: Prisma.CertificationSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationSkillPayload>[]
          }
          create: {
            args: Prisma.CertificationSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationSkillPayload>
          }
          createMany: {
            args: Prisma.CertificationSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificationSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationSkillPayload>[]
          }
          delete: {
            args: Prisma.CertificationSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationSkillPayload>
          }
          update: {
            args: Prisma.CertificationSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationSkillPayload>
          }
          deleteMany: {
            args: Prisma.CertificationSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificationSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CertificationSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationSkillPayload>[]
          }
          upsert: {
            args: Prisma.CertificationSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationSkillPayload>
          }
          aggregate: {
            args: Prisma.CertificationSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificationSkill>
          }
          groupBy: {
            args: Prisma.CertificationSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificationSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificationSkillCountArgs<ExtArgs>
            result: $Utils.Optional<CertificationSkillCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      BlogTag: {
        payload: Prisma.$BlogTagPayload<ExtArgs>
        fields: Prisma.BlogTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          findFirst: {
            args: Prisma.BlogTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          findMany: {
            args: Prisma.BlogTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>[]
          }
          create: {
            args: Prisma.BlogTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          createMany: {
            args: Prisma.BlogTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>[]
          }
          delete: {
            args: Prisma.BlogTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          update: {
            args: Prisma.BlogTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          deleteMany: {
            args: Prisma.BlogTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>[]
          }
          upsert: {
            args: Prisma.BlogTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          aggregate: {
            args: Prisma.BlogTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogTag>
          }
          groupBy: {
            args: Prisma.BlogTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogTagCountArgs<ExtArgs>
            result: $Utils.Optional<BlogTagCountAggregateOutputType> | number
          }
        }
      }
      Testimonial: {
        payload: Prisma.$TestimonialPayload<ExtArgs>
        fields: Prisma.TestimonialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestimonialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestimonialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findFirst: {
            args: Prisma.TestimonialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestimonialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findMany: {
            args: Prisma.TestimonialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          create: {
            args: Prisma.TestimonialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          createMany: {
            args: Prisma.TestimonialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestimonialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          delete: {
            args: Prisma.TestimonialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          update: {
            args: Prisma.TestimonialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          deleteMany: {
            args: Prisma.TestimonialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestimonialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestimonialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          upsert: {
            args: Prisma.TestimonialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          aggregate: {
            args: Prisma.TestimonialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonial>
          }
          groupBy: {
            args: Prisma.TestimonialGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestimonialCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      SocialMedia: {
        payload: Prisma.$SocialMediaPayload<ExtArgs>
        fields: Prisma.SocialMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPayload>
          }
          findFirst: {
            args: Prisma.SocialMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPayload>
          }
          findMany: {
            args: Prisma.SocialMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPayload>[]
          }
          create: {
            args: Prisma.SocialMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPayload>
          }
          createMany: {
            args: Prisma.SocialMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPayload>[]
          }
          delete: {
            args: Prisma.SocialMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPayload>
          }
          update: {
            args: Prisma.SocialMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPayload>
          }
          deleteMany: {
            args: Prisma.SocialMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SocialMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPayload>[]
          }
          upsert: {
            args: Prisma.SocialMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaPayload>
          }
          aggregate: {
            args: Prisma.SocialMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialMedia>
          }
          groupBy: {
            args: Prisma.SocialMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialMediaCountArgs<ExtArgs>
            result: $Utils.Optional<SocialMediaCountAggregateOutputType> | number
          }
        }
      }
      DevStats: {
        payload: Prisma.$DevStatsPayload<ExtArgs>
        fields: Prisma.DevStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DevStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DevStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevStatsPayload>
          }
          findFirst: {
            args: Prisma.DevStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DevStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevStatsPayload>
          }
          findMany: {
            args: Prisma.DevStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevStatsPayload>[]
          }
          create: {
            args: Prisma.DevStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevStatsPayload>
          }
          createMany: {
            args: Prisma.DevStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DevStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevStatsPayload>[]
          }
          delete: {
            args: Prisma.DevStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevStatsPayload>
          }
          update: {
            args: Prisma.DevStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevStatsPayload>
          }
          deleteMany: {
            args: Prisma.DevStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DevStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DevStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevStatsPayload>[]
          }
          upsert: {
            args: Prisma.DevStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevStatsPayload>
          }
          aggregate: {
            args: Prisma.DevStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevStats>
          }
          groupBy: {
            args: Prisma.DevStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DevStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DevStatsCountArgs<ExtArgs>
            result: $Utils.Optional<DevStatsCountAggregateOutputType> | number
          }
        }
      }
      ContributionData: {
        payload: Prisma.$ContributionDataPayload<ExtArgs>
        fields: Prisma.ContributionDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContributionDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContributionDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDataPayload>
          }
          findFirst: {
            args: Prisma.ContributionDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContributionDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDataPayload>
          }
          findMany: {
            args: Prisma.ContributionDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDataPayload>[]
          }
          create: {
            args: Prisma.ContributionDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDataPayload>
          }
          createMany: {
            args: Prisma.ContributionDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContributionDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDataPayload>[]
          }
          delete: {
            args: Prisma.ContributionDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDataPayload>
          }
          update: {
            args: Prisma.ContributionDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDataPayload>
          }
          deleteMany: {
            args: Prisma.ContributionDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContributionDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContributionDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDataPayload>[]
          }
          upsert: {
            args: Prisma.ContributionDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDataPayload>
          }
          aggregate: {
            args: Prisma.ContributionDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContributionData>
          }
          groupBy: {
            args: Prisma.ContributionDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContributionDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContributionDataCountArgs<ExtArgs>
            result: $Utils.Optional<ContributionDataCountAggregateOutputType> | number
          }
        }
      }
      ContributionDay: {
        payload: Prisma.$ContributionDayPayload<ExtArgs>
        fields: Prisma.ContributionDayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContributionDayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContributionDayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDayPayload>
          }
          findFirst: {
            args: Prisma.ContributionDayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContributionDayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDayPayload>
          }
          findMany: {
            args: Prisma.ContributionDayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDayPayload>[]
          }
          create: {
            args: Prisma.ContributionDayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDayPayload>
          }
          createMany: {
            args: Prisma.ContributionDayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContributionDayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDayPayload>[]
          }
          delete: {
            args: Prisma.ContributionDayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDayPayload>
          }
          update: {
            args: Prisma.ContributionDayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDayPayload>
          }
          deleteMany: {
            args: Prisma.ContributionDayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContributionDayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContributionDayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDayPayload>[]
          }
          upsert: {
            args: Prisma.ContributionDayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContributionDayPayload>
          }
          aggregate: {
            args: Prisma.ContributionDayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContributionDay>
          }
          groupBy: {
            args: Prisma.ContributionDayGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContributionDayGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContributionDayCountArgs<ExtArgs>
            result: $Utils.Optional<ContributionDayCountAggregateOutputType> | number
          }
        }
      }
      TimelineEvent: {
        payload: Prisma.$TimelineEventPayload<ExtArgs>
        fields: Prisma.TimelineEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimelineEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimelineEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>
          }
          findFirst: {
            args: Prisma.TimelineEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimelineEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>
          }
          findMany: {
            args: Prisma.TimelineEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>[]
          }
          create: {
            args: Prisma.TimelineEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>
          }
          createMany: {
            args: Prisma.TimelineEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimelineEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>[]
          }
          delete: {
            args: Prisma.TimelineEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>
          }
          update: {
            args: Prisma.TimelineEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>
          }
          deleteMany: {
            args: Prisma.TimelineEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimelineEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimelineEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>[]
          }
          upsert: {
            args: Prisma.TimelineEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineEventPayload>
          }
          aggregate: {
            args: Prisma.TimelineEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimelineEvent>
          }
          groupBy: {
            args: Prisma.TimelineEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimelineEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimelineEventCountArgs<ExtArgs>
            result: $Utils.Optional<TimelineEventCountAggregateOutputType> | number
          }
        }
      }
      ProjectTestimonial: {
        payload: Prisma.$ProjectTestimonialPayload<ExtArgs>
        fields: Prisma.ProjectTestimonialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectTestimonialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTestimonialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectTestimonialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTestimonialPayload>
          }
          findFirst: {
            args: Prisma.ProjectTestimonialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTestimonialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectTestimonialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTestimonialPayload>
          }
          findMany: {
            args: Prisma.ProjectTestimonialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTestimonialPayload>[]
          }
          create: {
            args: Prisma.ProjectTestimonialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTestimonialPayload>
          }
          createMany: {
            args: Prisma.ProjectTestimonialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectTestimonialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTestimonialPayload>[]
          }
          delete: {
            args: Prisma.ProjectTestimonialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTestimonialPayload>
          }
          update: {
            args: Prisma.ProjectTestimonialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTestimonialPayload>
          }
          deleteMany: {
            args: Prisma.ProjectTestimonialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectTestimonialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectTestimonialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTestimonialPayload>[]
          }
          upsert: {
            args: Prisma.ProjectTestimonialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTestimonialPayload>
          }
          aggregate: {
            args: Prisma.ProjectTestimonialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectTestimonial>
          }
          groupBy: {
            args: Prisma.ProjectTestimonialGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectTestimonialGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectTestimonialCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectTestimonialCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    skill?: SkillOmit
    project?: ProjectOmit
    projectFeature?: ProjectFeatureOmit
    projectTechStack?: ProjectTechStackOmit
    projectCollaborator?: ProjectCollaboratorOmit
    projectLearning?: ProjectLearningOmit
    workExperience?: WorkExperienceOmit
    workResponsibility?: WorkResponsibilityOmit
    workTechnology?: WorkTechnologyOmit
    workAchievement?: WorkAchievementOmit
    education?: EducationOmit
    educationAchievement?: EducationAchievementOmit
    certification?: CertificationOmit
    certificationSkill?: CertificationSkillOmit
    achievement?: AchievementOmit
    blogPost?: BlogPostOmit
    blogTag?: BlogTagOmit
    testimonial?: TestimonialOmit
    contact?: ContactOmit
    socialMedia?: SocialMediaOmit
    devStats?: DevStatsOmit
    contributionData?: ContributionDataOmit
    contributionDay?: ContributionDayOmit
    timelineEvent?: TimelineEventOmit
    projectTestimonial?: ProjectTestimonialOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    skills: number
    projects: number
    workExperiences: number
    educations: number
    certifications: number
    achievements: number
    blogPosts: number
    testimonials: number
    contacts: number
    socialMedia: number
    contributionData: number
    timelineEvents: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | UserCountOutputTypeCountSkillsArgs
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    workExperiences?: boolean | UserCountOutputTypeCountWorkExperiencesArgs
    educations?: boolean | UserCountOutputTypeCountEducationsArgs
    certifications?: boolean | UserCountOutputTypeCountCertificationsArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    blogPosts?: boolean | UserCountOutputTypeCountBlogPostsArgs
    testimonials?: boolean | UserCountOutputTypeCountTestimonialsArgs
    contacts?: boolean | UserCountOutputTypeCountContactsArgs
    socialMedia?: boolean | UserCountOutputTypeCountSocialMediaArgs
    contributionData?: boolean | UserCountOutputTypeCountContributionDataArgs
    timelineEvents?: boolean | UserCountOutputTypeCountTimelineEventsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkExperiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkExperienceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEducationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCertificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSocialMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialMediaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContributionDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContributionDataWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTimelineEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimelineEventWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    projects: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | SkillCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    features: number
    techStack: number
    collaborators: number
    learnings: number
    testimonials: number
    skills: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | ProjectCountOutputTypeCountFeaturesArgs
    techStack?: boolean | ProjectCountOutputTypeCountTechStackArgs
    collaborators?: boolean | ProjectCountOutputTypeCountCollaboratorsArgs
    learnings?: boolean | ProjectCountOutputTypeCountLearningsArgs
    testimonials?: boolean | ProjectCountOutputTypeCountTestimonialsArgs
    skills?: boolean | ProjectCountOutputTypeCountSkillsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectFeatureWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTechStackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTechStackWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCollaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectCollaboratorWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountLearningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectLearningWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTestimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTestimonialWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
  }


  /**
   * Count Type WorkExperienceCountOutputType
   */

  export type WorkExperienceCountOutputType = {
    responsibilities: number
    technologies: number
    achievements: number
  }

  export type WorkExperienceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsibilities?: boolean | WorkExperienceCountOutputTypeCountResponsibilitiesArgs
    technologies?: boolean | WorkExperienceCountOutputTypeCountTechnologiesArgs
    achievements?: boolean | WorkExperienceCountOutputTypeCountAchievementsArgs
  }

  // Custom InputTypes
  /**
   * WorkExperienceCountOutputType without action
   */
  export type WorkExperienceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperienceCountOutputType
     */
    select?: WorkExperienceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkExperienceCountOutputType without action
   */
  export type WorkExperienceCountOutputTypeCountResponsibilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkResponsibilityWhereInput
  }

  /**
   * WorkExperienceCountOutputType without action
   */
  export type WorkExperienceCountOutputTypeCountTechnologiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkTechnologyWhereInput
  }

  /**
   * WorkExperienceCountOutputType without action
   */
  export type WorkExperienceCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkAchievementWhereInput
  }


  /**
   * Count Type EducationCountOutputType
   */

  export type EducationCountOutputType = {
    achievements: number
  }

  export type EducationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievements?: boolean | EducationCountOutputTypeCountAchievementsArgs
  }

  // Custom InputTypes
  /**
   * EducationCountOutputType without action
   */
  export type EducationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationCountOutputType
     */
    select?: EducationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EducationCountOutputType without action
   */
  export type EducationCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationAchievementWhereInput
  }


  /**
   * Count Type CertificationCountOutputType
   */

  export type CertificationCountOutputType = {
    skills: number
  }

  export type CertificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | CertificationCountOutputTypeCountSkillsArgs
  }

  // Custom InputTypes
  /**
   * CertificationCountOutputType without action
   */
  export type CertificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationCountOutputType
     */
    select?: CertificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CertificationCountOutputType without action
   */
  export type CertificationCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationSkillWhereInput
  }


  /**
   * Count Type BlogPostCountOutputType
   */

  export type BlogPostCountOutputType = {
    tags: number
  }

  export type BlogPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | BlogPostCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostCountOutputType
     */
    select?: BlogPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogTagWhereInput
  }


  /**
   * Count Type TestimonialCountOutputType
   */

  export type TestimonialCountOutputType = {
    projectTestimonials: number
  }

  export type TestimonialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectTestimonials?: boolean | TestimonialCountOutputTypeCountProjectTestimonialsArgs
  }

  // Custom InputTypes
  /**
   * TestimonialCountOutputType without action
   */
  export type TestimonialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialCountOutputType
     */
    select?: TestimonialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestimonialCountOutputType without action
   */
  export type TestimonialCountOutputTypeCountProjectTestimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTestimonialWhereInput
  }


  /**
   * Count Type ContributionDataCountOutputType
   */

  export type ContributionDataCountOutputType = {
    days: number
  }

  export type ContributionDataCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    days?: boolean | ContributionDataCountOutputTypeCountDaysArgs
  }

  // Custom InputTypes
  /**
   * ContributionDataCountOutputType without action
   */
  export type ContributionDataCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionDataCountOutputType
     */
    select?: ContributionDataCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContributionDataCountOutputType without action
   */
  export type ContributionDataCountOutputTypeCountDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContributionDayWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    email: string | null
    phone: string | null
    location: string | null
    bio: string | null
    website: string | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    email: string | null
    phone: string | null
    location: string | null
    bio: string | null
    website: string | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    username: number
    email: number
    phone: number
    location: number
    bio: number
    website: number
    avatar: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    phone?: true
    location?: true
    bio?: true
    website?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    phone?: true
    location?: true
    bio?: true
    website?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    phone?: true
    location?: true
    bio?: true
    website?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    username: string
    email: string
    phone: string | null
    location: string | null
    bio: string | null
    website: string | null
    avatar: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    phone?: boolean
    location?: boolean
    bio?: boolean
    website?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skills?: boolean | User$skillsArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    workExperiences?: boolean | User$workExperiencesArgs<ExtArgs>
    educations?: boolean | User$educationsArgs<ExtArgs>
    certifications?: boolean | User$certificationsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    testimonials?: boolean | User$testimonialsArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    socialMedia?: boolean | User$socialMediaArgs<ExtArgs>
    devStats?: boolean | User$devStatsArgs<ExtArgs>
    contributionData?: boolean | User$contributionDataArgs<ExtArgs>
    timelineEvents?: boolean | User$timelineEventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    phone?: boolean
    location?: boolean
    bio?: boolean
    website?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    phone?: boolean
    location?: boolean
    bio?: boolean
    website?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    phone?: boolean
    location?: boolean
    bio?: boolean
    website?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "username" | "email" | "phone" | "location" | "bio" | "website" | "avatar" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | User$skillsArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    workExperiences?: boolean | User$workExperiencesArgs<ExtArgs>
    educations?: boolean | User$educationsArgs<ExtArgs>
    certifications?: boolean | User$certificationsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    testimonials?: boolean | User$testimonialsArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    socialMedia?: boolean | User$socialMediaArgs<ExtArgs>
    devStats?: boolean | User$devStatsArgs<ExtArgs>
    contributionData?: boolean | User$contributionDataArgs<ExtArgs>
    timelineEvents?: boolean | User$timelineEventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      skills: Prisma.$SkillPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      workExperiences: Prisma.$WorkExperiencePayload<ExtArgs>[]
      educations: Prisma.$EducationPayload<ExtArgs>[]
      certifications: Prisma.$CertificationPayload<ExtArgs>[]
      achievements: Prisma.$AchievementPayload<ExtArgs>[]
      blogPosts: Prisma.$BlogPostPayload<ExtArgs>[]
      testimonials: Prisma.$TestimonialPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      socialMedia: Prisma.$SocialMediaPayload<ExtArgs>[]
      devStats: Prisma.$DevStatsPayload<ExtArgs> | null
      contributionData: Prisma.$ContributionDataPayload<ExtArgs>[]
      timelineEvents: Prisma.$TimelineEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      username: string
      email: string
      phone: string | null
      location: string | null
      bio: string | null
      website: string | null
      avatar: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skills<T extends User$skillsArgs<ExtArgs> = {}>(args?: Subset<T, User$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workExperiences<T extends User$workExperiencesArgs<ExtArgs> = {}>(args?: Subset<T, User$workExperiencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    educations<T extends User$educationsArgs<ExtArgs> = {}>(args?: Subset<T, User$educationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certifications<T extends User$certificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$certificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blogPosts<T extends User$blogPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$blogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testimonials<T extends User$testimonialsArgs<ExtArgs> = {}>(args?: Subset<T, User$testimonialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends User$contactsArgs<ExtArgs> = {}>(args?: Subset<T, User$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    socialMedia<T extends User$socialMediaArgs<ExtArgs> = {}>(args?: Subset<T, User$socialMediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    devStats<T extends User$devStatsArgs<ExtArgs> = {}>(args?: Subset<T, User$devStatsArgs<ExtArgs>>): Prisma__DevStatsClient<$Result.GetResult<Prisma.$DevStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contributionData<T extends User$contributionDataArgs<ExtArgs> = {}>(args?: Subset<T, User$contributionDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContributionDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timelineEvents<T extends User$timelineEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$timelineEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly location: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly website: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.skills
   */
  export type User$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    cursor?: SkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.workExperiences
   */
  export type User$workExperiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    where?: WorkExperienceWhereInput
    orderBy?: WorkExperienceOrderByWithRelationInput | WorkExperienceOrderByWithRelationInput[]
    cursor?: WorkExperienceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkExperienceScalarFieldEnum | WorkExperienceScalarFieldEnum[]
  }

  /**
   * User.educations
   */
  export type User$educationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    where?: EducationWhereInput
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    cursor?: EducationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * User.certifications
   */
  export type User$certificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    cursor?: CertificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    cursor?: AchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * User.blogPosts
   */
  export type User$blogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * User.testimonials
   */
  export type User$testimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    cursor?: TestimonialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * User.contacts
   */
  export type User$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * User.socialMedia
   */
  export type User$socialMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMedia
     */
    select?: SocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMedia
     */
    omit?: SocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaInclude<ExtArgs> | null
    where?: SocialMediaWhereInput
    orderBy?: SocialMediaOrderByWithRelationInput | SocialMediaOrderByWithRelationInput[]
    cursor?: SocialMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialMediaScalarFieldEnum | SocialMediaScalarFieldEnum[]
  }

  /**
   * User.devStats
   */
  export type User$devStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevStats
     */
    select?: DevStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevStats
     */
    omit?: DevStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevStatsInclude<ExtArgs> | null
    where?: DevStatsWhereInput
  }

  /**
   * User.contributionData
   */
  export type User$contributionDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionData
     */
    select?: ContributionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionData
     */
    omit?: ContributionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDataInclude<ExtArgs> | null
    where?: ContributionDataWhereInput
    orderBy?: ContributionDataOrderByWithRelationInput | ContributionDataOrderByWithRelationInput[]
    cursor?: ContributionDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContributionDataScalarFieldEnum | ContributionDataScalarFieldEnum[]
  }

  /**
   * User.timelineEvents
   */
  export type User$timelineEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineEvent
     */
    omit?: TimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    where?: TimelineEventWhereInput
    orderBy?: TimelineEventOrderByWithRelationInput | TimelineEventOrderByWithRelationInput[]
    cursor?: TimelineEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimelineEventScalarFieldEnum | TimelineEventScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillAvgAggregateOutputType = {
    percentage: number | null
    years: number | null
  }

  export type SkillSumAggregateOutputType = {
    percentage: number | null
    years: number | null
  }

  export type SkillMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    percentage: number | null
    color: string | null
    icon: string | null
    category: string | null
    description: string | null
    years: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    percentage: number | null
    color: string | null
    icon: string | null
    category: string | null
    description: string | null
    years: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    percentage: number
    color: number
    icon: number
    category: number
    description: number
    years: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkillAvgAggregateInputType = {
    percentage?: true
    years?: true
  }

  export type SkillSumAggregateInputType = {
    percentage?: true
    years?: true
  }

  export type SkillMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    percentage?: true
    color?: true
    icon?: true
    category?: true
    description?: true
    years?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    percentage?: true
    color?: true
    icon?: true
    category?: true
    description?: true
    years?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    percentage?: true
    color?: true
    icon?: true
    category?: true
    description?: true
    years?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _avg?: SkillAvgAggregateInputType
    _sum?: SkillSumAggregateInputType
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: string
    userId: string
    name: string
    percentage: number
    color: string | null
    icon: string | null
    category: string | null
    description: string | null
    years: number | null
    createdAt: Date
    updatedAt: Date
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    percentage?: boolean
    color?: boolean
    icon?: boolean
    category?: boolean
    description?: boolean
    years?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    projects?: boolean | Skill$projectsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    percentage?: boolean
    color?: boolean
    icon?: boolean
    category?: boolean
    description?: boolean
    years?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    percentage?: boolean
    color?: boolean
    icon?: boolean
    category?: boolean
    description?: boolean
    years?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    percentage?: boolean
    color?: boolean
    icon?: boolean
    category?: boolean
    description?: boolean
    years?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "percentage" | "color" | "icon" | "category" | "description" | "years" | "createdAt" | "updatedAt", ExtArgs["result"]["skill"]>
  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    projects?: boolean | Skill$projectsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      projects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      percentage: number
      color: string | null
      icon: string | null
      category: string | null
      description: string | null
      years: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills and returns the data updated in the database.
     * @param {SkillUpdateManyAndReturnArgs} args - Arguments to update many Skills.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkillUpdateManyAndReturnArgs>(args: SelectSubset<T, SkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projects<T extends Skill$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'String'>
    readonly userId: FieldRef<"Skill", 'String'>
    readonly name: FieldRef<"Skill", 'String'>
    readonly percentage: FieldRef<"Skill", 'Int'>
    readonly color: FieldRef<"Skill", 'String'>
    readonly icon: FieldRef<"Skill", 'String'>
    readonly category: FieldRef<"Skill", 'String'>
    readonly description: FieldRef<"Skill", 'String'>
    readonly years: FieldRef<"Skill", 'Float'>
    readonly createdAt: FieldRef<"Skill", 'DateTime'>
    readonly updatedAt: FieldRef<"Skill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill createManyAndReturn
   */
  export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill updateManyAndReturn
   */
  export type SkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to delete.
     */
    limit?: number
  }

  /**
   * Skill.projects
   */
  export type Skill$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    branches: number | null
    stars: number | null
    views: number | null
    forks: number | null
    issues: number | null
    commits: number | null
  }

  export type ProjectSumAggregateOutputType = {
    branches: number | null
    stars: number | null
    views: number | null
    forks: number | null
    issues: number | null
    commits: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    slug: string | null
    description: string | null
    longDescription: string | null
    category: string | null
    image: string | null
    demoUrl: string | null
    githubUrl: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    branches: number | null
    stars: number | null
    views: number | null
    forks: number | null
    issues: number | null
    commits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    slug: string | null
    description: string | null
    longDescription: string | null
    category: string | null
    image: string | null
    demoUrl: string | null
    githubUrl: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    branches: number | null
    stars: number | null
    views: number | null
    forks: number | null
    issues: number | null
    commits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    slug: number
    description: number
    longDescription: number
    category: number
    image: number
    demoUrl: number
    githubUrl: number
    status: number
    startDate: number
    endDate: number
    branches: number
    stars: number
    views: number
    forks: number
    issues: number
    commits: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    branches?: true
    stars?: true
    views?: true
    forks?: true
    issues?: true
    commits?: true
  }

  export type ProjectSumAggregateInputType = {
    branches?: true
    stars?: true
    views?: true
    forks?: true
    issues?: true
    commits?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    slug?: true
    description?: true
    longDescription?: true
    category?: true
    image?: true
    demoUrl?: true
    githubUrl?: true
    status?: true
    startDate?: true
    endDate?: true
    branches?: true
    stars?: true
    views?: true
    forks?: true
    issues?: true
    commits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    slug?: true
    description?: true
    longDescription?: true
    category?: true
    image?: true
    demoUrl?: true
    githubUrl?: true
    status?: true
    startDate?: true
    endDate?: true
    branches?: true
    stars?: true
    views?: true
    forks?: true
    issues?: true
    commits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    slug?: true
    description?: true
    longDescription?: true
    category?: true
    image?: true
    demoUrl?: true
    githubUrl?: true
    status?: true
    startDate?: true
    endDate?: true
    branches?: true
    stars?: true
    views?: true
    forks?: true
    issues?: true
    commits?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    userId: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image: string | null
    demoUrl: string | null
    githubUrl: string | null
    status: string
    startDate: Date
    endDate: Date | null
    branches: number | null
    stars: number | null
    views: number | null
    forks: number | null
    issues: number | null
    commits: number | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    longDescription?: boolean
    category?: boolean
    image?: boolean
    demoUrl?: boolean
    githubUrl?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    branches?: boolean
    stars?: boolean
    views?: boolean
    forks?: boolean
    issues?: boolean
    commits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    features?: boolean | Project$featuresArgs<ExtArgs>
    techStack?: boolean | Project$techStackArgs<ExtArgs>
    collaborators?: boolean | Project$collaboratorsArgs<ExtArgs>
    learnings?: boolean | Project$learningsArgs<ExtArgs>
    testimonials?: boolean | Project$testimonialsArgs<ExtArgs>
    skills?: boolean | Project$skillsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    longDescription?: boolean
    category?: boolean
    image?: boolean
    demoUrl?: boolean
    githubUrl?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    branches?: boolean
    stars?: boolean
    views?: boolean
    forks?: boolean
    issues?: boolean
    commits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    longDescription?: boolean
    category?: boolean
    image?: boolean
    demoUrl?: boolean
    githubUrl?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    branches?: boolean
    stars?: boolean
    views?: boolean
    forks?: boolean
    issues?: boolean
    commits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    longDescription?: boolean
    category?: boolean
    image?: boolean
    demoUrl?: boolean
    githubUrl?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    branches?: boolean
    stars?: boolean
    views?: boolean
    forks?: boolean
    issues?: boolean
    commits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "slug" | "description" | "longDescription" | "category" | "image" | "demoUrl" | "githubUrl" | "status" | "startDate" | "endDate" | "branches" | "stars" | "views" | "forks" | "issues" | "commits" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    features?: boolean | Project$featuresArgs<ExtArgs>
    techStack?: boolean | Project$techStackArgs<ExtArgs>
    collaborators?: boolean | Project$collaboratorsArgs<ExtArgs>
    learnings?: boolean | Project$learningsArgs<ExtArgs>
    testimonials?: boolean | Project$testimonialsArgs<ExtArgs>
    skills?: boolean | Project$skillsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      features: Prisma.$ProjectFeaturePayload<ExtArgs>[]
      techStack: Prisma.$ProjectTechStackPayload<ExtArgs>[]
      collaborators: Prisma.$ProjectCollaboratorPayload<ExtArgs>[]
      learnings: Prisma.$ProjectLearningPayload<ExtArgs>[]
      testimonials: Prisma.$ProjectTestimonialPayload<ExtArgs>[]
      skills: Prisma.$SkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      slug: string
      description: string
      longDescription: string
      category: string
      image: string | null
      demoUrl: string | null
      githubUrl: string | null
      status: string
      startDate: Date
      endDate: Date | null
      branches: number | null
      stars: number | null
      views: number | null
      forks: number | null
      issues: number | null
      commits: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    features<T extends Project$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Project$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    techStack<T extends Project$techStackArgs<ExtArgs> = {}>(args?: Subset<T, Project$techStackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTechStackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collaborators<T extends Project$collaboratorsArgs<ExtArgs> = {}>(args?: Subset<T, Project$collaboratorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learnings<T extends Project$learningsArgs<ExtArgs> = {}>(args?: Subset<T, Project$learningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectLearningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testimonials<T extends Project$testimonialsArgs<ExtArgs> = {}>(args?: Subset<T, Project$testimonialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTestimonialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skills<T extends Project$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Project$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly userId: FieldRef<"Project", 'String'>
    readonly title: FieldRef<"Project", 'String'>
    readonly slug: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly longDescription: FieldRef<"Project", 'String'>
    readonly category: FieldRef<"Project", 'String'>
    readonly image: FieldRef<"Project", 'String'>
    readonly demoUrl: FieldRef<"Project", 'String'>
    readonly githubUrl: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'String'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly branches: FieldRef<"Project", 'Int'>
    readonly stars: FieldRef<"Project", 'Int'>
    readonly views: FieldRef<"Project", 'Int'>
    readonly forks: FieldRef<"Project", 'Int'>
    readonly issues: FieldRef<"Project", 'Int'>
    readonly commits: FieldRef<"Project", 'Int'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.features
   */
  export type Project$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFeature
     */
    select?: ProjectFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFeature
     */
    omit?: ProjectFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFeatureInclude<ExtArgs> | null
    where?: ProjectFeatureWhereInput
    orderBy?: ProjectFeatureOrderByWithRelationInput | ProjectFeatureOrderByWithRelationInput[]
    cursor?: ProjectFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectFeatureScalarFieldEnum | ProjectFeatureScalarFieldEnum[]
  }

  /**
   * Project.techStack
   */
  export type Project$techStackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTechStack
     */
    select?: ProjectTechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTechStack
     */
    omit?: ProjectTechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTechStackInclude<ExtArgs> | null
    where?: ProjectTechStackWhereInput
    orderBy?: ProjectTechStackOrderByWithRelationInput | ProjectTechStackOrderByWithRelationInput[]
    cursor?: ProjectTechStackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTechStackScalarFieldEnum | ProjectTechStackScalarFieldEnum[]
  }

  /**
   * Project.collaborators
   */
  export type Project$collaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectCollaborator
     */
    omit?: ProjectCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    where?: ProjectCollaboratorWhereInput
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    cursor?: ProjectCollaboratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectCollaboratorScalarFieldEnum | ProjectCollaboratorScalarFieldEnum[]
  }

  /**
   * Project.learnings
   */
  export type Project$learningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLearning
     */
    select?: ProjectLearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLearning
     */
    omit?: ProjectLearningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLearningInclude<ExtArgs> | null
    where?: ProjectLearningWhereInput
    orderBy?: ProjectLearningOrderByWithRelationInput | ProjectLearningOrderByWithRelationInput[]
    cursor?: ProjectLearningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectLearningScalarFieldEnum | ProjectLearningScalarFieldEnum[]
  }

  /**
   * Project.testimonials
   */
  export type Project$testimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTestimonial
     */
    select?: ProjectTestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTestimonial
     */
    omit?: ProjectTestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTestimonialInclude<ExtArgs> | null
    where?: ProjectTestimonialWhereInput
    orderBy?: ProjectTestimonialOrderByWithRelationInput | ProjectTestimonialOrderByWithRelationInput[]
    cursor?: ProjectTestimonialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTestimonialScalarFieldEnum | ProjectTestimonialScalarFieldEnum[]
  }

  /**
   * Project.skills
   */
  export type Project$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    cursor?: SkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectFeature
   */

  export type AggregateProjectFeature = {
    _count: ProjectFeatureCountAggregateOutputType | null
    _min: ProjectFeatureMinAggregateOutputType | null
    _max: ProjectFeatureMaxAggregateOutputType | null
  }

  export type ProjectFeatureMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    feature: string | null
  }

  export type ProjectFeatureMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    feature: string | null
  }

  export type ProjectFeatureCountAggregateOutputType = {
    id: number
    projectId: number
    feature: number
    _all: number
  }


  export type ProjectFeatureMinAggregateInputType = {
    id?: true
    projectId?: true
    feature?: true
  }

  export type ProjectFeatureMaxAggregateInputType = {
    id?: true
    projectId?: true
    feature?: true
  }

  export type ProjectFeatureCountAggregateInputType = {
    id?: true
    projectId?: true
    feature?: true
    _all?: true
  }

  export type ProjectFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectFeature to aggregate.
     */
    where?: ProjectFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFeatures to fetch.
     */
    orderBy?: ProjectFeatureOrderByWithRelationInput | ProjectFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectFeatures
    **/
    _count?: true | ProjectFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectFeatureMaxAggregateInputType
  }

  export type GetProjectFeatureAggregateType<T extends ProjectFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectFeature[P]>
      : GetScalarType<T[P], AggregateProjectFeature[P]>
  }




  export type ProjectFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectFeatureWhereInput
    orderBy?: ProjectFeatureOrderByWithAggregationInput | ProjectFeatureOrderByWithAggregationInput[]
    by: ProjectFeatureScalarFieldEnum[] | ProjectFeatureScalarFieldEnum
    having?: ProjectFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectFeatureCountAggregateInputType | true
    _min?: ProjectFeatureMinAggregateInputType
    _max?: ProjectFeatureMaxAggregateInputType
  }

  export type ProjectFeatureGroupByOutputType = {
    id: string
    projectId: string
    feature: string
    _count: ProjectFeatureCountAggregateOutputType | null
    _min: ProjectFeatureMinAggregateOutputType | null
    _max: ProjectFeatureMaxAggregateOutputType | null
  }

  type GetProjectFeatureGroupByPayload<T extends ProjectFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectFeatureGroupByOutputType[P]>
        }
      >
    >


  export type ProjectFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    feature?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectFeature"]>

  export type ProjectFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    feature?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectFeature"]>

  export type ProjectFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    feature?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectFeature"]>

  export type ProjectFeatureSelectScalar = {
    id?: boolean
    projectId?: boolean
    feature?: boolean
  }

  export type ProjectFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "feature", ExtArgs["result"]["projectFeature"]>
  export type ProjectFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectFeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectFeature"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      feature: string
    }, ExtArgs["result"]["projectFeature"]>
    composites: {}
  }

  type ProjectFeatureGetPayload<S extends boolean | null | undefined | ProjectFeatureDefaultArgs> = $Result.GetResult<Prisma.$ProjectFeaturePayload, S>

  type ProjectFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectFeatureCountAggregateInputType | true
    }

  export interface ProjectFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectFeature'], meta: { name: 'ProjectFeature' } }
    /**
     * Find zero or one ProjectFeature that matches the filter.
     * @param {ProjectFeatureFindUniqueArgs} args - Arguments to find a ProjectFeature
     * @example
     * // Get one ProjectFeature
     * const projectFeature = await prisma.projectFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFeatureFindUniqueArgs>(args: SelectSubset<T, ProjectFeatureFindUniqueArgs<ExtArgs>>): Prisma__ProjectFeatureClient<$Result.GetResult<Prisma.$ProjectFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFeatureFindUniqueOrThrowArgs} args - Arguments to find a ProjectFeature
     * @example
     * // Get one ProjectFeature
     * const projectFeature = await prisma.projectFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectFeatureClient<$Result.GetResult<Prisma.$ProjectFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFeatureFindFirstArgs} args - Arguments to find a ProjectFeature
     * @example
     * // Get one ProjectFeature
     * const projectFeature = await prisma.projectFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFeatureFindFirstArgs>(args?: SelectSubset<T, ProjectFeatureFindFirstArgs<ExtArgs>>): Prisma__ProjectFeatureClient<$Result.GetResult<Prisma.$ProjectFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFeatureFindFirstOrThrowArgs} args - Arguments to find a ProjectFeature
     * @example
     * // Get one ProjectFeature
     * const projectFeature = await prisma.projectFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectFeatureClient<$Result.GetResult<Prisma.$ProjectFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectFeatures
     * const projectFeatures = await prisma.projectFeature.findMany()
     * 
     * // Get first 10 ProjectFeatures
     * const projectFeatures = await prisma.projectFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectFeatureWithIdOnly = await prisma.projectFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFeatureFindManyArgs>(args?: SelectSubset<T, ProjectFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectFeature.
     * @param {ProjectFeatureCreateArgs} args - Arguments to create a ProjectFeature.
     * @example
     * // Create one ProjectFeature
     * const ProjectFeature = await prisma.projectFeature.create({
     *   data: {
     *     // ... data to create a ProjectFeature
     *   }
     * })
     * 
     */
    create<T extends ProjectFeatureCreateArgs>(args: SelectSubset<T, ProjectFeatureCreateArgs<ExtArgs>>): Prisma__ProjectFeatureClient<$Result.GetResult<Prisma.$ProjectFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectFeatures.
     * @param {ProjectFeatureCreateManyArgs} args - Arguments to create many ProjectFeatures.
     * @example
     * // Create many ProjectFeatures
     * const projectFeature = await prisma.projectFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectFeatureCreateManyArgs>(args?: SelectSubset<T, ProjectFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectFeatures and returns the data saved in the database.
     * @param {ProjectFeatureCreateManyAndReturnArgs} args - Arguments to create many ProjectFeatures.
     * @example
     * // Create many ProjectFeatures
     * const projectFeature = await prisma.projectFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectFeatures and only return the `id`
     * const projectFeatureWithIdOnly = await prisma.projectFeature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectFeature.
     * @param {ProjectFeatureDeleteArgs} args - Arguments to delete one ProjectFeature.
     * @example
     * // Delete one ProjectFeature
     * const ProjectFeature = await prisma.projectFeature.delete({
     *   where: {
     *     // ... filter to delete one ProjectFeature
     *   }
     * })
     * 
     */
    delete<T extends ProjectFeatureDeleteArgs>(args: SelectSubset<T, ProjectFeatureDeleteArgs<ExtArgs>>): Prisma__ProjectFeatureClient<$Result.GetResult<Prisma.$ProjectFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectFeature.
     * @param {ProjectFeatureUpdateArgs} args - Arguments to update one ProjectFeature.
     * @example
     * // Update one ProjectFeature
     * const projectFeature = await prisma.projectFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectFeatureUpdateArgs>(args: SelectSubset<T, ProjectFeatureUpdateArgs<ExtArgs>>): Prisma__ProjectFeatureClient<$Result.GetResult<Prisma.$ProjectFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectFeatures.
     * @param {ProjectFeatureDeleteManyArgs} args - Arguments to filter ProjectFeatures to delete.
     * @example
     * // Delete a few ProjectFeatures
     * const { count } = await prisma.projectFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectFeatureDeleteManyArgs>(args?: SelectSubset<T, ProjectFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectFeatures
     * const projectFeature = await prisma.projectFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectFeatureUpdateManyArgs>(args: SelectSubset<T, ProjectFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectFeatures and returns the data updated in the database.
     * @param {ProjectFeatureUpdateManyAndReturnArgs} args - Arguments to update many ProjectFeatures.
     * @example
     * // Update many ProjectFeatures
     * const projectFeature = await prisma.projectFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectFeatures and only return the `id`
     * const projectFeatureWithIdOnly = await prisma.projectFeature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectFeature.
     * @param {ProjectFeatureUpsertArgs} args - Arguments to update or create a ProjectFeature.
     * @example
     * // Update or create a ProjectFeature
     * const projectFeature = await prisma.projectFeature.upsert({
     *   create: {
     *     // ... data to create a ProjectFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectFeature we want to update
     *   }
     * })
     */
    upsert<T extends ProjectFeatureUpsertArgs>(args: SelectSubset<T, ProjectFeatureUpsertArgs<ExtArgs>>): Prisma__ProjectFeatureClient<$Result.GetResult<Prisma.$ProjectFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFeatureCountArgs} args - Arguments to filter ProjectFeatures to count.
     * @example
     * // Count the number of ProjectFeatures
     * const count = await prisma.projectFeature.count({
     *   where: {
     *     // ... the filter for the ProjectFeatures we want to count
     *   }
     * })
    **/
    count<T extends ProjectFeatureCountArgs>(
      args?: Subset<T, ProjectFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectFeatureAggregateArgs>(args: Subset<T, ProjectFeatureAggregateArgs>): Prisma.PrismaPromise<GetProjectFeatureAggregateType<T>>

    /**
     * Group by ProjectFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectFeatureGroupByArgs['orderBy'] }
        : { orderBy?: ProjectFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectFeature model
   */
  readonly fields: ProjectFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectFeature model
   */
  interface ProjectFeatureFieldRefs {
    readonly id: FieldRef<"ProjectFeature", 'String'>
    readonly projectId: FieldRef<"ProjectFeature", 'String'>
    readonly feature: FieldRef<"ProjectFeature", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectFeature findUnique
   */
  export type ProjectFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFeature
     */
    select?: ProjectFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFeature
     */
    omit?: ProjectFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFeature to fetch.
     */
    where: ProjectFeatureWhereUniqueInput
  }

  /**
   * ProjectFeature findUniqueOrThrow
   */
  export type ProjectFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFeature
     */
    select?: ProjectFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFeature
     */
    omit?: ProjectFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFeature to fetch.
     */
    where: ProjectFeatureWhereUniqueInput
  }

  /**
   * ProjectFeature findFirst
   */
  export type ProjectFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFeature
     */
    select?: ProjectFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFeature
     */
    omit?: ProjectFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFeature to fetch.
     */
    where?: ProjectFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFeatures to fetch.
     */
    orderBy?: ProjectFeatureOrderByWithRelationInput | ProjectFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectFeatures.
     */
    cursor?: ProjectFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectFeatures.
     */
    distinct?: ProjectFeatureScalarFieldEnum | ProjectFeatureScalarFieldEnum[]
  }

  /**
   * ProjectFeature findFirstOrThrow
   */
  export type ProjectFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFeature
     */
    select?: ProjectFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFeature
     */
    omit?: ProjectFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFeature to fetch.
     */
    where?: ProjectFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFeatures to fetch.
     */
    orderBy?: ProjectFeatureOrderByWithRelationInput | ProjectFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectFeatures.
     */
    cursor?: ProjectFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectFeatures.
     */
    distinct?: ProjectFeatureScalarFieldEnum | ProjectFeatureScalarFieldEnum[]
  }

  /**
   * ProjectFeature findMany
   */
  export type ProjectFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFeature
     */
    select?: ProjectFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFeature
     */
    omit?: ProjectFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFeatures to fetch.
     */
    where?: ProjectFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFeatures to fetch.
     */
    orderBy?: ProjectFeatureOrderByWithRelationInput | ProjectFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectFeatures.
     */
    cursor?: ProjectFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFeatures.
     */
    skip?: number
    distinct?: ProjectFeatureScalarFieldEnum | ProjectFeatureScalarFieldEnum[]
  }

  /**
   * ProjectFeature create
   */
  export type ProjectFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFeature
     */
    select?: ProjectFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFeature
     */
    omit?: ProjectFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectFeature.
     */
    data: XOR<ProjectFeatureCreateInput, ProjectFeatureUncheckedCreateInput>
  }

  /**
   * ProjectFeature createMany
   */
  export type ProjectFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectFeatures.
     */
    data: ProjectFeatureCreateManyInput | ProjectFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectFeature createManyAndReturn
   */
  export type ProjectFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFeature
     */
    select?: ProjectFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFeature
     */
    omit?: ProjectFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectFeatures.
     */
    data: ProjectFeatureCreateManyInput | ProjectFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectFeature update
   */
  export type ProjectFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFeature
     */
    select?: ProjectFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFeature
     */
    omit?: ProjectFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectFeature.
     */
    data: XOR<ProjectFeatureUpdateInput, ProjectFeatureUncheckedUpdateInput>
    /**
     * Choose, which ProjectFeature to update.
     */
    where: ProjectFeatureWhereUniqueInput
  }

  /**
   * ProjectFeature updateMany
   */
  export type ProjectFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectFeatures.
     */
    data: XOR<ProjectFeatureUpdateManyMutationInput, ProjectFeatureUncheckedUpdateManyInput>
    /**
     * Filter which ProjectFeatures to update
     */
    where?: ProjectFeatureWhereInput
    /**
     * Limit how many ProjectFeatures to update.
     */
    limit?: number
  }

  /**
   * ProjectFeature updateManyAndReturn
   */
  export type ProjectFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFeature
     */
    select?: ProjectFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFeature
     */
    omit?: ProjectFeatureOmit<ExtArgs> | null
    /**
     * The data used to update ProjectFeatures.
     */
    data: XOR<ProjectFeatureUpdateManyMutationInput, ProjectFeatureUncheckedUpdateManyInput>
    /**
     * Filter which ProjectFeatures to update
     */
    where?: ProjectFeatureWhereInput
    /**
     * Limit how many ProjectFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectFeature upsert
   */
  export type ProjectFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFeature
     */
    select?: ProjectFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFeature
     */
    omit?: ProjectFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectFeature to update in case it exists.
     */
    where: ProjectFeatureWhereUniqueInput
    /**
     * In case the ProjectFeature found by the `where` argument doesn't exist, create a new ProjectFeature with this data.
     */
    create: XOR<ProjectFeatureCreateInput, ProjectFeatureUncheckedCreateInput>
    /**
     * In case the ProjectFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectFeatureUpdateInput, ProjectFeatureUncheckedUpdateInput>
  }

  /**
   * ProjectFeature delete
   */
  export type ProjectFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFeature
     */
    select?: ProjectFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFeature
     */
    omit?: ProjectFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFeatureInclude<ExtArgs> | null
    /**
     * Filter which ProjectFeature to delete.
     */
    where: ProjectFeatureWhereUniqueInput
  }

  /**
   * ProjectFeature deleteMany
   */
  export type ProjectFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectFeatures to delete
     */
    where?: ProjectFeatureWhereInput
    /**
     * Limit how many ProjectFeatures to delete.
     */
    limit?: number
  }

  /**
   * ProjectFeature without action
   */
  export type ProjectFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFeature
     */
    select?: ProjectFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFeature
     */
    omit?: ProjectFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFeatureInclude<ExtArgs> | null
  }


  /**
   * Model ProjectTechStack
   */

  export type AggregateProjectTechStack = {
    _count: ProjectTechStackCountAggregateOutputType | null
    _min: ProjectTechStackMinAggregateOutputType | null
    _max: ProjectTechStackMaxAggregateOutputType | null
  }

  export type ProjectTechStackMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    tech: string | null
  }

  export type ProjectTechStackMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    tech: string | null
  }

  export type ProjectTechStackCountAggregateOutputType = {
    id: number
    projectId: number
    tech: number
    _all: number
  }


  export type ProjectTechStackMinAggregateInputType = {
    id?: true
    projectId?: true
    tech?: true
  }

  export type ProjectTechStackMaxAggregateInputType = {
    id?: true
    projectId?: true
    tech?: true
  }

  export type ProjectTechStackCountAggregateInputType = {
    id?: true
    projectId?: true
    tech?: true
    _all?: true
  }

  export type ProjectTechStackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTechStack to aggregate.
     */
    where?: ProjectTechStackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTechStacks to fetch.
     */
    orderBy?: ProjectTechStackOrderByWithRelationInput | ProjectTechStackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectTechStackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTechStacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTechStacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTechStacks
    **/
    _count?: true | ProjectTechStackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTechStackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTechStackMaxAggregateInputType
  }

  export type GetProjectTechStackAggregateType<T extends ProjectTechStackAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectTechStack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectTechStack[P]>
      : GetScalarType<T[P], AggregateProjectTechStack[P]>
  }




  export type ProjectTechStackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTechStackWhereInput
    orderBy?: ProjectTechStackOrderByWithAggregationInput | ProjectTechStackOrderByWithAggregationInput[]
    by: ProjectTechStackScalarFieldEnum[] | ProjectTechStackScalarFieldEnum
    having?: ProjectTechStackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTechStackCountAggregateInputType | true
    _min?: ProjectTechStackMinAggregateInputType
    _max?: ProjectTechStackMaxAggregateInputType
  }

  export type ProjectTechStackGroupByOutputType = {
    id: string
    projectId: string
    tech: string
    _count: ProjectTechStackCountAggregateOutputType | null
    _min: ProjectTechStackMinAggregateOutputType | null
    _max: ProjectTechStackMaxAggregateOutputType | null
  }

  type GetProjectTechStackGroupByPayload<T extends ProjectTechStackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectTechStackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectTechStackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectTechStackGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectTechStackGroupByOutputType[P]>
        }
      >
    >


  export type ProjectTechStackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    tech?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectTechStack"]>

  export type ProjectTechStackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    tech?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectTechStack"]>

  export type ProjectTechStackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    tech?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectTechStack"]>

  export type ProjectTechStackSelectScalar = {
    id?: boolean
    projectId?: boolean
    tech?: boolean
  }

  export type ProjectTechStackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "tech", ExtArgs["result"]["projectTechStack"]>
  export type ProjectTechStackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectTechStackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectTechStackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectTechStackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectTechStack"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      tech: string
    }, ExtArgs["result"]["projectTechStack"]>
    composites: {}
  }

  type ProjectTechStackGetPayload<S extends boolean | null | undefined | ProjectTechStackDefaultArgs> = $Result.GetResult<Prisma.$ProjectTechStackPayload, S>

  type ProjectTechStackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectTechStackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectTechStackCountAggregateInputType | true
    }

  export interface ProjectTechStackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectTechStack'], meta: { name: 'ProjectTechStack' } }
    /**
     * Find zero or one ProjectTechStack that matches the filter.
     * @param {ProjectTechStackFindUniqueArgs} args - Arguments to find a ProjectTechStack
     * @example
     * // Get one ProjectTechStack
     * const projectTechStack = await prisma.projectTechStack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectTechStackFindUniqueArgs>(args: SelectSubset<T, ProjectTechStackFindUniqueArgs<ExtArgs>>): Prisma__ProjectTechStackClient<$Result.GetResult<Prisma.$ProjectTechStackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectTechStack that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectTechStackFindUniqueOrThrowArgs} args - Arguments to find a ProjectTechStack
     * @example
     * // Get one ProjectTechStack
     * const projectTechStack = await prisma.projectTechStack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectTechStackFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectTechStackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectTechStackClient<$Result.GetResult<Prisma.$ProjectTechStackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectTechStack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTechStackFindFirstArgs} args - Arguments to find a ProjectTechStack
     * @example
     * // Get one ProjectTechStack
     * const projectTechStack = await prisma.projectTechStack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectTechStackFindFirstArgs>(args?: SelectSubset<T, ProjectTechStackFindFirstArgs<ExtArgs>>): Prisma__ProjectTechStackClient<$Result.GetResult<Prisma.$ProjectTechStackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectTechStack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTechStackFindFirstOrThrowArgs} args - Arguments to find a ProjectTechStack
     * @example
     * // Get one ProjectTechStack
     * const projectTechStack = await prisma.projectTechStack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectTechStackFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectTechStackFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectTechStackClient<$Result.GetResult<Prisma.$ProjectTechStackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectTechStacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTechStackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTechStacks
     * const projectTechStacks = await prisma.projectTechStack.findMany()
     * 
     * // Get first 10 ProjectTechStacks
     * const projectTechStacks = await prisma.projectTechStack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectTechStackWithIdOnly = await prisma.projectTechStack.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectTechStackFindManyArgs>(args?: SelectSubset<T, ProjectTechStackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTechStackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectTechStack.
     * @param {ProjectTechStackCreateArgs} args - Arguments to create a ProjectTechStack.
     * @example
     * // Create one ProjectTechStack
     * const ProjectTechStack = await prisma.projectTechStack.create({
     *   data: {
     *     // ... data to create a ProjectTechStack
     *   }
     * })
     * 
     */
    create<T extends ProjectTechStackCreateArgs>(args: SelectSubset<T, ProjectTechStackCreateArgs<ExtArgs>>): Prisma__ProjectTechStackClient<$Result.GetResult<Prisma.$ProjectTechStackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectTechStacks.
     * @param {ProjectTechStackCreateManyArgs} args - Arguments to create many ProjectTechStacks.
     * @example
     * // Create many ProjectTechStacks
     * const projectTechStack = await prisma.projectTechStack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectTechStackCreateManyArgs>(args?: SelectSubset<T, ProjectTechStackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectTechStacks and returns the data saved in the database.
     * @param {ProjectTechStackCreateManyAndReturnArgs} args - Arguments to create many ProjectTechStacks.
     * @example
     * // Create many ProjectTechStacks
     * const projectTechStack = await prisma.projectTechStack.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectTechStacks and only return the `id`
     * const projectTechStackWithIdOnly = await prisma.projectTechStack.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectTechStackCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectTechStackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTechStackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectTechStack.
     * @param {ProjectTechStackDeleteArgs} args - Arguments to delete one ProjectTechStack.
     * @example
     * // Delete one ProjectTechStack
     * const ProjectTechStack = await prisma.projectTechStack.delete({
     *   where: {
     *     // ... filter to delete one ProjectTechStack
     *   }
     * })
     * 
     */
    delete<T extends ProjectTechStackDeleteArgs>(args: SelectSubset<T, ProjectTechStackDeleteArgs<ExtArgs>>): Prisma__ProjectTechStackClient<$Result.GetResult<Prisma.$ProjectTechStackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectTechStack.
     * @param {ProjectTechStackUpdateArgs} args - Arguments to update one ProjectTechStack.
     * @example
     * // Update one ProjectTechStack
     * const projectTechStack = await prisma.projectTechStack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectTechStackUpdateArgs>(args: SelectSubset<T, ProjectTechStackUpdateArgs<ExtArgs>>): Prisma__ProjectTechStackClient<$Result.GetResult<Prisma.$ProjectTechStackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectTechStacks.
     * @param {ProjectTechStackDeleteManyArgs} args - Arguments to filter ProjectTechStacks to delete.
     * @example
     * // Delete a few ProjectTechStacks
     * const { count } = await prisma.projectTechStack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectTechStackDeleteManyArgs>(args?: SelectSubset<T, ProjectTechStackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTechStacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTechStackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTechStacks
     * const projectTechStack = await prisma.projectTechStack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectTechStackUpdateManyArgs>(args: SelectSubset<T, ProjectTechStackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTechStacks and returns the data updated in the database.
     * @param {ProjectTechStackUpdateManyAndReturnArgs} args - Arguments to update many ProjectTechStacks.
     * @example
     * // Update many ProjectTechStacks
     * const projectTechStack = await prisma.projectTechStack.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectTechStacks and only return the `id`
     * const projectTechStackWithIdOnly = await prisma.projectTechStack.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectTechStackUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectTechStackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTechStackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectTechStack.
     * @param {ProjectTechStackUpsertArgs} args - Arguments to update or create a ProjectTechStack.
     * @example
     * // Update or create a ProjectTechStack
     * const projectTechStack = await prisma.projectTechStack.upsert({
     *   create: {
     *     // ... data to create a ProjectTechStack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectTechStack we want to update
     *   }
     * })
     */
    upsert<T extends ProjectTechStackUpsertArgs>(args: SelectSubset<T, ProjectTechStackUpsertArgs<ExtArgs>>): Prisma__ProjectTechStackClient<$Result.GetResult<Prisma.$ProjectTechStackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectTechStacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTechStackCountArgs} args - Arguments to filter ProjectTechStacks to count.
     * @example
     * // Count the number of ProjectTechStacks
     * const count = await prisma.projectTechStack.count({
     *   where: {
     *     // ... the filter for the ProjectTechStacks we want to count
     *   }
     * })
    **/
    count<T extends ProjectTechStackCountArgs>(
      args?: Subset<T, ProjectTechStackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTechStackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectTechStack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTechStackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTechStackAggregateArgs>(args: Subset<T, ProjectTechStackAggregateArgs>): Prisma.PrismaPromise<GetProjectTechStackAggregateType<T>>

    /**
     * Group by ProjectTechStack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTechStackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectTechStackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectTechStackGroupByArgs['orderBy'] }
        : { orderBy?: ProjectTechStackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectTechStackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTechStackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectTechStack model
   */
  readonly fields: ProjectTechStackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectTechStack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectTechStackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectTechStack model
   */
  interface ProjectTechStackFieldRefs {
    readonly id: FieldRef<"ProjectTechStack", 'String'>
    readonly projectId: FieldRef<"ProjectTechStack", 'String'>
    readonly tech: FieldRef<"ProjectTechStack", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectTechStack findUnique
   */
  export type ProjectTechStackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTechStack
     */
    select?: ProjectTechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTechStack
     */
    omit?: ProjectTechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTechStackInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTechStack to fetch.
     */
    where: ProjectTechStackWhereUniqueInput
  }

  /**
   * ProjectTechStack findUniqueOrThrow
   */
  export type ProjectTechStackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTechStack
     */
    select?: ProjectTechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTechStack
     */
    omit?: ProjectTechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTechStackInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTechStack to fetch.
     */
    where: ProjectTechStackWhereUniqueInput
  }

  /**
   * ProjectTechStack findFirst
   */
  export type ProjectTechStackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTechStack
     */
    select?: ProjectTechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTechStack
     */
    omit?: ProjectTechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTechStackInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTechStack to fetch.
     */
    where?: ProjectTechStackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTechStacks to fetch.
     */
    orderBy?: ProjectTechStackOrderByWithRelationInput | ProjectTechStackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTechStacks.
     */
    cursor?: ProjectTechStackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTechStacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTechStacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTechStacks.
     */
    distinct?: ProjectTechStackScalarFieldEnum | ProjectTechStackScalarFieldEnum[]
  }

  /**
   * ProjectTechStack findFirstOrThrow
   */
  export type ProjectTechStackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTechStack
     */
    select?: ProjectTechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTechStack
     */
    omit?: ProjectTechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTechStackInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTechStack to fetch.
     */
    where?: ProjectTechStackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTechStacks to fetch.
     */
    orderBy?: ProjectTechStackOrderByWithRelationInput | ProjectTechStackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTechStacks.
     */
    cursor?: ProjectTechStackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTechStacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTechStacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTechStacks.
     */
    distinct?: ProjectTechStackScalarFieldEnum | ProjectTechStackScalarFieldEnum[]
  }

  /**
   * ProjectTechStack findMany
   */
  export type ProjectTechStackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTechStack
     */
    select?: ProjectTechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTechStack
     */
    omit?: ProjectTechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTechStackInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTechStacks to fetch.
     */
    where?: ProjectTechStackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTechStacks to fetch.
     */
    orderBy?: ProjectTechStackOrderByWithRelationInput | ProjectTechStackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTechStacks.
     */
    cursor?: ProjectTechStackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTechStacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTechStacks.
     */
    skip?: number
    distinct?: ProjectTechStackScalarFieldEnum | ProjectTechStackScalarFieldEnum[]
  }

  /**
   * ProjectTechStack create
   */
  export type ProjectTechStackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTechStack
     */
    select?: ProjectTechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTechStack
     */
    omit?: ProjectTechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTechStackInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectTechStack.
     */
    data: XOR<ProjectTechStackCreateInput, ProjectTechStackUncheckedCreateInput>
  }

  /**
   * ProjectTechStack createMany
   */
  export type ProjectTechStackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectTechStacks.
     */
    data: ProjectTechStackCreateManyInput | ProjectTechStackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectTechStack createManyAndReturn
   */
  export type ProjectTechStackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTechStack
     */
    select?: ProjectTechStackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTechStack
     */
    omit?: ProjectTechStackOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectTechStacks.
     */
    data: ProjectTechStackCreateManyInput | ProjectTechStackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTechStackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectTechStack update
   */
  export type ProjectTechStackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTechStack
     */
    select?: ProjectTechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTechStack
     */
    omit?: ProjectTechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTechStackInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectTechStack.
     */
    data: XOR<ProjectTechStackUpdateInput, ProjectTechStackUncheckedUpdateInput>
    /**
     * Choose, which ProjectTechStack to update.
     */
    where: ProjectTechStackWhereUniqueInput
  }

  /**
   * ProjectTechStack updateMany
   */
  export type ProjectTechStackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectTechStacks.
     */
    data: XOR<ProjectTechStackUpdateManyMutationInput, ProjectTechStackUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTechStacks to update
     */
    where?: ProjectTechStackWhereInput
    /**
     * Limit how many ProjectTechStacks to update.
     */
    limit?: number
  }

  /**
   * ProjectTechStack updateManyAndReturn
   */
  export type ProjectTechStackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTechStack
     */
    select?: ProjectTechStackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTechStack
     */
    omit?: ProjectTechStackOmit<ExtArgs> | null
    /**
     * The data used to update ProjectTechStacks.
     */
    data: XOR<ProjectTechStackUpdateManyMutationInput, ProjectTechStackUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTechStacks to update
     */
    where?: ProjectTechStackWhereInput
    /**
     * Limit how many ProjectTechStacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTechStackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectTechStack upsert
   */
  export type ProjectTechStackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTechStack
     */
    select?: ProjectTechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTechStack
     */
    omit?: ProjectTechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTechStackInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectTechStack to update in case it exists.
     */
    where: ProjectTechStackWhereUniqueInput
    /**
     * In case the ProjectTechStack found by the `where` argument doesn't exist, create a new ProjectTechStack with this data.
     */
    create: XOR<ProjectTechStackCreateInput, ProjectTechStackUncheckedCreateInput>
    /**
     * In case the ProjectTechStack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectTechStackUpdateInput, ProjectTechStackUncheckedUpdateInput>
  }

  /**
   * ProjectTechStack delete
   */
  export type ProjectTechStackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTechStack
     */
    select?: ProjectTechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTechStack
     */
    omit?: ProjectTechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTechStackInclude<ExtArgs> | null
    /**
     * Filter which ProjectTechStack to delete.
     */
    where: ProjectTechStackWhereUniqueInput
  }

  /**
   * ProjectTechStack deleteMany
   */
  export type ProjectTechStackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTechStacks to delete
     */
    where?: ProjectTechStackWhereInput
    /**
     * Limit how many ProjectTechStacks to delete.
     */
    limit?: number
  }

  /**
   * ProjectTechStack without action
   */
  export type ProjectTechStackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTechStack
     */
    select?: ProjectTechStackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTechStack
     */
    omit?: ProjectTechStackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTechStackInclude<ExtArgs> | null
  }


  /**
   * Model ProjectCollaborator
   */

  export type AggregateProjectCollaborator = {
    _count: ProjectCollaboratorCountAggregateOutputType | null
    _min: ProjectCollaboratorMinAggregateOutputType | null
    _max: ProjectCollaboratorMaxAggregateOutputType | null
  }

  export type ProjectCollaboratorMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    username: string | null
  }

  export type ProjectCollaboratorMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    username: string | null
  }

  export type ProjectCollaboratorCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    username: number
    _all: number
  }


  export type ProjectCollaboratorMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    username?: true
  }

  export type ProjectCollaboratorMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    username?: true
  }

  export type ProjectCollaboratorCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    username?: true
    _all?: true
  }

  export type ProjectCollaboratorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectCollaborator to aggregate.
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectCollaborators to fetch.
     */
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectCollaborators
    **/
    _count?: true | ProjectCollaboratorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectCollaboratorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectCollaboratorMaxAggregateInputType
  }

  export type GetProjectCollaboratorAggregateType<T extends ProjectCollaboratorAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectCollaborator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectCollaborator[P]>
      : GetScalarType<T[P], AggregateProjectCollaborator[P]>
  }




  export type ProjectCollaboratorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectCollaboratorWhereInput
    orderBy?: ProjectCollaboratorOrderByWithAggregationInput | ProjectCollaboratorOrderByWithAggregationInput[]
    by: ProjectCollaboratorScalarFieldEnum[] | ProjectCollaboratorScalarFieldEnum
    having?: ProjectCollaboratorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCollaboratorCountAggregateInputType | true
    _min?: ProjectCollaboratorMinAggregateInputType
    _max?: ProjectCollaboratorMaxAggregateInputType
  }

  export type ProjectCollaboratorGroupByOutputType = {
    id: string
    projectId: string
    name: string
    username: string
    _count: ProjectCollaboratorCountAggregateOutputType | null
    _min: ProjectCollaboratorMinAggregateOutputType | null
    _max: ProjectCollaboratorMaxAggregateOutputType | null
  }

  type GetProjectCollaboratorGroupByPayload<T extends ProjectCollaboratorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectCollaboratorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectCollaboratorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectCollaboratorGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectCollaboratorGroupByOutputType[P]>
        }
      >
    >


  export type ProjectCollaboratorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    username?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectCollaborator"]>

  export type ProjectCollaboratorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    username?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectCollaborator"]>

  export type ProjectCollaboratorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    username?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectCollaborator"]>

  export type ProjectCollaboratorSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    username?: boolean
  }

  export type ProjectCollaboratorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "username", ExtArgs["result"]["projectCollaborator"]>
  export type ProjectCollaboratorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectCollaboratorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectCollaboratorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectCollaboratorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectCollaborator"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      username: string
    }, ExtArgs["result"]["projectCollaborator"]>
    composites: {}
  }

  type ProjectCollaboratorGetPayload<S extends boolean | null | undefined | ProjectCollaboratorDefaultArgs> = $Result.GetResult<Prisma.$ProjectCollaboratorPayload, S>

  type ProjectCollaboratorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectCollaboratorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCollaboratorCountAggregateInputType | true
    }

  export interface ProjectCollaboratorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectCollaborator'], meta: { name: 'ProjectCollaborator' } }
    /**
     * Find zero or one ProjectCollaborator that matches the filter.
     * @param {ProjectCollaboratorFindUniqueArgs} args - Arguments to find a ProjectCollaborator
     * @example
     * // Get one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectCollaboratorFindUniqueArgs>(args: SelectSubset<T, ProjectCollaboratorFindUniqueArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectCollaborator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectCollaboratorFindUniqueOrThrowArgs} args - Arguments to find a ProjectCollaborator
     * @example
     * // Get one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectCollaboratorFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectCollaboratorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectCollaborator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorFindFirstArgs} args - Arguments to find a ProjectCollaborator
     * @example
     * // Get one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectCollaboratorFindFirstArgs>(args?: SelectSubset<T, ProjectCollaboratorFindFirstArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectCollaborator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorFindFirstOrThrowArgs} args - Arguments to find a ProjectCollaborator
     * @example
     * // Get one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectCollaboratorFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectCollaboratorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectCollaborators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectCollaborators
     * const projectCollaborators = await prisma.projectCollaborator.findMany()
     * 
     * // Get first 10 ProjectCollaborators
     * const projectCollaborators = await prisma.projectCollaborator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectCollaboratorWithIdOnly = await prisma.projectCollaborator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectCollaboratorFindManyArgs>(args?: SelectSubset<T, ProjectCollaboratorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectCollaborator.
     * @param {ProjectCollaboratorCreateArgs} args - Arguments to create a ProjectCollaborator.
     * @example
     * // Create one ProjectCollaborator
     * const ProjectCollaborator = await prisma.projectCollaborator.create({
     *   data: {
     *     // ... data to create a ProjectCollaborator
     *   }
     * })
     * 
     */
    create<T extends ProjectCollaboratorCreateArgs>(args: SelectSubset<T, ProjectCollaboratorCreateArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectCollaborators.
     * @param {ProjectCollaboratorCreateManyArgs} args - Arguments to create many ProjectCollaborators.
     * @example
     * // Create many ProjectCollaborators
     * const projectCollaborator = await prisma.projectCollaborator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCollaboratorCreateManyArgs>(args?: SelectSubset<T, ProjectCollaboratorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectCollaborators and returns the data saved in the database.
     * @param {ProjectCollaboratorCreateManyAndReturnArgs} args - Arguments to create many ProjectCollaborators.
     * @example
     * // Create many ProjectCollaborators
     * const projectCollaborator = await prisma.projectCollaborator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectCollaborators and only return the `id`
     * const projectCollaboratorWithIdOnly = await prisma.projectCollaborator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCollaboratorCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCollaboratorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectCollaborator.
     * @param {ProjectCollaboratorDeleteArgs} args - Arguments to delete one ProjectCollaborator.
     * @example
     * // Delete one ProjectCollaborator
     * const ProjectCollaborator = await prisma.projectCollaborator.delete({
     *   where: {
     *     // ... filter to delete one ProjectCollaborator
     *   }
     * })
     * 
     */
    delete<T extends ProjectCollaboratorDeleteArgs>(args: SelectSubset<T, ProjectCollaboratorDeleteArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectCollaborator.
     * @param {ProjectCollaboratorUpdateArgs} args - Arguments to update one ProjectCollaborator.
     * @example
     * // Update one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectCollaboratorUpdateArgs>(args: SelectSubset<T, ProjectCollaboratorUpdateArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectCollaborators.
     * @param {ProjectCollaboratorDeleteManyArgs} args - Arguments to filter ProjectCollaborators to delete.
     * @example
     * // Delete a few ProjectCollaborators
     * const { count } = await prisma.projectCollaborator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectCollaboratorDeleteManyArgs>(args?: SelectSubset<T, ProjectCollaboratorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectCollaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectCollaborators
     * const projectCollaborator = await prisma.projectCollaborator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectCollaboratorUpdateManyArgs>(args: SelectSubset<T, ProjectCollaboratorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectCollaborators and returns the data updated in the database.
     * @param {ProjectCollaboratorUpdateManyAndReturnArgs} args - Arguments to update many ProjectCollaborators.
     * @example
     * // Update many ProjectCollaborators
     * const projectCollaborator = await prisma.projectCollaborator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectCollaborators and only return the `id`
     * const projectCollaboratorWithIdOnly = await prisma.projectCollaborator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectCollaboratorUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectCollaboratorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectCollaborator.
     * @param {ProjectCollaboratorUpsertArgs} args - Arguments to update or create a ProjectCollaborator.
     * @example
     * // Update or create a ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.upsert({
     *   create: {
     *     // ... data to create a ProjectCollaborator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectCollaborator we want to update
     *   }
     * })
     */
    upsert<T extends ProjectCollaboratorUpsertArgs>(args: SelectSubset<T, ProjectCollaboratorUpsertArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectCollaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorCountArgs} args - Arguments to filter ProjectCollaborators to count.
     * @example
     * // Count the number of ProjectCollaborators
     * const count = await prisma.projectCollaborator.count({
     *   where: {
     *     // ... the filter for the ProjectCollaborators we want to count
     *   }
     * })
    **/
    count<T extends ProjectCollaboratorCountArgs>(
      args?: Subset<T, ProjectCollaboratorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCollaboratorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectCollaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectCollaboratorAggregateArgs>(args: Subset<T, ProjectCollaboratorAggregateArgs>): Prisma.PrismaPromise<GetProjectCollaboratorAggregateType<T>>

    /**
     * Group by ProjectCollaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectCollaboratorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectCollaboratorGroupByArgs['orderBy'] }
        : { orderBy?: ProjectCollaboratorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectCollaboratorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectCollaboratorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectCollaborator model
   */
  readonly fields: ProjectCollaboratorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectCollaborator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectCollaboratorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectCollaborator model
   */
  interface ProjectCollaboratorFieldRefs {
    readonly id: FieldRef<"ProjectCollaborator", 'String'>
    readonly projectId: FieldRef<"ProjectCollaborator", 'String'>
    readonly name: FieldRef<"ProjectCollaborator", 'String'>
    readonly username: FieldRef<"ProjectCollaborator", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectCollaborator findUnique
   */
  export type ProjectCollaboratorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectCollaborator
     */
    omit?: ProjectCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborator to fetch.
     */
    where: ProjectCollaboratorWhereUniqueInput
  }

  /**
   * ProjectCollaborator findUniqueOrThrow
   */
  export type ProjectCollaboratorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectCollaborator
     */
    omit?: ProjectCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborator to fetch.
     */
    where: ProjectCollaboratorWhereUniqueInput
  }

  /**
   * ProjectCollaborator findFirst
   */
  export type ProjectCollaboratorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectCollaborator
     */
    omit?: ProjectCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborator to fetch.
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectCollaborators to fetch.
     */
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectCollaborators.
     */
    cursor?: ProjectCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectCollaborators.
     */
    distinct?: ProjectCollaboratorScalarFieldEnum | ProjectCollaboratorScalarFieldEnum[]
  }

  /**
   * ProjectCollaborator findFirstOrThrow
   */
  export type ProjectCollaboratorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectCollaborator
     */
    omit?: ProjectCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborator to fetch.
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectCollaborators to fetch.
     */
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectCollaborators.
     */
    cursor?: ProjectCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectCollaborators.
     */
    distinct?: ProjectCollaboratorScalarFieldEnum | ProjectCollaboratorScalarFieldEnum[]
  }

  /**
   * ProjectCollaborator findMany
   */
  export type ProjectCollaboratorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectCollaborator
     */
    omit?: ProjectCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborators to fetch.
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectCollaborators to fetch.
     */
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectCollaborators.
     */
    cursor?: ProjectCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectCollaborators.
     */
    skip?: number
    distinct?: ProjectCollaboratorScalarFieldEnum | ProjectCollaboratorScalarFieldEnum[]
  }

  /**
   * ProjectCollaborator create
   */
  export type ProjectCollaboratorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectCollaborator
     */
    omit?: ProjectCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectCollaborator.
     */
    data: XOR<ProjectCollaboratorCreateInput, ProjectCollaboratorUncheckedCreateInput>
  }

  /**
   * ProjectCollaborator createMany
   */
  export type ProjectCollaboratorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectCollaborators.
     */
    data: ProjectCollaboratorCreateManyInput | ProjectCollaboratorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectCollaborator createManyAndReturn
   */
  export type ProjectCollaboratorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectCollaborator
     */
    omit?: ProjectCollaboratorOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectCollaborators.
     */
    data: ProjectCollaboratorCreateManyInput | ProjectCollaboratorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectCollaborator update
   */
  export type ProjectCollaboratorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectCollaborator
     */
    omit?: ProjectCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectCollaborator.
     */
    data: XOR<ProjectCollaboratorUpdateInput, ProjectCollaboratorUncheckedUpdateInput>
    /**
     * Choose, which ProjectCollaborator to update.
     */
    where: ProjectCollaboratorWhereUniqueInput
  }

  /**
   * ProjectCollaborator updateMany
   */
  export type ProjectCollaboratorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectCollaborators.
     */
    data: XOR<ProjectCollaboratorUpdateManyMutationInput, ProjectCollaboratorUncheckedUpdateManyInput>
    /**
     * Filter which ProjectCollaborators to update
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * Limit how many ProjectCollaborators to update.
     */
    limit?: number
  }

  /**
   * ProjectCollaborator updateManyAndReturn
   */
  export type ProjectCollaboratorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectCollaborator
     */
    omit?: ProjectCollaboratorOmit<ExtArgs> | null
    /**
     * The data used to update ProjectCollaborators.
     */
    data: XOR<ProjectCollaboratorUpdateManyMutationInput, ProjectCollaboratorUncheckedUpdateManyInput>
    /**
     * Filter which ProjectCollaborators to update
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * Limit how many ProjectCollaborators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectCollaborator upsert
   */
  export type ProjectCollaboratorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectCollaborator
     */
    omit?: ProjectCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectCollaborator to update in case it exists.
     */
    where: ProjectCollaboratorWhereUniqueInput
    /**
     * In case the ProjectCollaborator found by the `where` argument doesn't exist, create a new ProjectCollaborator with this data.
     */
    create: XOR<ProjectCollaboratorCreateInput, ProjectCollaboratorUncheckedCreateInput>
    /**
     * In case the ProjectCollaborator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectCollaboratorUpdateInput, ProjectCollaboratorUncheckedUpdateInput>
  }

  /**
   * ProjectCollaborator delete
   */
  export type ProjectCollaboratorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectCollaborator
     */
    omit?: ProjectCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter which ProjectCollaborator to delete.
     */
    where: ProjectCollaboratorWhereUniqueInput
  }

  /**
   * ProjectCollaborator deleteMany
   */
  export type ProjectCollaboratorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectCollaborators to delete
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * Limit how many ProjectCollaborators to delete.
     */
    limit?: number
  }

  /**
   * ProjectCollaborator without action
   */
  export type ProjectCollaboratorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectCollaborator
     */
    omit?: ProjectCollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
  }


  /**
   * Model ProjectLearning
   */

  export type AggregateProjectLearning = {
    _count: ProjectLearningCountAggregateOutputType | null
    _min: ProjectLearningMinAggregateOutputType | null
    _max: ProjectLearningMaxAggregateOutputType | null
  }

  export type ProjectLearningMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    learning: string | null
  }

  export type ProjectLearningMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    learning: string | null
  }

  export type ProjectLearningCountAggregateOutputType = {
    id: number
    projectId: number
    learning: number
    _all: number
  }


  export type ProjectLearningMinAggregateInputType = {
    id?: true
    projectId?: true
    learning?: true
  }

  export type ProjectLearningMaxAggregateInputType = {
    id?: true
    projectId?: true
    learning?: true
  }

  export type ProjectLearningCountAggregateInputType = {
    id?: true
    projectId?: true
    learning?: true
    _all?: true
  }

  export type ProjectLearningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectLearning to aggregate.
     */
    where?: ProjectLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectLearnings to fetch.
     */
    orderBy?: ProjectLearningOrderByWithRelationInput | ProjectLearningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectLearnings
    **/
    _count?: true | ProjectLearningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectLearningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectLearningMaxAggregateInputType
  }

  export type GetProjectLearningAggregateType<T extends ProjectLearningAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectLearning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectLearning[P]>
      : GetScalarType<T[P], AggregateProjectLearning[P]>
  }




  export type ProjectLearningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectLearningWhereInput
    orderBy?: ProjectLearningOrderByWithAggregationInput | ProjectLearningOrderByWithAggregationInput[]
    by: ProjectLearningScalarFieldEnum[] | ProjectLearningScalarFieldEnum
    having?: ProjectLearningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectLearningCountAggregateInputType | true
    _min?: ProjectLearningMinAggregateInputType
    _max?: ProjectLearningMaxAggregateInputType
  }

  export type ProjectLearningGroupByOutputType = {
    id: string
    projectId: string
    learning: string
    _count: ProjectLearningCountAggregateOutputType | null
    _min: ProjectLearningMinAggregateOutputType | null
    _max: ProjectLearningMaxAggregateOutputType | null
  }

  type GetProjectLearningGroupByPayload<T extends ProjectLearningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectLearningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectLearningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectLearningGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectLearningGroupByOutputType[P]>
        }
      >
    >


  export type ProjectLearningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    learning?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectLearning"]>

  export type ProjectLearningSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    learning?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectLearning"]>

  export type ProjectLearningSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    learning?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectLearning"]>

  export type ProjectLearningSelectScalar = {
    id?: boolean
    projectId?: boolean
    learning?: boolean
  }

  export type ProjectLearningOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "learning", ExtArgs["result"]["projectLearning"]>
  export type ProjectLearningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectLearningIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectLearningIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectLearningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectLearning"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      learning: string
    }, ExtArgs["result"]["projectLearning"]>
    composites: {}
  }

  type ProjectLearningGetPayload<S extends boolean | null | undefined | ProjectLearningDefaultArgs> = $Result.GetResult<Prisma.$ProjectLearningPayload, S>

  type ProjectLearningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectLearningFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectLearningCountAggregateInputType | true
    }

  export interface ProjectLearningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectLearning'], meta: { name: 'ProjectLearning' } }
    /**
     * Find zero or one ProjectLearning that matches the filter.
     * @param {ProjectLearningFindUniqueArgs} args - Arguments to find a ProjectLearning
     * @example
     * // Get one ProjectLearning
     * const projectLearning = await prisma.projectLearning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectLearningFindUniqueArgs>(args: SelectSubset<T, ProjectLearningFindUniqueArgs<ExtArgs>>): Prisma__ProjectLearningClient<$Result.GetResult<Prisma.$ProjectLearningPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectLearning that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectLearningFindUniqueOrThrowArgs} args - Arguments to find a ProjectLearning
     * @example
     * // Get one ProjectLearning
     * const projectLearning = await prisma.projectLearning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectLearningFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectLearningFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectLearningClient<$Result.GetResult<Prisma.$ProjectLearningPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectLearning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectLearningFindFirstArgs} args - Arguments to find a ProjectLearning
     * @example
     * // Get one ProjectLearning
     * const projectLearning = await prisma.projectLearning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectLearningFindFirstArgs>(args?: SelectSubset<T, ProjectLearningFindFirstArgs<ExtArgs>>): Prisma__ProjectLearningClient<$Result.GetResult<Prisma.$ProjectLearningPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectLearning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectLearningFindFirstOrThrowArgs} args - Arguments to find a ProjectLearning
     * @example
     * // Get one ProjectLearning
     * const projectLearning = await prisma.projectLearning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectLearningFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectLearningFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectLearningClient<$Result.GetResult<Prisma.$ProjectLearningPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectLearnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectLearningFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectLearnings
     * const projectLearnings = await prisma.projectLearning.findMany()
     * 
     * // Get first 10 ProjectLearnings
     * const projectLearnings = await prisma.projectLearning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectLearningWithIdOnly = await prisma.projectLearning.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectLearningFindManyArgs>(args?: SelectSubset<T, ProjectLearningFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectLearningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectLearning.
     * @param {ProjectLearningCreateArgs} args - Arguments to create a ProjectLearning.
     * @example
     * // Create one ProjectLearning
     * const ProjectLearning = await prisma.projectLearning.create({
     *   data: {
     *     // ... data to create a ProjectLearning
     *   }
     * })
     * 
     */
    create<T extends ProjectLearningCreateArgs>(args: SelectSubset<T, ProjectLearningCreateArgs<ExtArgs>>): Prisma__ProjectLearningClient<$Result.GetResult<Prisma.$ProjectLearningPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectLearnings.
     * @param {ProjectLearningCreateManyArgs} args - Arguments to create many ProjectLearnings.
     * @example
     * // Create many ProjectLearnings
     * const projectLearning = await prisma.projectLearning.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectLearningCreateManyArgs>(args?: SelectSubset<T, ProjectLearningCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectLearnings and returns the data saved in the database.
     * @param {ProjectLearningCreateManyAndReturnArgs} args - Arguments to create many ProjectLearnings.
     * @example
     * // Create many ProjectLearnings
     * const projectLearning = await prisma.projectLearning.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectLearnings and only return the `id`
     * const projectLearningWithIdOnly = await prisma.projectLearning.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectLearningCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectLearningCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectLearningPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectLearning.
     * @param {ProjectLearningDeleteArgs} args - Arguments to delete one ProjectLearning.
     * @example
     * // Delete one ProjectLearning
     * const ProjectLearning = await prisma.projectLearning.delete({
     *   where: {
     *     // ... filter to delete one ProjectLearning
     *   }
     * })
     * 
     */
    delete<T extends ProjectLearningDeleteArgs>(args: SelectSubset<T, ProjectLearningDeleteArgs<ExtArgs>>): Prisma__ProjectLearningClient<$Result.GetResult<Prisma.$ProjectLearningPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectLearning.
     * @param {ProjectLearningUpdateArgs} args - Arguments to update one ProjectLearning.
     * @example
     * // Update one ProjectLearning
     * const projectLearning = await prisma.projectLearning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectLearningUpdateArgs>(args: SelectSubset<T, ProjectLearningUpdateArgs<ExtArgs>>): Prisma__ProjectLearningClient<$Result.GetResult<Prisma.$ProjectLearningPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectLearnings.
     * @param {ProjectLearningDeleteManyArgs} args - Arguments to filter ProjectLearnings to delete.
     * @example
     * // Delete a few ProjectLearnings
     * const { count } = await prisma.projectLearning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectLearningDeleteManyArgs>(args?: SelectSubset<T, ProjectLearningDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectLearnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectLearningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectLearnings
     * const projectLearning = await prisma.projectLearning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectLearningUpdateManyArgs>(args: SelectSubset<T, ProjectLearningUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectLearnings and returns the data updated in the database.
     * @param {ProjectLearningUpdateManyAndReturnArgs} args - Arguments to update many ProjectLearnings.
     * @example
     * // Update many ProjectLearnings
     * const projectLearning = await prisma.projectLearning.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectLearnings and only return the `id`
     * const projectLearningWithIdOnly = await prisma.projectLearning.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectLearningUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectLearningUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectLearningPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectLearning.
     * @param {ProjectLearningUpsertArgs} args - Arguments to update or create a ProjectLearning.
     * @example
     * // Update or create a ProjectLearning
     * const projectLearning = await prisma.projectLearning.upsert({
     *   create: {
     *     // ... data to create a ProjectLearning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectLearning we want to update
     *   }
     * })
     */
    upsert<T extends ProjectLearningUpsertArgs>(args: SelectSubset<T, ProjectLearningUpsertArgs<ExtArgs>>): Prisma__ProjectLearningClient<$Result.GetResult<Prisma.$ProjectLearningPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectLearnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectLearningCountArgs} args - Arguments to filter ProjectLearnings to count.
     * @example
     * // Count the number of ProjectLearnings
     * const count = await prisma.projectLearning.count({
     *   where: {
     *     // ... the filter for the ProjectLearnings we want to count
     *   }
     * })
    **/
    count<T extends ProjectLearningCountArgs>(
      args?: Subset<T, ProjectLearningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectLearningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectLearning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectLearningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectLearningAggregateArgs>(args: Subset<T, ProjectLearningAggregateArgs>): Prisma.PrismaPromise<GetProjectLearningAggregateType<T>>

    /**
     * Group by ProjectLearning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectLearningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectLearningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectLearningGroupByArgs['orderBy'] }
        : { orderBy?: ProjectLearningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectLearningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectLearningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectLearning model
   */
  readonly fields: ProjectLearningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectLearning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectLearningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectLearning model
   */
  interface ProjectLearningFieldRefs {
    readonly id: FieldRef<"ProjectLearning", 'String'>
    readonly projectId: FieldRef<"ProjectLearning", 'String'>
    readonly learning: FieldRef<"ProjectLearning", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectLearning findUnique
   */
  export type ProjectLearningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLearning
     */
    select?: ProjectLearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLearning
     */
    omit?: ProjectLearningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLearningInclude<ExtArgs> | null
    /**
     * Filter, which ProjectLearning to fetch.
     */
    where: ProjectLearningWhereUniqueInput
  }

  /**
   * ProjectLearning findUniqueOrThrow
   */
  export type ProjectLearningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLearning
     */
    select?: ProjectLearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLearning
     */
    omit?: ProjectLearningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLearningInclude<ExtArgs> | null
    /**
     * Filter, which ProjectLearning to fetch.
     */
    where: ProjectLearningWhereUniqueInput
  }

  /**
   * ProjectLearning findFirst
   */
  export type ProjectLearningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLearning
     */
    select?: ProjectLearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLearning
     */
    omit?: ProjectLearningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLearningInclude<ExtArgs> | null
    /**
     * Filter, which ProjectLearning to fetch.
     */
    where?: ProjectLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectLearnings to fetch.
     */
    orderBy?: ProjectLearningOrderByWithRelationInput | ProjectLearningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectLearnings.
     */
    cursor?: ProjectLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectLearnings.
     */
    distinct?: ProjectLearningScalarFieldEnum | ProjectLearningScalarFieldEnum[]
  }

  /**
   * ProjectLearning findFirstOrThrow
   */
  export type ProjectLearningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLearning
     */
    select?: ProjectLearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLearning
     */
    omit?: ProjectLearningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLearningInclude<ExtArgs> | null
    /**
     * Filter, which ProjectLearning to fetch.
     */
    where?: ProjectLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectLearnings to fetch.
     */
    orderBy?: ProjectLearningOrderByWithRelationInput | ProjectLearningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectLearnings.
     */
    cursor?: ProjectLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectLearnings.
     */
    distinct?: ProjectLearningScalarFieldEnum | ProjectLearningScalarFieldEnum[]
  }

  /**
   * ProjectLearning findMany
   */
  export type ProjectLearningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLearning
     */
    select?: ProjectLearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLearning
     */
    omit?: ProjectLearningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLearningInclude<ExtArgs> | null
    /**
     * Filter, which ProjectLearnings to fetch.
     */
    where?: ProjectLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectLearnings to fetch.
     */
    orderBy?: ProjectLearningOrderByWithRelationInput | ProjectLearningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectLearnings.
     */
    cursor?: ProjectLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectLearnings.
     */
    skip?: number
    distinct?: ProjectLearningScalarFieldEnum | ProjectLearningScalarFieldEnum[]
  }

  /**
   * ProjectLearning create
   */
  export type ProjectLearningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLearning
     */
    select?: ProjectLearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLearning
     */
    omit?: ProjectLearningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLearningInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectLearning.
     */
    data: XOR<ProjectLearningCreateInput, ProjectLearningUncheckedCreateInput>
  }

  /**
   * ProjectLearning createMany
   */
  export type ProjectLearningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectLearnings.
     */
    data: ProjectLearningCreateManyInput | ProjectLearningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectLearning createManyAndReturn
   */
  export type ProjectLearningCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLearning
     */
    select?: ProjectLearningSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLearning
     */
    omit?: ProjectLearningOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectLearnings.
     */
    data: ProjectLearningCreateManyInput | ProjectLearningCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLearningIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectLearning update
   */
  export type ProjectLearningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLearning
     */
    select?: ProjectLearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLearning
     */
    omit?: ProjectLearningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLearningInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectLearning.
     */
    data: XOR<ProjectLearningUpdateInput, ProjectLearningUncheckedUpdateInput>
    /**
     * Choose, which ProjectLearning to update.
     */
    where: ProjectLearningWhereUniqueInput
  }

  /**
   * ProjectLearning updateMany
   */
  export type ProjectLearningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectLearnings.
     */
    data: XOR<ProjectLearningUpdateManyMutationInput, ProjectLearningUncheckedUpdateManyInput>
    /**
     * Filter which ProjectLearnings to update
     */
    where?: ProjectLearningWhereInput
    /**
     * Limit how many ProjectLearnings to update.
     */
    limit?: number
  }

  /**
   * ProjectLearning updateManyAndReturn
   */
  export type ProjectLearningUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLearning
     */
    select?: ProjectLearningSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLearning
     */
    omit?: ProjectLearningOmit<ExtArgs> | null
    /**
     * The data used to update ProjectLearnings.
     */
    data: XOR<ProjectLearningUpdateManyMutationInput, ProjectLearningUncheckedUpdateManyInput>
    /**
     * Filter which ProjectLearnings to update
     */
    where?: ProjectLearningWhereInput
    /**
     * Limit how many ProjectLearnings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLearningIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectLearning upsert
   */
  export type ProjectLearningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLearning
     */
    select?: ProjectLearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLearning
     */
    omit?: ProjectLearningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLearningInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectLearning to update in case it exists.
     */
    where: ProjectLearningWhereUniqueInput
    /**
     * In case the ProjectLearning found by the `where` argument doesn't exist, create a new ProjectLearning with this data.
     */
    create: XOR<ProjectLearningCreateInput, ProjectLearningUncheckedCreateInput>
    /**
     * In case the ProjectLearning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectLearningUpdateInput, ProjectLearningUncheckedUpdateInput>
  }

  /**
   * ProjectLearning delete
   */
  export type ProjectLearningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLearning
     */
    select?: ProjectLearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLearning
     */
    omit?: ProjectLearningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLearningInclude<ExtArgs> | null
    /**
     * Filter which ProjectLearning to delete.
     */
    where: ProjectLearningWhereUniqueInput
  }

  /**
   * ProjectLearning deleteMany
   */
  export type ProjectLearningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectLearnings to delete
     */
    where?: ProjectLearningWhereInput
    /**
     * Limit how many ProjectLearnings to delete.
     */
    limit?: number
  }

  /**
   * ProjectLearning without action
   */
  export type ProjectLearningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLearning
     */
    select?: ProjectLearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLearning
     */
    omit?: ProjectLearningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLearningInclude<ExtArgs> | null
  }


  /**
   * Model WorkExperience
   */

  export type AggregateWorkExperience = {
    _count: WorkExperienceCountAggregateOutputType | null
    _min: WorkExperienceMinAggregateOutputType | null
    _max: WorkExperienceMaxAggregateOutputType | null
  }

  export type WorkExperienceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    company: string | null
    position: string | null
    period: string | null
    description: string | null
    location: string | null
    type: string | null
    logo: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkExperienceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    company: string | null
    position: string | null
    period: string | null
    description: string | null
    location: string | null
    type: string | null
    logo: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkExperienceCountAggregateOutputType = {
    id: number
    userId: number
    company: number
    position: number
    period: number
    description: number
    location: number
    type: number
    logo: number
    website: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkExperienceMinAggregateInputType = {
    id?: true
    userId?: true
    company?: true
    position?: true
    period?: true
    description?: true
    location?: true
    type?: true
    logo?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkExperienceMaxAggregateInputType = {
    id?: true
    userId?: true
    company?: true
    position?: true
    period?: true
    description?: true
    location?: true
    type?: true
    logo?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkExperienceCountAggregateInputType = {
    id?: true
    userId?: true
    company?: true
    position?: true
    period?: true
    description?: true
    location?: true
    type?: true
    logo?: true
    website?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkExperienceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkExperience to aggregate.
     */
    where?: WorkExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkExperiences to fetch.
     */
    orderBy?: WorkExperienceOrderByWithRelationInput | WorkExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkExperiences
    **/
    _count?: true | WorkExperienceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkExperienceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkExperienceMaxAggregateInputType
  }

  export type GetWorkExperienceAggregateType<T extends WorkExperienceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkExperience]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkExperience[P]>
      : GetScalarType<T[P], AggregateWorkExperience[P]>
  }




  export type WorkExperienceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkExperienceWhereInput
    orderBy?: WorkExperienceOrderByWithAggregationInput | WorkExperienceOrderByWithAggregationInput[]
    by: WorkExperienceScalarFieldEnum[] | WorkExperienceScalarFieldEnum
    having?: WorkExperienceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkExperienceCountAggregateInputType | true
    _min?: WorkExperienceMinAggregateInputType
    _max?: WorkExperienceMaxAggregateInputType
  }

  export type WorkExperienceGroupByOutputType = {
    id: string
    userId: string
    company: string
    position: string
    period: string
    description: string | null
    location: string | null
    type: string | null
    logo: string | null
    website: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkExperienceCountAggregateOutputType | null
    _min: WorkExperienceMinAggregateOutputType | null
    _max: WorkExperienceMaxAggregateOutputType | null
  }

  type GetWorkExperienceGroupByPayload<T extends WorkExperienceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkExperienceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkExperienceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkExperienceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkExperienceGroupByOutputType[P]>
        }
      >
    >


  export type WorkExperienceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company?: boolean
    position?: boolean
    period?: boolean
    description?: boolean
    location?: boolean
    type?: boolean
    logo?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    responsibilities?: boolean | WorkExperience$responsibilitiesArgs<ExtArgs>
    technologies?: boolean | WorkExperience$technologiesArgs<ExtArgs>
    achievements?: boolean | WorkExperience$achievementsArgs<ExtArgs>
    _count?: boolean | WorkExperienceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workExperience"]>

  export type WorkExperienceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company?: boolean
    position?: boolean
    period?: boolean
    description?: boolean
    location?: boolean
    type?: boolean
    logo?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workExperience"]>

  export type WorkExperienceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company?: boolean
    position?: boolean
    period?: boolean
    description?: boolean
    location?: boolean
    type?: boolean
    logo?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workExperience"]>

  export type WorkExperienceSelectScalar = {
    id?: boolean
    userId?: boolean
    company?: boolean
    position?: boolean
    period?: boolean
    description?: boolean
    location?: boolean
    type?: boolean
    logo?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkExperienceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "company" | "position" | "period" | "description" | "location" | "type" | "logo" | "website" | "createdAt" | "updatedAt", ExtArgs["result"]["workExperience"]>
  export type WorkExperienceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    responsibilities?: boolean | WorkExperience$responsibilitiesArgs<ExtArgs>
    technologies?: boolean | WorkExperience$technologiesArgs<ExtArgs>
    achievements?: boolean | WorkExperience$achievementsArgs<ExtArgs>
    _count?: boolean | WorkExperienceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkExperienceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkExperienceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkExperiencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkExperience"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      responsibilities: Prisma.$WorkResponsibilityPayload<ExtArgs>[]
      technologies: Prisma.$WorkTechnologyPayload<ExtArgs>[]
      achievements: Prisma.$WorkAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      company: string
      position: string
      period: string
      description: string | null
      location: string | null
      type: string | null
      logo: string | null
      website: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workExperience"]>
    composites: {}
  }

  type WorkExperienceGetPayload<S extends boolean | null | undefined | WorkExperienceDefaultArgs> = $Result.GetResult<Prisma.$WorkExperiencePayload, S>

  type WorkExperienceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkExperienceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkExperienceCountAggregateInputType | true
    }

  export interface WorkExperienceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkExperience'], meta: { name: 'WorkExperience' } }
    /**
     * Find zero or one WorkExperience that matches the filter.
     * @param {WorkExperienceFindUniqueArgs} args - Arguments to find a WorkExperience
     * @example
     * // Get one WorkExperience
     * const workExperience = await prisma.workExperience.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkExperienceFindUniqueArgs>(args: SelectSubset<T, WorkExperienceFindUniqueArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkExperience that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkExperienceFindUniqueOrThrowArgs} args - Arguments to find a WorkExperience
     * @example
     * // Get one WorkExperience
     * const workExperience = await prisma.workExperience.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkExperienceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkExperienceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkExperience that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkExperienceFindFirstArgs} args - Arguments to find a WorkExperience
     * @example
     * // Get one WorkExperience
     * const workExperience = await prisma.workExperience.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkExperienceFindFirstArgs>(args?: SelectSubset<T, WorkExperienceFindFirstArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkExperience that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkExperienceFindFirstOrThrowArgs} args - Arguments to find a WorkExperience
     * @example
     * // Get one WorkExperience
     * const workExperience = await prisma.workExperience.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkExperienceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkExperienceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkExperiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkExperienceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkExperiences
     * const workExperiences = await prisma.workExperience.findMany()
     * 
     * // Get first 10 WorkExperiences
     * const workExperiences = await prisma.workExperience.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workExperienceWithIdOnly = await prisma.workExperience.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkExperienceFindManyArgs>(args?: SelectSubset<T, WorkExperienceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkExperience.
     * @param {WorkExperienceCreateArgs} args - Arguments to create a WorkExperience.
     * @example
     * // Create one WorkExperience
     * const WorkExperience = await prisma.workExperience.create({
     *   data: {
     *     // ... data to create a WorkExperience
     *   }
     * })
     * 
     */
    create<T extends WorkExperienceCreateArgs>(args: SelectSubset<T, WorkExperienceCreateArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkExperiences.
     * @param {WorkExperienceCreateManyArgs} args - Arguments to create many WorkExperiences.
     * @example
     * // Create many WorkExperiences
     * const workExperience = await prisma.workExperience.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkExperienceCreateManyArgs>(args?: SelectSubset<T, WorkExperienceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkExperiences and returns the data saved in the database.
     * @param {WorkExperienceCreateManyAndReturnArgs} args - Arguments to create many WorkExperiences.
     * @example
     * // Create many WorkExperiences
     * const workExperience = await prisma.workExperience.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkExperiences and only return the `id`
     * const workExperienceWithIdOnly = await prisma.workExperience.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkExperienceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkExperienceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkExperience.
     * @param {WorkExperienceDeleteArgs} args - Arguments to delete one WorkExperience.
     * @example
     * // Delete one WorkExperience
     * const WorkExperience = await prisma.workExperience.delete({
     *   where: {
     *     // ... filter to delete one WorkExperience
     *   }
     * })
     * 
     */
    delete<T extends WorkExperienceDeleteArgs>(args: SelectSubset<T, WorkExperienceDeleteArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkExperience.
     * @param {WorkExperienceUpdateArgs} args - Arguments to update one WorkExperience.
     * @example
     * // Update one WorkExperience
     * const workExperience = await prisma.workExperience.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkExperienceUpdateArgs>(args: SelectSubset<T, WorkExperienceUpdateArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkExperiences.
     * @param {WorkExperienceDeleteManyArgs} args - Arguments to filter WorkExperiences to delete.
     * @example
     * // Delete a few WorkExperiences
     * const { count } = await prisma.workExperience.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkExperienceDeleteManyArgs>(args?: SelectSubset<T, WorkExperienceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkExperienceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkExperiences
     * const workExperience = await prisma.workExperience.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkExperienceUpdateManyArgs>(args: SelectSubset<T, WorkExperienceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkExperiences and returns the data updated in the database.
     * @param {WorkExperienceUpdateManyAndReturnArgs} args - Arguments to update many WorkExperiences.
     * @example
     * // Update many WorkExperiences
     * const workExperience = await prisma.workExperience.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkExperiences and only return the `id`
     * const workExperienceWithIdOnly = await prisma.workExperience.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkExperienceUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkExperienceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkExperience.
     * @param {WorkExperienceUpsertArgs} args - Arguments to update or create a WorkExperience.
     * @example
     * // Update or create a WorkExperience
     * const workExperience = await prisma.workExperience.upsert({
     *   create: {
     *     // ... data to create a WorkExperience
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkExperience we want to update
     *   }
     * })
     */
    upsert<T extends WorkExperienceUpsertArgs>(args: SelectSubset<T, WorkExperienceUpsertArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkExperienceCountArgs} args - Arguments to filter WorkExperiences to count.
     * @example
     * // Count the number of WorkExperiences
     * const count = await prisma.workExperience.count({
     *   where: {
     *     // ... the filter for the WorkExperiences we want to count
     *   }
     * })
    **/
    count<T extends WorkExperienceCountArgs>(
      args?: Subset<T, WorkExperienceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkExperienceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkExperienceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkExperienceAggregateArgs>(args: Subset<T, WorkExperienceAggregateArgs>): Prisma.PrismaPromise<GetWorkExperienceAggregateType<T>>

    /**
     * Group by WorkExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkExperienceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkExperienceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkExperienceGroupByArgs['orderBy'] }
        : { orderBy?: WorkExperienceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkExperienceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkExperienceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkExperience model
   */
  readonly fields: WorkExperienceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkExperience.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkExperienceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    responsibilities<T extends WorkExperience$responsibilitiesArgs<ExtArgs> = {}>(args?: Subset<T, WorkExperience$responsibilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkResponsibilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    technologies<T extends WorkExperience$technologiesArgs<ExtArgs> = {}>(args?: Subset<T, WorkExperience$technologiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkTechnologyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievements<T extends WorkExperience$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, WorkExperience$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkExperience model
   */
  interface WorkExperienceFieldRefs {
    readonly id: FieldRef<"WorkExperience", 'String'>
    readonly userId: FieldRef<"WorkExperience", 'String'>
    readonly company: FieldRef<"WorkExperience", 'String'>
    readonly position: FieldRef<"WorkExperience", 'String'>
    readonly period: FieldRef<"WorkExperience", 'String'>
    readonly description: FieldRef<"WorkExperience", 'String'>
    readonly location: FieldRef<"WorkExperience", 'String'>
    readonly type: FieldRef<"WorkExperience", 'String'>
    readonly logo: FieldRef<"WorkExperience", 'String'>
    readonly website: FieldRef<"WorkExperience", 'String'>
    readonly createdAt: FieldRef<"WorkExperience", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkExperience", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkExperience findUnique
   */
  export type WorkExperienceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * Filter, which WorkExperience to fetch.
     */
    where: WorkExperienceWhereUniqueInput
  }

  /**
   * WorkExperience findUniqueOrThrow
   */
  export type WorkExperienceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * Filter, which WorkExperience to fetch.
     */
    where: WorkExperienceWhereUniqueInput
  }

  /**
   * WorkExperience findFirst
   */
  export type WorkExperienceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * Filter, which WorkExperience to fetch.
     */
    where?: WorkExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkExperiences to fetch.
     */
    orderBy?: WorkExperienceOrderByWithRelationInput | WorkExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkExperiences.
     */
    cursor?: WorkExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkExperiences.
     */
    distinct?: WorkExperienceScalarFieldEnum | WorkExperienceScalarFieldEnum[]
  }

  /**
   * WorkExperience findFirstOrThrow
   */
  export type WorkExperienceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * Filter, which WorkExperience to fetch.
     */
    where?: WorkExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkExperiences to fetch.
     */
    orderBy?: WorkExperienceOrderByWithRelationInput | WorkExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkExperiences.
     */
    cursor?: WorkExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkExperiences.
     */
    distinct?: WorkExperienceScalarFieldEnum | WorkExperienceScalarFieldEnum[]
  }

  /**
   * WorkExperience findMany
   */
  export type WorkExperienceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * Filter, which WorkExperiences to fetch.
     */
    where?: WorkExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkExperiences to fetch.
     */
    orderBy?: WorkExperienceOrderByWithRelationInput | WorkExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkExperiences.
     */
    cursor?: WorkExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkExperiences.
     */
    skip?: number
    distinct?: WorkExperienceScalarFieldEnum | WorkExperienceScalarFieldEnum[]
  }

  /**
   * WorkExperience create
   */
  export type WorkExperienceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkExperience.
     */
    data: XOR<WorkExperienceCreateInput, WorkExperienceUncheckedCreateInput>
  }

  /**
   * WorkExperience createMany
   */
  export type WorkExperienceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkExperiences.
     */
    data: WorkExperienceCreateManyInput | WorkExperienceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkExperience createManyAndReturn
   */
  export type WorkExperienceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * The data used to create many WorkExperiences.
     */
    data: WorkExperienceCreateManyInput | WorkExperienceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkExperience update
   */
  export type WorkExperienceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkExperience.
     */
    data: XOR<WorkExperienceUpdateInput, WorkExperienceUncheckedUpdateInput>
    /**
     * Choose, which WorkExperience to update.
     */
    where: WorkExperienceWhereUniqueInput
  }

  /**
   * WorkExperience updateMany
   */
  export type WorkExperienceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkExperiences.
     */
    data: XOR<WorkExperienceUpdateManyMutationInput, WorkExperienceUncheckedUpdateManyInput>
    /**
     * Filter which WorkExperiences to update
     */
    where?: WorkExperienceWhereInput
    /**
     * Limit how many WorkExperiences to update.
     */
    limit?: number
  }

  /**
   * WorkExperience updateManyAndReturn
   */
  export type WorkExperienceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * The data used to update WorkExperiences.
     */
    data: XOR<WorkExperienceUpdateManyMutationInput, WorkExperienceUncheckedUpdateManyInput>
    /**
     * Filter which WorkExperiences to update
     */
    where?: WorkExperienceWhereInput
    /**
     * Limit how many WorkExperiences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkExperience upsert
   */
  export type WorkExperienceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkExperience to update in case it exists.
     */
    where: WorkExperienceWhereUniqueInput
    /**
     * In case the WorkExperience found by the `where` argument doesn't exist, create a new WorkExperience with this data.
     */
    create: XOR<WorkExperienceCreateInput, WorkExperienceUncheckedCreateInput>
    /**
     * In case the WorkExperience was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkExperienceUpdateInput, WorkExperienceUncheckedUpdateInput>
  }

  /**
   * WorkExperience delete
   */
  export type WorkExperienceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
    /**
     * Filter which WorkExperience to delete.
     */
    where: WorkExperienceWhereUniqueInput
  }

  /**
   * WorkExperience deleteMany
   */
  export type WorkExperienceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkExperiences to delete
     */
    where?: WorkExperienceWhereInput
    /**
     * Limit how many WorkExperiences to delete.
     */
    limit?: number
  }

  /**
   * WorkExperience.responsibilities
   */
  export type WorkExperience$responsibilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkResponsibility
     */
    select?: WorkResponsibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkResponsibility
     */
    omit?: WorkResponsibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkResponsibilityInclude<ExtArgs> | null
    where?: WorkResponsibilityWhereInput
    orderBy?: WorkResponsibilityOrderByWithRelationInput | WorkResponsibilityOrderByWithRelationInput[]
    cursor?: WorkResponsibilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkResponsibilityScalarFieldEnum | WorkResponsibilityScalarFieldEnum[]
  }

  /**
   * WorkExperience.technologies
   */
  export type WorkExperience$technologiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTechnology
     */
    select?: WorkTechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTechnology
     */
    omit?: WorkTechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTechnologyInclude<ExtArgs> | null
    where?: WorkTechnologyWhereInput
    orderBy?: WorkTechnologyOrderByWithRelationInput | WorkTechnologyOrderByWithRelationInput[]
    cursor?: WorkTechnologyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkTechnologyScalarFieldEnum | WorkTechnologyScalarFieldEnum[]
  }

  /**
   * WorkExperience.achievements
   */
  export type WorkExperience$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkAchievement
     */
    select?: WorkAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkAchievement
     */
    omit?: WorkAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkAchievementInclude<ExtArgs> | null
    where?: WorkAchievementWhereInput
    orderBy?: WorkAchievementOrderByWithRelationInput | WorkAchievementOrderByWithRelationInput[]
    cursor?: WorkAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkAchievementScalarFieldEnum | WorkAchievementScalarFieldEnum[]
  }

  /**
   * WorkExperience without action
   */
  export type WorkExperienceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkExperience
     */
    select?: WorkExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkExperience
     */
    omit?: WorkExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkExperienceInclude<ExtArgs> | null
  }


  /**
   * Model WorkResponsibility
   */

  export type AggregateWorkResponsibility = {
    _count: WorkResponsibilityCountAggregateOutputType | null
    _min: WorkResponsibilityMinAggregateOutputType | null
    _max: WorkResponsibilityMaxAggregateOutputType | null
  }

  export type WorkResponsibilityMinAggregateOutputType = {
    id: string | null
    experienceId: string | null
    responsibility: string | null
  }

  export type WorkResponsibilityMaxAggregateOutputType = {
    id: string | null
    experienceId: string | null
    responsibility: string | null
  }

  export type WorkResponsibilityCountAggregateOutputType = {
    id: number
    experienceId: number
    responsibility: number
    _all: number
  }


  export type WorkResponsibilityMinAggregateInputType = {
    id?: true
    experienceId?: true
    responsibility?: true
  }

  export type WorkResponsibilityMaxAggregateInputType = {
    id?: true
    experienceId?: true
    responsibility?: true
  }

  export type WorkResponsibilityCountAggregateInputType = {
    id?: true
    experienceId?: true
    responsibility?: true
    _all?: true
  }

  export type WorkResponsibilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkResponsibility to aggregate.
     */
    where?: WorkResponsibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkResponsibilities to fetch.
     */
    orderBy?: WorkResponsibilityOrderByWithRelationInput | WorkResponsibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkResponsibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkResponsibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkResponsibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkResponsibilities
    **/
    _count?: true | WorkResponsibilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkResponsibilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkResponsibilityMaxAggregateInputType
  }

  export type GetWorkResponsibilityAggregateType<T extends WorkResponsibilityAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkResponsibility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkResponsibility[P]>
      : GetScalarType<T[P], AggregateWorkResponsibility[P]>
  }




  export type WorkResponsibilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkResponsibilityWhereInput
    orderBy?: WorkResponsibilityOrderByWithAggregationInput | WorkResponsibilityOrderByWithAggregationInput[]
    by: WorkResponsibilityScalarFieldEnum[] | WorkResponsibilityScalarFieldEnum
    having?: WorkResponsibilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkResponsibilityCountAggregateInputType | true
    _min?: WorkResponsibilityMinAggregateInputType
    _max?: WorkResponsibilityMaxAggregateInputType
  }

  export type WorkResponsibilityGroupByOutputType = {
    id: string
    experienceId: string
    responsibility: string
    _count: WorkResponsibilityCountAggregateOutputType | null
    _min: WorkResponsibilityMinAggregateOutputType | null
    _max: WorkResponsibilityMaxAggregateOutputType | null
  }

  type GetWorkResponsibilityGroupByPayload<T extends WorkResponsibilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkResponsibilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkResponsibilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkResponsibilityGroupByOutputType[P]>
            : GetScalarType<T[P], WorkResponsibilityGroupByOutputType[P]>
        }
      >
    >


  export type WorkResponsibilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experienceId?: boolean
    responsibility?: boolean
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workResponsibility"]>

  export type WorkResponsibilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experienceId?: boolean
    responsibility?: boolean
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workResponsibility"]>

  export type WorkResponsibilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experienceId?: boolean
    responsibility?: boolean
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workResponsibility"]>

  export type WorkResponsibilitySelectScalar = {
    id?: boolean
    experienceId?: boolean
    responsibility?: boolean
  }

  export type WorkResponsibilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "experienceId" | "responsibility", ExtArgs["result"]["workResponsibility"]>
  export type WorkResponsibilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }
  export type WorkResponsibilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }
  export type WorkResponsibilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }

  export type $WorkResponsibilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkResponsibility"
    objects: {
      workExperience: Prisma.$WorkExperiencePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      experienceId: string
      responsibility: string
    }, ExtArgs["result"]["workResponsibility"]>
    composites: {}
  }

  type WorkResponsibilityGetPayload<S extends boolean | null | undefined | WorkResponsibilityDefaultArgs> = $Result.GetResult<Prisma.$WorkResponsibilityPayload, S>

  type WorkResponsibilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkResponsibilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkResponsibilityCountAggregateInputType | true
    }

  export interface WorkResponsibilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkResponsibility'], meta: { name: 'WorkResponsibility' } }
    /**
     * Find zero or one WorkResponsibility that matches the filter.
     * @param {WorkResponsibilityFindUniqueArgs} args - Arguments to find a WorkResponsibility
     * @example
     * // Get one WorkResponsibility
     * const workResponsibility = await prisma.workResponsibility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkResponsibilityFindUniqueArgs>(args: SelectSubset<T, WorkResponsibilityFindUniqueArgs<ExtArgs>>): Prisma__WorkResponsibilityClient<$Result.GetResult<Prisma.$WorkResponsibilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkResponsibility that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkResponsibilityFindUniqueOrThrowArgs} args - Arguments to find a WorkResponsibility
     * @example
     * // Get one WorkResponsibility
     * const workResponsibility = await prisma.workResponsibility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkResponsibilityFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkResponsibilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkResponsibilityClient<$Result.GetResult<Prisma.$WorkResponsibilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkResponsibility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkResponsibilityFindFirstArgs} args - Arguments to find a WorkResponsibility
     * @example
     * // Get one WorkResponsibility
     * const workResponsibility = await prisma.workResponsibility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkResponsibilityFindFirstArgs>(args?: SelectSubset<T, WorkResponsibilityFindFirstArgs<ExtArgs>>): Prisma__WorkResponsibilityClient<$Result.GetResult<Prisma.$WorkResponsibilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkResponsibility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkResponsibilityFindFirstOrThrowArgs} args - Arguments to find a WorkResponsibility
     * @example
     * // Get one WorkResponsibility
     * const workResponsibility = await prisma.workResponsibility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkResponsibilityFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkResponsibilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkResponsibilityClient<$Result.GetResult<Prisma.$WorkResponsibilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkResponsibilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkResponsibilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkResponsibilities
     * const workResponsibilities = await prisma.workResponsibility.findMany()
     * 
     * // Get first 10 WorkResponsibilities
     * const workResponsibilities = await prisma.workResponsibility.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workResponsibilityWithIdOnly = await prisma.workResponsibility.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkResponsibilityFindManyArgs>(args?: SelectSubset<T, WorkResponsibilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkResponsibilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkResponsibility.
     * @param {WorkResponsibilityCreateArgs} args - Arguments to create a WorkResponsibility.
     * @example
     * // Create one WorkResponsibility
     * const WorkResponsibility = await prisma.workResponsibility.create({
     *   data: {
     *     // ... data to create a WorkResponsibility
     *   }
     * })
     * 
     */
    create<T extends WorkResponsibilityCreateArgs>(args: SelectSubset<T, WorkResponsibilityCreateArgs<ExtArgs>>): Prisma__WorkResponsibilityClient<$Result.GetResult<Prisma.$WorkResponsibilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkResponsibilities.
     * @param {WorkResponsibilityCreateManyArgs} args - Arguments to create many WorkResponsibilities.
     * @example
     * // Create many WorkResponsibilities
     * const workResponsibility = await prisma.workResponsibility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkResponsibilityCreateManyArgs>(args?: SelectSubset<T, WorkResponsibilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkResponsibilities and returns the data saved in the database.
     * @param {WorkResponsibilityCreateManyAndReturnArgs} args - Arguments to create many WorkResponsibilities.
     * @example
     * // Create many WorkResponsibilities
     * const workResponsibility = await prisma.workResponsibility.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkResponsibilities and only return the `id`
     * const workResponsibilityWithIdOnly = await prisma.workResponsibility.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkResponsibilityCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkResponsibilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkResponsibilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkResponsibility.
     * @param {WorkResponsibilityDeleteArgs} args - Arguments to delete one WorkResponsibility.
     * @example
     * // Delete one WorkResponsibility
     * const WorkResponsibility = await prisma.workResponsibility.delete({
     *   where: {
     *     // ... filter to delete one WorkResponsibility
     *   }
     * })
     * 
     */
    delete<T extends WorkResponsibilityDeleteArgs>(args: SelectSubset<T, WorkResponsibilityDeleteArgs<ExtArgs>>): Prisma__WorkResponsibilityClient<$Result.GetResult<Prisma.$WorkResponsibilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkResponsibility.
     * @param {WorkResponsibilityUpdateArgs} args - Arguments to update one WorkResponsibility.
     * @example
     * // Update one WorkResponsibility
     * const workResponsibility = await prisma.workResponsibility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkResponsibilityUpdateArgs>(args: SelectSubset<T, WorkResponsibilityUpdateArgs<ExtArgs>>): Prisma__WorkResponsibilityClient<$Result.GetResult<Prisma.$WorkResponsibilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkResponsibilities.
     * @param {WorkResponsibilityDeleteManyArgs} args - Arguments to filter WorkResponsibilities to delete.
     * @example
     * // Delete a few WorkResponsibilities
     * const { count } = await prisma.workResponsibility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkResponsibilityDeleteManyArgs>(args?: SelectSubset<T, WorkResponsibilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkResponsibilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkResponsibilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkResponsibilities
     * const workResponsibility = await prisma.workResponsibility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkResponsibilityUpdateManyArgs>(args: SelectSubset<T, WorkResponsibilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkResponsibilities and returns the data updated in the database.
     * @param {WorkResponsibilityUpdateManyAndReturnArgs} args - Arguments to update many WorkResponsibilities.
     * @example
     * // Update many WorkResponsibilities
     * const workResponsibility = await prisma.workResponsibility.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkResponsibilities and only return the `id`
     * const workResponsibilityWithIdOnly = await prisma.workResponsibility.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkResponsibilityUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkResponsibilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkResponsibilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkResponsibility.
     * @param {WorkResponsibilityUpsertArgs} args - Arguments to update or create a WorkResponsibility.
     * @example
     * // Update or create a WorkResponsibility
     * const workResponsibility = await prisma.workResponsibility.upsert({
     *   create: {
     *     // ... data to create a WorkResponsibility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkResponsibility we want to update
     *   }
     * })
     */
    upsert<T extends WorkResponsibilityUpsertArgs>(args: SelectSubset<T, WorkResponsibilityUpsertArgs<ExtArgs>>): Prisma__WorkResponsibilityClient<$Result.GetResult<Prisma.$WorkResponsibilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkResponsibilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkResponsibilityCountArgs} args - Arguments to filter WorkResponsibilities to count.
     * @example
     * // Count the number of WorkResponsibilities
     * const count = await prisma.workResponsibility.count({
     *   where: {
     *     // ... the filter for the WorkResponsibilities we want to count
     *   }
     * })
    **/
    count<T extends WorkResponsibilityCountArgs>(
      args?: Subset<T, WorkResponsibilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkResponsibilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkResponsibility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkResponsibilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkResponsibilityAggregateArgs>(args: Subset<T, WorkResponsibilityAggregateArgs>): Prisma.PrismaPromise<GetWorkResponsibilityAggregateType<T>>

    /**
     * Group by WorkResponsibility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkResponsibilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkResponsibilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkResponsibilityGroupByArgs['orderBy'] }
        : { orderBy?: WorkResponsibilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkResponsibilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkResponsibilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkResponsibility model
   */
  readonly fields: WorkResponsibilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkResponsibility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkResponsibilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workExperience<T extends WorkExperienceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkExperienceDefaultArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkResponsibility model
   */
  interface WorkResponsibilityFieldRefs {
    readonly id: FieldRef<"WorkResponsibility", 'String'>
    readonly experienceId: FieldRef<"WorkResponsibility", 'String'>
    readonly responsibility: FieldRef<"WorkResponsibility", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkResponsibility findUnique
   */
  export type WorkResponsibilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkResponsibility
     */
    select?: WorkResponsibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkResponsibility
     */
    omit?: WorkResponsibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkResponsibilityInclude<ExtArgs> | null
    /**
     * Filter, which WorkResponsibility to fetch.
     */
    where: WorkResponsibilityWhereUniqueInput
  }

  /**
   * WorkResponsibility findUniqueOrThrow
   */
  export type WorkResponsibilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkResponsibility
     */
    select?: WorkResponsibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkResponsibility
     */
    omit?: WorkResponsibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkResponsibilityInclude<ExtArgs> | null
    /**
     * Filter, which WorkResponsibility to fetch.
     */
    where: WorkResponsibilityWhereUniqueInput
  }

  /**
   * WorkResponsibility findFirst
   */
  export type WorkResponsibilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkResponsibility
     */
    select?: WorkResponsibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkResponsibility
     */
    omit?: WorkResponsibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkResponsibilityInclude<ExtArgs> | null
    /**
     * Filter, which WorkResponsibility to fetch.
     */
    where?: WorkResponsibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkResponsibilities to fetch.
     */
    orderBy?: WorkResponsibilityOrderByWithRelationInput | WorkResponsibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkResponsibilities.
     */
    cursor?: WorkResponsibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkResponsibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkResponsibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkResponsibilities.
     */
    distinct?: WorkResponsibilityScalarFieldEnum | WorkResponsibilityScalarFieldEnum[]
  }

  /**
   * WorkResponsibility findFirstOrThrow
   */
  export type WorkResponsibilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkResponsibility
     */
    select?: WorkResponsibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkResponsibility
     */
    omit?: WorkResponsibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkResponsibilityInclude<ExtArgs> | null
    /**
     * Filter, which WorkResponsibility to fetch.
     */
    where?: WorkResponsibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkResponsibilities to fetch.
     */
    orderBy?: WorkResponsibilityOrderByWithRelationInput | WorkResponsibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkResponsibilities.
     */
    cursor?: WorkResponsibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkResponsibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkResponsibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkResponsibilities.
     */
    distinct?: WorkResponsibilityScalarFieldEnum | WorkResponsibilityScalarFieldEnum[]
  }

  /**
   * WorkResponsibility findMany
   */
  export type WorkResponsibilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkResponsibility
     */
    select?: WorkResponsibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkResponsibility
     */
    omit?: WorkResponsibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkResponsibilityInclude<ExtArgs> | null
    /**
     * Filter, which WorkResponsibilities to fetch.
     */
    where?: WorkResponsibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkResponsibilities to fetch.
     */
    orderBy?: WorkResponsibilityOrderByWithRelationInput | WorkResponsibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkResponsibilities.
     */
    cursor?: WorkResponsibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkResponsibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkResponsibilities.
     */
    skip?: number
    distinct?: WorkResponsibilityScalarFieldEnum | WorkResponsibilityScalarFieldEnum[]
  }

  /**
   * WorkResponsibility create
   */
  export type WorkResponsibilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkResponsibility
     */
    select?: WorkResponsibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkResponsibility
     */
    omit?: WorkResponsibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkResponsibilityInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkResponsibility.
     */
    data: XOR<WorkResponsibilityCreateInput, WorkResponsibilityUncheckedCreateInput>
  }

  /**
   * WorkResponsibility createMany
   */
  export type WorkResponsibilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkResponsibilities.
     */
    data: WorkResponsibilityCreateManyInput | WorkResponsibilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkResponsibility createManyAndReturn
   */
  export type WorkResponsibilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkResponsibility
     */
    select?: WorkResponsibilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkResponsibility
     */
    omit?: WorkResponsibilityOmit<ExtArgs> | null
    /**
     * The data used to create many WorkResponsibilities.
     */
    data: WorkResponsibilityCreateManyInput | WorkResponsibilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkResponsibilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkResponsibility update
   */
  export type WorkResponsibilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkResponsibility
     */
    select?: WorkResponsibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkResponsibility
     */
    omit?: WorkResponsibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkResponsibilityInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkResponsibility.
     */
    data: XOR<WorkResponsibilityUpdateInput, WorkResponsibilityUncheckedUpdateInput>
    /**
     * Choose, which WorkResponsibility to update.
     */
    where: WorkResponsibilityWhereUniqueInput
  }

  /**
   * WorkResponsibility updateMany
   */
  export type WorkResponsibilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkResponsibilities.
     */
    data: XOR<WorkResponsibilityUpdateManyMutationInput, WorkResponsibilityUncheckedUpdateManyInput>
    /**
     * Filter which WorkResponsibilities to update
     */
    where?: WorkResponsibilityWhereInput
    /**
     * Limit how many WorkResponsibilities to update.
     */
    limit?: number
  }

  /**
   * WorkResponsibility updateManyAndReturn
   */
  export type WorkResponsibilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkResponsibility
     */
    select?: WorkResponsibilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkResponsibility
     */
    omit?: WorkResponsibilityOmit<ExtArgs> | null
    /**
     * The data used to update WorkResponsibilities.
     */
    data: XOR<WorkResponsibilityUpdateManyMutationInput, WorkResponsibilityUncheckedUpdateManyInput>
    /**
     * Filter which WorkResponsibilities to update
     */
    where?: WorkResponsibilityWhereInput
    /**
     * Limit how many WorkResponsibilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkResponsibilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkResponsibility upsert
   */
  export type WorkResponsibilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkResponsibility
     */
    select?: WorkResponsibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkResponsibility
     */
    omit?: WorkResponsibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkResponsibilityInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkResponsibility to update in case it exists.
     */
    where: WorkResponsibilityWhereUniqueInput
    /**
     * In case the WorkResponsibility found by the `where` argument doesn't exist, create a new WorkResponsibility with this data.
     */
    create: XOR<WorkResponsibilityCreateInput, WorkResponsibilityUncheckedCreateInput>
    /**
     * In case the WorkResponsibility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkResponsibilityUpdateInput, WorkResponsibilityUncheckedUpdateInput>
  }

  /**
   * WorkResponsibility delete
   */
  export type WorkResponsibilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkResponsibility
     */
    select?: WorkResponsibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkResponsibility
     */
    omit?: WorkResponsibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkResponsibilityInclude<ExtArgs> | null
    /**
     * Filter which WorkResponsibility to delete.
     */
    where: WorkResponsibilityWhereUniqueInput
  }

  /**
   * WorkResponsibility deleteMany
   */
  export type WorkResponsibilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkResponsibilities to delete
     */
    where?: WorkResponsibilityWhereInput
    /**
     * Limit how many WorkResponsibilities to delete.
     */
    limit?: number
  }

  /**
   * WorkResponsibility without action
   */
  export type WorkResponsibilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkResponsibility
     */
    select?: WorkResponsibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkResponsibility
     */
    omit?: WorkResponsibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkResponsibilityInclude<ExtArgs> | null
  }


  /**
   * Model WorkTechnology
   */

  export type AggregateWorkTechnology = {
    _count: WorkTechnologyCountAggregateOutputType | null
    _min: WorkTechnologyMinAggregateOutputType | null
    _max: WorkTechnologyMaxAggregateOutputType | null
  }

  export type WorkTechnologyMinAggregateOutputType = {
    id: string | null
    experienceId: string | null
    technology: string | null
  }

  export type WorkTechnologyMaxAggregateOutputType = {
    id: string | null
    experienceId: string | null
    technology: string | null
  }

  export type WorkTechnologyCountAggregateOutputType = {
    id: number
    experienceId: number
    technology: number
    _all: number
  }


  export type WorkTechnologyMinAggregateInputType = {
    id?: true
    experienceId?: true
    technology?: true
  }

  export type WorkTechnologyMaxAggregateInputType = {
    id?: true
    experienceId?: true
    technology?: true
  }

  export type WorkTechnologyCountAggregateInputType = {
    id?: true
    experienceId?: true
    technology?: true
    _all?: true
  }

  export type WorkTechnologyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkTechnology to aggregate.
     */
    where?: WorkTechnologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkTechnologies to fetch.
     */
    orderBy?: WorkTechnologyOrderByWithRelationInput | WorkTechnologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkTechnologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkTechnologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkTechnologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkTechnologies
    **/
    _count?: true | WorkTechnologyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkTechnologyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkTechnologyMaxAggregateInputType
  }

  export type GetWorkTechnologyAggregateType<T extends WorkTechnologyAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkTechnology]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkTechnology[P]>
      : GetScalarType<T[P], AggregateWorkTechnology[P]>
  }




  export type WorkTechnologyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkTechnologyWhereInput
    orderBy?: WorkTechnologyOrderByWithAggregationInput | WorkTechnologyOrderByWithAggregationInput[]
    by: WorkTechnologyScalarFieldEnum[] | WorkTechnologyScalarFieldEnum
    having?: WorkTechnologyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkTechnologyCountAggregateInputType | true
    _min?: WorkTechnologyMinAggregateInputType
    _max?: WorkTechnologyMaxAggregateInputType
  }

  export type WorkTechnologyGroupByOutputType = {
    id: string
    experienceId: string
    technology: string
    _count: WorkTechnologyCountAggregateOutputType | null
    _min: WorkTechnologyMinAggregateOutputType | null
    _max: WorkTechnologyMaxAggregateOutputType | null
  }

  type GetWorkTechnologyGroupByPayload<T extends WorkTechnologyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkTechnologyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkTechnologyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkTechnologyGroupByOutputType[P]>
            : GetScalarType<T[P], WorkTechnologyGroupByOutputType[P]>
        }
      >
    >


  export type WorkTechnologySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experienceId?: boolean
    technology?: boolean
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workTechnology"]>

  export type WorkTechnologySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experienceId?: boolean
    technology?: boolean
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workTechnology"]>

  export type WorkTechnologySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experienceId?: boolean
    technology?: boolean
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workTechnology"]>

  export type WorkTechnologySelectScalar = {
    id?: boolean
    experienceId?: boolean
    technology?: boolean
  }

  export type WorkTechnologyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "experienceId" | "technology", ExtArgs["result"]["workTechnology"]>
  export type WorkTechnologyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }
  export type WorkTechnologyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }
  export type WorkTechnologyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }

  export type $WorkTechnologyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkTechnology"
    objects: {
      workExperience: Prisma.$WorkExperiencePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      experienceId: string
      technology: string
    }, ExtArgs["result"]["workTechnology"]>
    composites: {}
  }

  type WorkTechnologyGetPayload<S extends boolean | null | undefined | WorkTechnologyDefaultArgs> = $Result.GetResult<Prisma.$WorkTechnologyPayload, S>

  type WorkTechnologyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkTechnologyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkTechnologyCountAggregateInputType | true
    }

  export interface WorkTechnologyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkTechnology'], meta: { name: 'WorkTechnology' } }
    /**
     * Find zero or one WorkTechnology that matches the filter.
     * @param {WorkTechnologyFindUniqueArgs} args - Arguments to find a WorkTechnology
     * @example
     * // Get one WorkTechnology
     * const workTechnology = await prisma.workTechnology.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkTechnologyFindUniqueArgs>(args: SelectSubset<T, WorkTechnologyFindUniqueArgs<ExtArgs>>): Prisma__WorkTechnologyClient<$Result.GetResult<Prisma.$WorkTechnologyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkTechnology that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkTechnologyFindUniqueOrThrowArgs} args - Arguments to find a WorkTechnology
     * @example
     * // Get one WorkTechnology
     * const workTechnology = await prisma.workTechnology.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkTechnologyFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkTechnologyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkTechnologyClient<$Result.GetResult<Prisma.$WorkTechnologyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkTechnology that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTechnologyFindFirstArgs} args - Arguments to find a WorkTechnology
     * @example
     * // Get one WorkTechnology
     * const workTechnology = await prisma.workTechnology.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkTechnologyFindFirstArgs>(args?: SelectSubset<T, WorkTechnologyFindFirstArgs<ExtArgs>>): Prisma__WorkTechnologyClient<$Result.GetResult<Prisma.$WorkTechnologyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkTechnology that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTechnologyFindFirstOrThrowArgs} args - Arguments to find a WorkTechnology
     * @example
     * // Get one WorkTechnology
     * const workTechnology = await prisma.workTechnology.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkTechnologyFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkTechnologyFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkTechnologyClient<$Result.GetResult<Prisma.$WorkTechnologyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkTechnologies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTechnologyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkTechnologies
     * const workTechnologies = await prisma.workTechnology.findMany()
     * 
     * // Get first 10 WorkTechnologies
     * const workTechnologies = await prisma.workTechnology.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workTechnologyWithIdOnly = await prisma.workTechnology.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkTechnologyFindManyArgs>(args?: SelectSubset<T, WorkTechnologyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkTechnologyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkTechnology.
     * @param {WorkTechnologyCreateArgs} args - Arguments to create a WorkTechnology.
     * @example
     * // Create one WorkTechnology
     * const WorkTechnology = await prisma.workTechnology.create({
     *   data: {
     *     // ... data to create a WorkTechnology
     *   }
     * })
     * 
     */
    create<T extends WorkTechnologyCreateArgs>(args: SelectSubset<T, WorkTechnologyCreateArgs<ExtArgs>>): Prisma__WorkTechnologyClient<$Result.GetResult<Prisma.$WorkTechnologyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkTechnologies.
     * @param {WorkTechnologyCreateManyArgs} args - Arguments to create many WorkTechnologies.
     * @example
     * // Create many WorkTechnologies
     * const workTechnology = await prisma.workTechnology.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkTechnologyCreateManyArgs>(args?: SelectSubset<T, WorkTechnologyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkTechnologies and returns the data saved in the database.
     * @param {WorkTechnologyCreateManyAndReturnArgs} args - Arguments to create many WorkTechnologies.
     * @example
     * // Create many WorkTechnologies
     * const workTechnology = await prisma.workTechnology.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkTechnologies and only return the `id`
     * const workTechnologyWithIdOnly = await prisma.workTechnology.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkTechnologyCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkTechnologyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkTechnologyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkTechnology.
     * @param {WorkTechnologyDeleteArgs} args - Arguments to delete one WorkTechnology.
     * @example
     * // Delete one WorkTechnology
     * const WorkTechnology = await prisma.workTechnology.delete({
     *   where: {
     *     // ... filter to delete one WorkTechnology
     *   }
     * })
     * 
     */
    delete<T extends WorkTechnologyDeleteArgs>(args: SelectSubset<T, WorkTechnologyDeleteArgs<ExtArgs>>): Prisma__WorkTechnologyClient<$Result.GetResult<Prisma.$WorkTechnologyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkTechnology.
     * @param {WorkTechnologyUpdateArgs} args - Arguments to update one WorkTechnology.
     * @example
     * // Update one WorkTechnology
     * const workTechnology = await prisma.workTechnology.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkTechnologyUpdateArgs>(args: SelectSubset<T, WorkTechnologyUpdateArgs<ExtArgs>>): Prisma__WorkTechnologyClient<$Result.GetResult<Prisma.$WorkTechnologyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkTechnologies.
     * @param {WorkTechnologyDeleteManyArgs} args - Arguments to filter WorkTechnologies to delete.
     * @example
     * // Delete a few WorkTechnologies
     * const { count } = await prisma.workTechnology.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkTechnologyDeleteManyArgs>(args?: SelectSubset<T, WorkTechnologyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkTechnologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTechnologyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkTechnologies
     * const workTechnology = await prisma.workTechnology.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkTechnologyUpdateManyArgs>(args: SelectSubset<T, WorkTechnologyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkTechnologies and returns the data updated in the database.
     * @param {WorkTechnologyUpdateManyAndReturnArgs} args - Arguments to update many WorkTechnologies.
     * @example
     * // Update many WorkTechnologies
     * const workTechnology = await prisma.workTechnology.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkTechnologies and only return the `id`
     * const workTechnologyWithIdOnly = await prisma.workTechnology.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkTechnologyUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkTechnologyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkTechnologyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkTechnology.
     * @param {WorkTechnologyUpsertArgs} args - Arguments to update or create a WorkTechnology.
     * @example
     * // Update or create a WorkTechnology
     * const workTechnology = await prisma.workTechnology.upsert({
     *   create: {
     *     // ... data to create a WorkTechnology
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkTechnology we want to update
     *   }
     * })
     */
    upsert<T extends WorkTechnologyUpsertArgs>(args: SelectSubset<T, WorkTechnologyUpsertArgs<ExtArgs>>): Prisma__WorkTechnologyClient<$Result.GetResult<Prisma.$WorkTechnologyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkTechnologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTechnologyCountArgs} args - Arguments to filter WorkTechnologies to count.
     * @example
     * // Count the number of WorkTechnologies
     * const count = await prisma.workTechnology.count({
     *   where: {
     *     // ... the filter for the WorkTechnologies we want to count
     *   }
     * })
    **/
    count<T extends WorkTechnologyCountArgs>(
      args?: Subset<T, WorkTechnologyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkTechnologyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkTechnology.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTechnologyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkTechnologyAggregateArgs>(args: Subset<T, WorkTechnologyAggregateArgs>): Prisma.PrismaPromise<GetWorkTechnologyAggregateType<T>>

    /**
     * Group by WorkTechnology.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTechnologyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkTechnologyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkTechnologyGroupByArgs['orderBy'] }
        : { orderBy?: WorkTechnologyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkTechnologyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkTechnologyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkTechnology model
   */
  readonly fields: WorkTechnologyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkTechnology.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkTechnologyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workExperience<T extends WorkExperienceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkExperienceDefaultArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkTechnology model
   */
  interface WorkTechnologyFieldRefs {
    readonly id: FieldRef<"WorkTechnology", 'String'>
    readonly experienceId: FieldRef<"WorkTechnology", 'String'>
    readonly technology: FieldRef<"WorkTechnology", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkTechnology findUnique
   */
  export type WorkTechnologyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTechnology
     */
    select?: WorkTechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTechnology
     */
    omit?: WorkTechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTechnologyInclude<ExtArgs> | null
    /**
     * Filter, which WorkTechnology to fetch.
     */
    where: WorkTechnologyWhereUniqueInput
  }

  /**
   * WorkTechnology findUniqueOrThrow
   */
  export type WorkTechnologyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTechnology
     */
    select?: WorkTechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTechnology
     */
    omit?: WorkTechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTechnologyInclude<ExtArgs> | null
    /**
     * Filter, which WorkTechnology to fetch.
     */
    where: WorkTechnologyWhereUniqueInput
  }

  /**
   * WorkTechnology findFirst
   */
  export type WorkTechnologyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTechnology
     */
    select?: WorkTechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTechnology
     */
    omit?: WorkTechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTechnologyInclude<ExtArgs> | null
    /**
     * Filter, which WorkTechnology to fetch.
     */
    where?: WorkTechnologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkTechnologies to fetch.
     */
    orderBy?: WorkTechnologyOrderByWithRelationInput | WorkTechnologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkTechnologies.
     */
    cursor?: WorkTechnologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkTechnologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkTechnologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkTechnologies.
     */
    distinct?: WorkTechnologyScalarFieldEnum | WorkTechnologyScalarFieldEnum[]
  }

  /**
   * WorkTechnology findFirstOrThrow
   */
  export type WorkTechnologyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTechnology
     */
    select?: WorkTechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTechnology
     */
    omit?: WorkTechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTechnologyInclude<ExtArgs> | null
    /**
     * Filter, which WorkTechnology to fetch.
     */
    where?: WorkTechnologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkTechnologies to fetch.
     */
    orderBy?: WorkTechnologyOrderByWithRelationInput | WorkTechnologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkTechnologies.
     */
    cursor?: WorkTechnologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkTechnologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkTechnologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkTechnologies.
     */
    distinct?: WorkTechnologyScalarFieldEnum | WorkTechnologyScalarFieldEnum[]
  }

  /**
   * WorkTechnology findMany
   */
  export type WorkTechnologyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTechnology
     */
    select?: WorkTechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTechnology
     */
    omit?: WorkTechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTechnologyInclude<ExtArgs> | null
    /**
     * Filter, which WorkTechnologies to fetch.
     */
    where?: WorkTechnologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkTechnologies to fetch.
     */
    orderBy?: WorkTechnologyOrderByWithRelationInput | WorkTechnologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkTechnologies.
     */
    cursor?: WorkTechnologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkTechnologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkTechnologies.
     */
    skip?: number
    distinct?: WorkTechnologyScalarFieldEnum | WorkTechnologyScalarFieldEnum[]
  }

  /**
   * WorkTechnology create
   */
  export type WorkTechnologyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTechnology
     */
    select?: WorkTechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTechnology
     */
    omit?: WorkTechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTechnologyInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkTechnology.
     */
    data: XOR<WorkTechnologyCreateInput, WorkTechnologyUncheckedCreateInput>
  }

  /**
   * WorkTechnology createMany
   */
  export type WorkTechnologyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkTechnologies.
     */
    data: WorkTechnologyCreateManyInput | WorkTechnologyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkTechnology createManyAndReturn
   */
  export type WorkTechnologyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTechnology
     */
    select?: WorkTechnologySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTechnology
     */
    omit?: WorkTechnologyOmit<ExtArgs> | null
    /**
     * The data used to create many WorkTechnologies.
     */
    data: WorkTechnologyCreateManyInput | WorkTechnologyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTechnologyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkTechnology update
   */
  export type WorkTechnologyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTechnology
     */
    select?: WorkTechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTechnology
     */
    omit?: WorkTechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTechnologyInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkTechnology.
     */
    data: XOR<WorkTechnologyUpdateInput, WorkTechnologyUncheckedUpdateInput>
    /**
     * Choose, which WorkTechnology to update.
     */
    where: WorkTechnologyWhereUniqueInput
  }

  /**
   * WorkTechnology updateMany
   */
  export type WorkTechnologyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkTechnologies.
     */
    data: XOR<WorkTechnologyUpdateManyMutationInput, WorkTechnologyUncheckedUpdateManyInput>
    /**
     * Filter which WorkTechnologies to update
     */
    where?: WorkTechnologyWhereInput
    /**
     * Limit how many WorkTechnologies to update.
     */
    limit?: number
  }

  /**
   * WorkTechnology updateManyAndReturn
   */
  export type WorkTechnologyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTechnology
     */
    select?: WorkTechnologySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTechnology
     */
    omit?: WorkTechnologyOmit<ExtArgs> | null
    /**
     * The data used to update WorkTechnologies.
     */
    data: XOR<WorkTechnologyUpdateManyMutationInput, WorkTechnologyUncheckedUpdateManyInput>
    /**
     * Filter which WorkTechnologies to update
     */
    where?: WorkTechnologyWhereInput
    /**
     * Limit how many WorkTechnologies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTechnologyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkTechnology upsert
   */
  export type WorkTechnologyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTechnology
     */
    select?: WorkTechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTechnology
     */
    omit?: WorkTechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTechnologyInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkTechnology to update in case it exists.
     */
    where: WorkTechnologyWhereUniqueInput
    /**
     * In case the WorkTechnology found by the `where` argument doesn't exist, create a new WorkTechnology with this data.
     */
    create: XOR<WorkTechnologyCreateInput, WorkTechnologyUncheckedCreateInput>
    /**
     * In case the WorkTechnology was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkTechnologyUpdateInput, WorkTechnologyUncheckedUpdateInput>
  }

  /**
   * WorkTechnology delete
   */
  export type WorkTechnologyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTechnology
     */
    select?: WorkTechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTechnology
     */
    omit?: WorkTechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTechnologyInclude<ExtArgs> | null
    /**
     * Filter which WorkTechnology to delete.
     */
    where: WorkTechnologyWhereUniqueInput
  }

  /**
   * WorkTechnology deleteMany
   */
  export type WorkTechnologyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkTechnologies to delete
     */
    where?: WorkTechnologyWhereInput
    /**
     * Limit how many WorkTechnologies to delete.
     */
    limit?: number
  }

  /**
   * WorkTechnology without action
   */
  export type WorkTechnologyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTechnology
     */
    select?: WorkTechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTechnology
     */
    omit?: WorkTechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTechnologyInclude<ExtArgs> | null
  }


  /**
   * Model WorkAchievement
   */

  export type AggregateWorkAchievement = {
    _count: WorkAchievementCountAggregateOutputType | null
    _min: WorkAchievementMinAggregateOutputType | null
    _max: WorkAchievementMaxAggregateOutputType | null
  }

  export type WorkAchievementMinAggregateOutputType = {
    id: string | null
    experienceId: string | null
    achievement: string | null
  }

  export type WorkAchievementMaxAggregateOutputType = {
    id: string | null
    experienceId: string | null
    achievement: string | null
  }

  export type WorkAchievementCountAggregateOutputType = {
    id: number
    experienceId: number
    achievement: number
    _all: number
  }


  export type WorkAchievementMinAggregateInputType = {
    id?: true
    experienceId?: true
    achievement?: true
  }

  export type WorkAchievementMaxAggregateInputType = {
    id?: true
    experienceId?: true
    achievement?: true
  }

  export type WorkAchievementCountAggregateInputType = {
    id?: true
    experienceId?: true
    achievement?: true
    _all?: true
  }

  export type WorkAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkAchievement to aggregate.
     */
    where?: WorkAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkAchievements to fetch.
     */
    orderBy?: WorkAchievementOrderByWithRelationInput | WorkAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkAchievements
    **/
    _count?: true | WorkAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkAchievementMaxAggregateInputType
  }

  export type GetWorkAchievementAggregateType<T extends WorkAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkAchievement[P]>
      : GetScalarType<T[P], AggregateWorkAchievement[P]>
  }




  export type WorkAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkAchievementWhereInput
    orderBy?: WorkAchievementOrderByWithAggregationInput | WorkAchievementOrderByWithAggregationInput[]
    by: WorkAchievementScalarFieldEnum[] | WorkAchievementScalarFieldEnum
    having?: WorkAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkAchievementCountAggregateInputType | true
    _min?: WorkAchievementMinAggregateInputType
    _max?: WorkAchievementMaxAggregateInputType
  }

  export type WorkAchievementGroupByOutputType = {
    id: string
    experienceId: string
    achievement: string
    _count: WorkAchievementCountAggregateOutputType | null
    _min: WorkAchievementMinAggregateOutputType | null
    _max: WorkAchievementMaxAggregateOutputType | null
  }

  type GetWorkAchievementGroupByPayload<T extends WorkAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], WorkAchievementGroupByOutputType[P]>
        }
      >
    >


  export type WorkAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experienceId?: boolean
    achievement?: boolean
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workAchievement"]>

  export type WorkAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experienceId?: boolean
    achievement?: boolean
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workAchievement"]>

  export type WorkAchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experienceId?: boolean
    achievement?: boolean
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workAchievement"]>

  export type WorkAchievementSelectScalar = {
    id?: boolean
    experienceId?: boolean
    achievement?: boolean
  }

  export type WorkAchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "experienceId" | "achievement", ExtArgs["result"]["workAchievement"]>
  export type WorkAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }
  export type WorkAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }
  export type WorkAchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workExperience?: boolean | WorkExperienceDefaultArgs<ExtArgs>
  }

  export type $WorkAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkAchievement"
    objects: {
      workExperience: Prisma.$WorkExperiencePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      experienceId: string
      achievement: string
    }, ExtArgs["result"]["workAchievement"]>
    composites: {}
  }

  type WorkAchievementGetPayload<S extends boolean | null | undefined | WorkAchievementDefaultArgs> = $Result.GetResult<Prisma.$WorkAchievementPayload, S>

  type WorkAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkAchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkAchievementCountAggregateInputType | true
    }

  export interface WorkAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkAchievement'], meta: { name: 'WorkAchievement' } }
    /**
     * Find zero or one WorkAchievement that matches the filter.
     * @param {WorkAchievementFindUniqueArgs} args - Arguments to find a WorkAchievement
     * @example
     * // Get one WorkAchievement
     * const workAchievement = await prisma.workAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkAchievementFindUniqueArgs>(args: SelectSubset<T, WorkAchievementFindUniqueArgs<ExtArgs>>): Prisma__WorkAchievementClient<$Result.GetResult<Prisma.$WorkAchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkAchievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkAchievementFindUniqueOrThrowArgs} args - Arguments to find a WorkAchievement
     * @example
     * // Get one WorkAchievement
     * const workAchievement = await prisma.workAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkAchievementClient<$Result.GetResult<Prisma.$WorkAchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkAchievementFindFirstArgs} args - Arguments to find a WorkAchievement
     * @example
     * // Get one WorkAchievement
     * const workAchievement = await prisma.workAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkAchievementFindFirstArgs>(args?: SelectSubset<T, WorkAchievementFindFirstArgs<ExtArgs>>): Prisma__WorkAchievementClient<$Result.GetResult<Prisma.$WorkAchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkAchievementFindFirstOrThrowArgs} args - Arguments to find a WorkAchievement
     * @example
     * // Get one WorkAchievement
     * const workAchievement = await prisma.workAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkAchievementClient<$Result.GetResult<Prisma.$WorkAchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkAchievements
     * const workAchievements = await prisma.workAchievement.findMany()
     * 
     * // Get first 10 WorkAchievements
     * const workAchievements = await prisma.workAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workAchievementWithIdOnly = await prisma.workAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkAchievementFindManyArgs>(args?: SelectSubset<T, WorkAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkAchievement.
     * @param {WorkAchievementCreateArgs} args - Arguments to create a WorkAchievement.
     * @example
     * // Create one WorkAchievement
     * const WorkAchievement = await prisma.workAchievement.create({
     *   data: {
     *     // ... data to create a WorkAchievement
     *   }
     * })
     * 
     */
    create<T extends WorkAchievementCreateArgs>(args: SelectSubset<T, WorkAchievementCreateArgs<ExtArgs>>): Prisma__WorkAchievementClient<$Result.GetResult<Prisma.$WorkAchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkAchievements.
     * @param {WorkAchievementCreateManyArgs} args - Arguments to create many WorkAchievements.
     * @example
     * // Create many WorkAchievements
     * const workAchievement = await prisma.workAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkAchievementCreateManyArgs>(args?: SelectSubset<T, WorkAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkAchievements and returns the data saved in the database.
     * @param {WorkAchievementCreateManyAndReturnArgs} args - Arguments to create many WorkAchievements.
     * @example
     * // Create many WorkAchievements
     * const workAchievement = await prisma.workAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkAchievements and only return the `id`
     * const workAchievementWithIdOnly = await prisma.workAchievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkAchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkAchievement.
     * @param {WorkAchievementDeleteArgs} args - Arguments to delete one WorkAchievement.
     * @example
     * // Delete one WorkAchievement
     * const WorkAchievement = await prisma.workAchievement.delete({
     *   where: {
     *     // ... filter to delete one WorkAchievement
     *   }
     * })
     * 
     */
    delete<T extends WorkAchievementDeleteArgs>(args: SelectSubset<T, WorkAchievementDeleteArgs<ExtArgs>>): Prisma__WorkAchievementClient<$Result.GetResult<Prisma.$WorkAchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkAchievement.
     * @param {WorkAchievementUpdateArgs} args - Arguments to update one WorkAchievement.
     * @example
     * // Update one WorkAchievement
     * const workAchievement = await prisma.workAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkAchievementUpdateArgs>(args: SelectSubset<T, WorkAchievementUpdateArgs<ExtArgs>>): Prisma__WorkAchievementClient<$Result.GetResult<Prisma.$WorkAchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkAchievements.
     * @param {WorkAchievementDeleteManyArgs} args - Arguments to filter WorkAchievements to delete.
     * @example
     * // Delete a few WorkAchievements
     * const { count } = await prisma.workAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkAchievementDeleteManyArgs>(args?: SelectSubset<T, WorkAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkAchievements
     * const workAchievement = await prisma.workAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkAchievementUpdateManyArgs>(args: SelectSubset<T, WorkAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkAchievements and returns the data updated in the database.
     * @param {WorkAchievementUpdateManyAndReturnArgs} args - Arguments to update many WorkAchievements.
     * @example
     * // Update many WorkAchievements
     * const workAchievement = await prisma.workAchievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkAchievements and only return the `id`
     * const workAchievementWithIdOnly = await prisma.workAchievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkAchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkAchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkAchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkAchievement.
     * @param {WorkAchievementUpsertArgs} args - Arguments to update or create a WorkAchievement.
     * @example
     * // Update or create a WorkAchievement
     * const workAchievement = await prisma.workAchievement.upsert({
     *   create: {
     *     // ... data to create a WorkAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkAchievement we want to update
     *   }
     * })
     */
    upsert<T extends WorkAchievementUpsertArgs>(args: SelectSubset<T, WorkAchievementUpsertArgs<ExtArgs>>): Prisma__WorkAchievementClient<$Result.GetResult<Prisma.$WorkAchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkAchievementCountArgs} args - Arguments to filter WorkAchievements to count.
     * @example
     * // Count the number of WorkAchievements
     * const count = await prisma.workAchievement.count({
     *   where: {
     *     // ... the filter for the WorkAchievements we want to count
     *   }
     * })
    **/
    count<T extends WorkAchievementCountArgs>(
      args?: Subset<T, WorkAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkAchievementAggregateArgs>(args: Subset<T, WorkAchievementAggregateArgs>): Prisma.PrismaPromise<GetWorkAchievementAggregateType<T>>

    /**
     * Group by WorkAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkAchievementGroupByArgs['orderBy'] }
        : { orderBy?: WorkAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkAchievement model
   */
  readonly fields: WorkAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workExperience<T extends WorkExperienceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkExperienceDefaultArgs<ExtArgs>>): Prisma__WorkExperienceClient<$Result.GetResult<Prisma.$WorkExperiencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkAchievement model
   */
  interface WorkAchievementFieldRefs {
    readonly id: FieldRef<"WorkAchievement", 'String'>
    readonly experienceId: FieldRef<"WorkAchievement", 'String'>
    readonly achievement: FieldRef<"WorkAchievement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkAchievement findUnique
   */
  export type WorkAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkAchievement
     */
    select?: WorkAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkAchievement
     */
    omit?: WorkAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkAchievementInclude<ExtArgs> | null
    /**
     * Filter, which WorkAchievement to fetch.
     */
    where: WorkAchievementWhereUniqueInput
  }

  /**
   * WorkAchievement findUniqueOrThrow
   */
  export type WorkAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkAchievement
     */
    select?: WorkAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkAchievement
     */
    omit?: WorkAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkAchievementInclude<ExtArgs> | null
    /**
     * Filter, which WorkAchievement to fetch.
     */
    where: WorkAchievementWhereUniqueInput
  }

  /**
   * WorkAchievement findFirst
   */
  export type WorkAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkAchievement
     */
    select?: WorkAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkAchievement
     */
    omit?: WorkAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkAchievementInclude<ExtArgs> | null
    /**
     * Filter, which WorkAchievement to fetch.
     */
    where?: WorkAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkAchievements to fetch.
     */
    orderBy?: WorkAchievementOrderByWithRelationInput | WorkAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkAchievements.
     */
    cursor?: WorkAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkAchievements.
     */
    distinct?: WorkAchievementScalarFieldEnum | WorkAchievementScalarFieldEnum[]
  }

  /**
   * WorkAchievement findFirstOrThrow
   */
  export type WorkAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkAchievement
     */
    select?: WorkAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkAchievement
     */
    omit?: WorkAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkAchievementInclude<ExtArgs> | null
    /**
     * Filter, which WorkAchievement to fetch.
     */
    where?: WorkAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkAchievements to fetch.
     */
    orderBy?: WorkAchievementOrderByWithRelationInput | WorkAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkAchievements.
     */
    cursor?: WorkAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkAchievements.
     */
    distinct?: WorkAchievementScalarFieldEnum | WorkAchievementScalarFieldEnum[]
  }

  /**
   * WorkAchievement findMany
   */
  export type WorkAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkAchievement
     */
    select?: WorkAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkAchievement
     */
    omit?: WorkAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkAchievementInclude<ExtArgs> | null
    /**
     * Filter, which WorkAchievements to fetch.
     */
    where?: WorkAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkAchievements to fetch.
     */
    orderBy?: WorkAchievementOrderByWithRelationInput | WorkAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkAchievements.
     */
    cursor?: WorkAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkAchievements.
     */
    skip?: number
    distinct?: WorkAchievementScalarFieldEnum | WorkAchievementScalarFieldEnum[]
  }

  /**
   * WorkAchievement create
   */
  export type WorkAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkAchievement
     */
    select?: WorkAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkAchievement
     */
    omit?: WorkAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkAchievement.
     */
    data: XOR<WorkAchievementCreateInput, WorkAchievementUncheckedCreateInput>
  }

  /**
   * WorkAchievement createMany
   */
  export type WorkAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkAchievements.
     */
    data: WorkAchievementCreateManyInput | WorkAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkAchievement createManyAndReturn
   */
  export type WorkAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkAchievement
     */
    select?: WorkAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkAchievement
     */
    omit?: WorkAchievementOmit<ExtArgs> | null
    /**
     * The data used to create many WorkAchievements.
     */
    data: WorkAchievementCreateManyInput | WorkAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkAchievement update
   */
  export type WorkAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkAchievement
     */
    select?: WorkAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkAchievement
     */
    omit?: WorkAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkAchievement.
     */
    data: XOR<WorkAchievementUpdateInput, WorkAchievementUncheckedUpdateInput>
    /**
     * Choose, which WorkAchievement to update.
     */
    where: WorkAchievementWhereUniqueInput
  }

  /**
   * WorkAchievement updateMany
   */
  export type WorkAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkAchievements.
     */
    data: XOR<WorkAchievementUpdateManyMutationInput, WorkAchievementUncheckedUpdateManyInput>
    /**
     * Filter which WorkAchievements to update
     */
    where?: WorkAchievementWhereInput
    /**
     * Limit how many WorkAchievements to update.
     */
    limit?: number
  }

  /**
   * WorkAchievement updateManyAndReturn
   */
  export type WorkAchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkAchievement
     */
    select?: WorkAchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkAchievement
     */
    omit?: WorkAchievementOmit<ExtArgs> | null
    /**
     * The data used to update WorkAchievements.
     */
    data: XOR<WorkAchievementUpdateManyMutationInput, WorkAchievementUncheckedUpdateManyInput>
    /**
     * Filter which WorkAchievements to update
     */
    where?: WorkAchievementWhereInput
    /**
     * Limit how many WorkAchievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkAchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkAchievement upsert
   */
  export type WorkAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkAchievement
     */
    select?: WorkAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkAchievement
     */
    omit?: WorkAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkAchievement to update in case it exists.
     */
    where: WorkAchievementWhereUniqueInput
    /**
     * In case the WorkAchievement found by the `where` argument doesn't exist, create a new WorkAchievement with this data.
     */
    create: XOR<WorkAchievementCreateInput, WorkAchievementUncheckedCreateInput>
    /**
     * In case the WorkAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkAchievementUpdateInput, WorkAchievementUncheckedUpdateInput>
  }

  /**
   * WorkAchievement delete
   */
  export type WorkAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkAchievement
     */
    select?: WorkAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkAchievement
     */
    omit?: WorkAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkAchievementInclude<ExtArgs> | null
    /**
     * Filter which WorkAchievement to delete.
     */
    where: WorkAchievementWhereUniqueInput
  }

  /**
   * WorkAchievement deleteMany
   */
  export type WorkAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkAchievements to delete
     */
    where?: WorkAchievementWhereInput
    /**
     * Limit how many WorkAchievements to delete.
     */
    limit?: number
  }

  /**
   * WorkAchievement without action
   */
  export type WorkAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkAchievement
     */
    select?: WorkAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkAchievement
     */
    omit?: WorkAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkAchievementInclude<ExtArgs> | null
  }


  /**
   * Model Education
   */

  export type AggregateEducation = {
    _count: EducationCountAggregateOutputType | null
    _min: EducationMinAggregateOutputType | null
    _max: EducationMaxAggregateOutputType | null
  }

  export type EducationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    institution: string | null
    degree: string | null
    field: string | null
    period: string | null
    description: string | null
    gpa: string | null
    location: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EducationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    institution: string | null
    degree: string | null
    field: string | null
    period: string | null
    description: string | null
    gpa: string | null
    location: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EducationCountAggregateOutputType = {
    id: number
    userId: number
    institution: number
    degree: number
    field: number
    period: number
    description: number
    gpa: number
    location: number
    logo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EducationMinAggregateInputType = {
    id?: true
    userId?: true
    institution?: true
    degree?: true
    field?: true
    period?: true
    description?: true
    gpa?: true
    location?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EducationMaxAggregateInputType = {
    id?: true
    userId?: true
    institution?: true
    degree?: true
    field?: true
    period?: true
    description?: true
    gpa?: true
    location?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EducationCountAggregateInputType = {
    id?: true
    userId?: true
    institution?: true
    degree?: true
    field?: true
    period?: true
    description?: true
    gpa?: true
    location?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EducationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Education to aggregate.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Educations
    **/
    _count?: true | EducationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationMaxAggregateInputType
  }

  export type GetEducationAggregateType<T extends EducationAggregateArgs> = {
        [P in keyof T & keyof AggregateEducation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducation[P]>
      : GetScalarType<T[P], AggregateEducation[P]>
  }




  export type EducationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationWhereInput
    orderBy?: EducationOrderByWithAggregationInput | EducationOrderByWithAggregationInput[]
    by: EducationScalarFieldEnum[] | EducationScalarFieldEnum
    having?: EducationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationCountAggregateInputType | true
    _min?: EducationMinAggregateInputType
    _max?: EducationMaxAggregateInputType
  }

  export type EducationGroupByOutputType = {
    id: string
    userId: string
    institution: string
    degree: string
    field: string
    period: string
    description: string | null
    gpa: string | null
    location: string | null
    logo: string | null
    createdAt: Date
    updatedAt: Date
    _count: EducationCountAggregateOutputType | null
    _min: EducationMinAggregateOutputType | null
    _max: EducationMaxAggregateOutputType | null
  }

  type GetEducationGroupByPayload<T extends EducationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationGroupByOutputType[P]>
            : GetScalarType<T[P], EducationGroupByOutputType[P]>
        }
      >
    >


  export type EducationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    institution?: boolean
    degree?: boolean
    field?: boolean
    period?: boolean
    description?: boolean
    gpa?: boolean
    location?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievements?: boolean | Education$achievementsArgs<ExtArgs>
    _count?: boolean | EducationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>

  export type EducationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    institution?: boolean
    degree?: boolean
    field?: boolean
    period?: boolean
    description?: boolean
    gpa?: boolean
    location?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>

  export type EducationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    institution?: boolean
    degree?: boolean
    field?: boolean
    period?: boolean
    description?: boolean
    gpa?: boolean
    location?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>

  export type EducationSelectScalar = {
    id?: boolean
    userId?: boolean
    institution?: boolean
    degree?: boolean
    field?: boolean
    period?: boolean
    description?: boolean
    gpa?: boolean
    location?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EducationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "institution" | "degree" | "field" | "period" | "description" | "gpa" | "location" | "logo" | "createdAt" | "updatedAt", ExtArgs["result"]["education"]>
  export type EducationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievements?: boolean | Education$achievementsArgs<ExtArgs>
    _count?: boolean | EducationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EducationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EducationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EducationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Education"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      achievements: Prisma.$EducationAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      institution: string
      degree: string
      field: string
      period: string
      description: string | null
      gpa: string | null
      location: string | null
      logo: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["education"]>
    composites: {}
  }

  type EducationGetPayload<S extends boolean | null | undefined | EducationDefaultArgs> = $Result.GetResult<Prisma.$EducationPayload, S>

  type EducationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EducationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EducationCountAggregateInputType | true
    }

  export interface EducationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Education'], meta: { name: 'Education' } }
    /**
     * Find zero or one Education that matches the filter.
     * @param {EducationFindUniqueArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationFindUniqueArgs>(args: SelectSubset<T, EducationFindUniqueArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Education that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EducationFindUniqueOrThrowArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Education that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindFirstArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationFindFirstArgs>(args?: SelectSubset<T, EducationFindFirstArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Education that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindFirstOrThrowArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Educations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Educations
     * const educations = await prisma.education.findMany()
     * 
     * // Get first 10 Educations
     * const educations = await prisma.education.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const educationWithIdOnly = await prisma.education.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EducationFindManyArgs>(args?: SelectSubset<T, EducationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Education.
     * @param {EducationCreateArgs} args - Arguments to create a Education.
     * @example
     * // Create one Education
     * const Education = await prisma.education.create({
     *   data: {
     *     // ... data to create a Education
     *   }
     * })
     * 
     */
    create<T extends EducationCreateArgs>(args: SelectSubset<T, EducationCreateArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Educations.
     * @param {EducationCreateManyArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const education = await prisma.education.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationCreateManyArgs>(args?: SelectSubset<T, EducationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Educations and returns the data saved in the database.
     * @param {EducationCreateManyAndReturnArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const education = await prisma.education.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Educations and only return the `id`
     * const educationWithIdOnly = await prisma.education.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EducationCreateManyAndReturnArgs>(args?: SelectSubset<T, EducationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Education.
     * @param {EducationDeleteArgs} args - Arguments to delete one Education.
     * @example
     * // Delete one Education
     * const Education = await prisma.education.delete({
     *   where: {
     *     // ... filter to delete one Education
     *   }
     * })
     * 
     */
    delete<T extends EducationDeleteArgs>(args: SelectSubset<T, EducationDeleteArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Education.
     * @param {EducationUpdateArgs} args - Arguments to update one Education.
     * @example
     * // Update one Education
     * const education = await prisma.education.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationUpdateArgs>(args: SelectSubset<T, EducationUpdateArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Educations.
     * @param {EducationDeleteManyArgs} args - Arguments to filter Educations to delete.
     * @example
     * // Delete a few Educations
     * const { count } = await prisma.education.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationDeleteManyArgs>(args?: SelectSubset<T, EducationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Educations
     * const education = await prisma.education.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationUpdateManyArgs>(args: SelectSubset<T, EducationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations and returns the data updated in the database.
     * @param {EducationUpdateManyAndReturnArgs} args - Arguments to update many Educations.
     * @example
     * // Update many Educations
     * const education = await prisma.education.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Educations and only return the `id`
     * const educationWithIdOnly = await prisma.education.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EducationUpdateManyAndReturnArgs>(args: SelectSubset<T, EducationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Education.
     * @param {EducationUpsertArgs} args - Arguments to update or create a Education.
     * @example
     * // Update or create a Education
     * const education = await prisma.education.upsert({
     *   create: {
     *     // ... data to create a Education
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Education we want to update
     *   }
     * })
     */
    upsert<T extends EducationUpsertArgs>(args: SelectSubset<T, EducationUpsertArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationCountArgs} args - Arguments to filter Educations to count.
     * @example
     * // Count the number of Educations
     * const count = await prisma.education.count({
     *   where: {
     *     // ... the filter for the Educations we want to count
     *   }
     * })
    **/
    count<T extends EducationCountArgs>(
      args?: Subset<T, EducationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationAggregateArgs>(args: Subset<T, EducationAggregateArgs>): Prisma.PrismaPromise<GetEducationAggregateType<T>>

    /**
     * Group by Education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationGroupByArgs['orderBy'] }
        : { orderBy?: EducationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Education model
   */
  readonly fields: EducationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Education.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    achievements<T extends Education$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, Education$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Education model
   */
  interface EducationFieldRefs {
    readonly id: FieldRef<"Education", 'String'>
    readonly userId: FieldRef<"Education", 'String'>
    readonly institution: FieldRef<"Education", 'String'>
    readonly degree: FieldRef<"Education", 'String'>
    readonly field: FieldRef<"Education", 'String'>
    readonly period: FieldRef<"Education", 'String'>
    readonly description: FieldRef<"Education", 'String'>
    readonly gpa: FieldRef<"Education", 'String'>
    readonly location: FieldRef<"Education", 'String'>
    readonly logo: FieldRef<"Education", 'String'>
    readonly createdAt: FieldRef<"Education", 'DateTime'>
    readonly updatedAt: FieldRef<"Education", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Education findUnique
   */
  export type EducationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education findUniqueOrThrow
   */
  export type EducationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education findFirst
   */
  export type EducationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Educations.
     */
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education findFirstOrThrow
   */
  export type EducationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Educations.
     */
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education findMany
   */
  export type EducationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Educations to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education create
   */
  export type EducationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The data needed to create a Education.
     */
    data: XOR<EducationCreateInput, EducationUncheckedCreateInput>
  }

  /**
   * Education createMany
   */
  export type EducationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Educations.
     */
    data: EducationCreateManyInput | EducationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Education createManyAndReturn
   */
  export type EducationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * The data used to create many Educations.
     */
    data: EducationCreateManyInput | EducationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Education update
   */
  export type EducationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The data needed to update a Education.
     */
    data: XOR<EducationUpdateInput, EducationUncheckedUpdateInput>
    /**
     * Choose, which Education to update.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education updateMany
   */
  export type EducationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Educations.
     */
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyInput>
    /**
     * Filter which Educations to update
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to update.
     */
    limit?: number
  }

  /**
   * Education updateManyAndReturn
   */
  export type EducationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * The data used to update Educations.
     */
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyInput>
    /**
     * Filter which Educations to update
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Education upsert
   */
  export type EducationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The filter to search for the Education to update in case it exists.
     */
    where: EducationWhereUniqueInput
    /**
     * In case the Education found by the `where` argument doesn't exist, create a new Education with this data.
     */
    create: XOR<EducationCreateInput, EducationUncheckedCreateInput>
    /**
     * In case the Education was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationUpdateInput, EducationUncheckedUpdateInput>
  }

  /**
   * Education delete
   */
  export type EducationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter which Education to delete.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education deleteMany
   */
  export type EducationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Educations to delete
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to delete.
     */
    limit?: number
  }

  /**
   * Education.achievements
   */
  export type Education$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationAchievement
     */
    select?: EducationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationAchievement
     */
    omit?: EducationAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationAchievementInclude<ExtArgs> | null
    where?: EducationAchievementWhereInput
    orderBy?: EducationAchievementOrderByWithRelationInput | EducationAchievementOrderByWithRelationInput[]
    cursor?: EducationAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationAchievementScalarFieldEnum | EducationAchievementScalarFieldEnum[]
  }

  /**
   * Education without action
   */
  export type EducationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
  }


  /**
   * Model EducationAchievement
   */

  export type AggregateEducationAchievement = {
    _count: EducationAchievementCountAggregateOutputType | null
    _min: EducationAchievementMinAggregateOutputType | null
    _max: EducationAchievementMaxAggregateOutputType | null
  }

  export type EducationAchievementMinAggregateOutputType = {
    id: string | null
    educationId: string | null
    achievement: string | null
  }

  export type EducationAchievementMaxAggregateOutputType = {
    id: string | null
    educationId: string | null
    achievement: string | null
  }

  export type EducationAchievementCountAggregateOutputType = {
    id: number
    educationId: number
    achievement: number
    _all: number
  }


  export type EducationAchievementMinAggregateInputType = {
    id?: true
    educationId?: true
    achievement?: true
  }

  export type EducationAchievementMaxAggregateInputType = {
    id?: true
    educationId?: true
    achievement?: true
  }

  export type EducationAchievementCountAggregateInputType = {
    id?: true
    educationId?: true
    achievement?: true
    _all?: true
  }

  export type EducationAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationAchievement to aggregate.
     */
    where?: EducationAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationAchievements to fetch.
     */
    orderBy?: EducationAchievementOrderByWithRelationInput | EducationAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EducationAchievements
    **/
    _count?: true | EducationAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationAchievementMaxAggregateInputType
  }

  export type GetEducationAchievementAggregateType<T extends EducationAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateEducationAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducationAchievement[P]>
      : GetScalarType<T[P], AggregateEducationAchievement[P]>
  }




  export type EducationAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationAchievementWhereInput
    orderBy?: EducationAchievementOrderByWithAggregationInput | EducationAchievementOrderByWithAggregationInput[]
    by: EducationAchievementScalarFieldEnum[] | EducationAchievementScalarFieldEnum
    having?: EducationAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationAchievementCountAggregateInputType | true
    _min?: EducationAchievementMinAggregateInputType
    _max?: EducationAchievementMaxAggregateInputType
  }

  export type EducationAchievementGroupByOutputType = {
    id: string
    educationId: string
    achievement: string
    _count: EducationAchievementCountAggregateOutputType | null
    _min: EducationAchievementMinAggregateOutputType | null
    _max: EducationAchievementMaxAggregateOutputType | null
  }

  type GetEducationAchievementGroupByPayload<T extends EducationAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], EducationAchievementGroupByOutputType[P]>
        }
      >
    >


  export type EducationAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    educationId?: boolean
    achievement?: boolean
    education?: boolean | EducationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educationAchievement"]>

  export type EducationAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    educationId?: boolean
    achievement?: boolean
    education?: boolean | EducationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educationAchievement"]>

  export type EducationAchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    educationId?: boolean
    achievement?: boolean
    education?: boolean | EducationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educationAchievement"]>

  export type EducationAchievementSelectScalar = {
    id?: boolean
    educationId?: boolean
    achievement?: boolean
  }

  export type EducationAchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "educationId" | "achievement", ExtArgs["result"]["educationAchievement"]>
  export type EducationAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    education?: boolean | EducationDefaultArgs<ExtArgs>
  }
  export type EducationAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    education?: boolean | EducationDefaultArgs<ExtArgs>
  }
  export type EducationAchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    education?: boolean | EducationDefaultArgs<ExtArgs>
  }

  export type $EducationAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EducationAchievement"
    objects: {
      education: Prisma.$EducationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      educationId: string
      achievement: string
    }, ExtArgs["result"]["educationAchievement"]>
    composites: {}
  }

  type EducationAchievementGetPayload<S extends boolean | null | undefined | EducationAchievementDefaultArgs> = $Result.GetResult<Prisma.$EducationAchievementPayload, S>

  type EducationAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EducationAchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EducationAchievementCountAggregateInputType | true
    }

  export interface EducationAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EducationAchievement'], meta: { name: 'EducationAchievement' } }
    /**
     * Find zero or one EducationAchievement that matches the filter.
     * @param {EducationAchievementFindUniqueArgs} args - Arguments to find a EducationAchievement
     * @example
     * // Get one EducationAchievement
     * const educationAchievement = await prisma.educationAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationAchievementFindUniqueArgs>(args: SelectSubset<T, EducationAchievementFindUniqueArgs<ExtArgs>>): Prisma__EducationAchievementClient<$Result.GetResult<Prisma.$EducationAchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EducationAchievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EducationAchievementFindUniqueOrThrowArgs} args - Arguments to find a EducationAchievement
     * @example
     * // Get one EducationAchievement
     * const educationAchievement = await prisma.educationAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationAchievementClient<$Result.GetResult<Prisma.$EducationAchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EducationAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationAchievementFindFirstArgs} args - Arguments to find a EducationAchievement
     * @example
     * // Get one EducationAchievement
     * const educationAchievement = await prisma.educationAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationAchievementFindFirstArgs>(args?: SelectSubset<T, EducationAchievementFindFirstArgs<ExtArgs>>): Prisma__EducationAchievementClient<$Result.GetResult<Prisma.$EducationAchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EducationAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationAchievementFindFirstOrThrowArgs} args - Arguments to find a EducationAchievement
     * @example
     * // Get one EducationAchievement
     * const educationAchievement = await prisma.educationAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationAchievementClient<$Result.GetResult<Prisma.$EducationAchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EducationAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EducationAchievements
     * const educationAchievements = await prisma.educationAchievement.findMany()
     * 
     * // Get first 10 EducationAchievements
     * const educationAchievements = await prisma.educationAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const educationAchievementWithIdOnly = await prisma.educationAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EducationAchievementFindManyArgs>(args?: SelectSubset<T, EducationAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EducationAchievement.
     * @param {EducationAchievementCreateArgs} args - Arguments to create a EducationAchievement.
     * @example
     * // Create one EducationAchievement
     * const EducationAchievement = await prisma.educationAchievement.create({
     *   data: {
     *     // ... data to create a EducationAchievement
     *   }
     * })
     * 
     */
    create<T extends EducationAchievementCreateArgs>(args: SelectSubset<T, EducationAchievementCreateArgs<ExtArgs>>): Prisma__EducationAchievementClient<$Result.GetResult<Prisma.$EducationAchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EducationAchievements.
     * @param {EducationAchievementCreateManyArgs} args - Arguments to create many EducationAchievements.
     * @example
     * // Create many EducationAchievements
     * const educationAchievement = await prisma.educationAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationAchievementCreateManyArgs>(args?: SelectSubset<T, EducationAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EducationAchievements and returns the data saved in the database.
     * @param {EducationAchievementCreateManyAndReturnArgs} args - Arguments to create many EducationAchievements.
     * @example
     * // Create many EducationAchievements
     * const educationAchievement = await prisma.educationAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EducationAchievements and only return the `id`
     * const educationAchievementWithIdOnly = await prisma.educationAchievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EducationAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, EducationAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationAchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EducationAchievement.
     * @param {EducationAchievementDeleteArgs} args - Arguments to delete one EducationAchievement.
     * @example
     * // Delete one EducationAchievement
     * const EducationAchievement = await prisma.educationAchievement.delete({
     *   where: {
     *     // ... filter to delete one EducationAchievement
     *   }
     * })
     * 
     */
    delete<T extends EducationAchievementDeleteArgs>(args: SelectSubset<T, EducationAchievementDeleteArgs<ExtArgs>>): Prisma__EducationAchievementClient<$Result.GetResult<Prisma.$EducationAchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EducationAchievement.
     * @param {EducationAchievementUpdateArgs} args - Arguments to update one EducationAchievement.
     * @example
     * // Update one EducationAchievement
     * const educationAchievement = await prisma.educationAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationAchievementUpdateArgs>(args: SelectSubset<T, EducationAchievementUpdateArgs<ExtArgs>>): Prisma__EducationAchievementClient<$Result.GetResult<Prisma.$EducationAchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EducationAchievements.
     * @param {EducationAchievementDeleteManyArgs} args - Arguments to filter EducationAchievements to delete.
     * @example
     * // Delete a few EducationAchievements
     * const { count } = await prisma.educationAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationAchievementDeleteManyArgs>(args?: SelectSubset<T, EducationAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EducationAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EducationAchievements
     * const educationAchievement = await prisma.educationAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationAchievementUpdateManyArgs>(args: SelectSubset<T, EducationAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EducationAchievements and returns the data updated in the database.
     * @param {EducationAchievementUpdateManyAndReturnArgs} args - Arguments to update many EducationAchievements.
     * @example
     * // Update many EducationAchievements
     * const educationAchievement = await prisma.educationAchievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EducationAchievements and only return the `id`
     * const educationAchievementWithIdOnly = await prisma.educationAchievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EducationAchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, EducationAchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationAchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EducationAchievement.
     * @param {EducationAchievementUpsertArgs} args - Arguments to update or create a EducationAchievement.
     * @example
     * // Update or create a EducationAchievement
     * const educationAchievement = await prisma.educationAchievement.upsert({
     *   create: {
     *     // ... data to create a EducationAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EducationAchievement we want to update
     *   }
     * })
     */
    upsert<T extends EducationAchievementUpsertArgs>(args: SelectSubset<T, EducationAchievementUpsertArgs<ExtArgs>>): Prisma__EducationAchievementClient<$Result.GetResult<Prisma.$EducationAchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EducationAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationAchievementCountArgs} args - Arguments to filter EducationAchievements to count.
     * @example
     * // Count the number of EducationAchievements
     * const count = await prisma.educationAchievement.count({
     *   where: {
     *     // ... the filter for the EducationAchievements we want to count
     *   }
     * })
    **/
    count<T extends EducationAchievementCountArgs>(
      args?: Subset<T, EducationAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EducationAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationAchievementAggregateArgs>(args: Subset<T, EducationAchievementAggregateArgs>): Prisma.PrismaPromise<GetEducationAchievementAggregateType<T>>

    /**
     * Group by EducationAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationAchievementGroupByArgs['orderBy'] }
        : { orderBy?: EducationAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EducationAchievement model
   */
  readonly fields: EducationAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EducationAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    education<T extends EducationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EducationDefaultArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EducationAchievement model
   */
  interface EducationAchievementFieldRefs {
    readonly id: FieldRef<"EducationAchievement", 'String'>
    readonly educationId: FieldRef<"EducationAchievement", 'String'>
    readonly achievement: FieldRef<"EducationAchievement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EducationAchievement findUnique
   */
  export type EducationAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationAchievement
     */
    select?: EducationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationAchievement
     */
    omit?: EducationAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationAchievementInclude<ExtArgs> | null
    /**
     * Filter, which EducationAchievement to fetch.
     */
    where: EducationAchievementWhereUniqueInput
  }

  /**
   * EducationAchievement findUniqueOrThrow
   */
  export type EducationAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationAchievement
     */
    select?: EducationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationAchievement
     */
    omit?: EducationAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationAchievementInclude<ExtArgs> | null
    /**
     * Filter, which EducationAchievement to fetch.
     */
    where: EducationAchievementWhereUniqueInput
  }

  /**
   * EducationAchievement findFirst
   */
  export type EducationAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationAchievement
     */
    select?: EducationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationAchievement
     */
    omit?: EducationAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationAchievementInclude<ExtArgs> | null
    /**
     * Filter, which EducationAchievement to fetch.
     */
    where?: EducationAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationAchievements to fetch.
     */
    orderBy?: EducationAchievementOrderByWithRelationInput | EducationAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationAchievements.
     */
    cursor?: EducationAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationAchievements.
     */
    distinct?: EducationAchievementScalarFieldEnum | EducationAchievementScalarFieldEnum[]
  }

  /**
   * EducationAchievement findFirstOrThrow
   */
  export type EducationAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationAchievement
     */
    select?: EducationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationAchievement
     */
    omit?: EducationAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationAchievementInclude<ExtArgs> | null
    /**
     * Filter, which EducationAchievement to fetch.
     */
    where?: EducationAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationAchievements to fetch.
     */
    orderBy?: EducationAchievementOrderByWithRelationInput | EducationAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationAchievements.
     */
    cursor?: EducationAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationAchievements.
     */
    distinct?: EducationAchievementScalarFieldEnum | EducationAchievementScalarFieldEnum[]
  }

  /**
   * EducationAchievement findMany
   */
  export type EducationAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationAchievement
     */
    select?: EducationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationAchievement
     */
    omit?: EducationAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationAchievementInclude<ExtArgs> | null
    /**
     * Filter, which EducationAchievements to fetch.
     */
    where?: EducationAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationAchievements to fetch.
     */
    orderBy?: EducationAchievementOrderByWithRelationInput | EducationAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EducationAchievements.
     */
    cursor?: EducationAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationAchievements.
     */
    skip?: number
    distinct?: EducationAchievementScalarFieldEnum | EducationAchievementScalarFieldEnum[]
  }

  /**
   * EducationAchievement create
   */
  export type EducationAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationAchievement
     */
    select?: EducationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationAchievement
     */
    omit?: EducationAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a EducationAchievement.
     */
    data: XOR<EducationAchievementCreateInput, EducationAchievementUncheckedCreateInput>
  }

  /**
   * EducationAchievement createMany
   */
  export type EducationAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EducationAchievements.
     */
    data: EducationAchievementCreateManyInput | EducationAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EducationAchievement createManyAndReturn
   */
  export type EducationAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationAchievement
     */
    select?: EducationAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EducationAchievement
     */
    omit?: EducationAchievementOmit<ExtArgs> | null
    /**
     * The data used to create many EducationAchievements.
     */
    data: EducationAchievementCreateManyInput | EducationAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EducationAchievement update
   */
  export type EducationAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationAchievement
     */
    select?: EducationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationAchievement
     */
    omit?: EducationAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a EducationAchievement.
     */
    data: XOR<EducationAchievementUpdateInput, EducationAchievementUncheckedUpdateInput>
    /**
     * Choose, which EducationAchievement to update.
     */
    where: EducationAchievementWhereUniqueInput
  }

  /**
   * EducationAchievement updateMany
   */
  export type EducationAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EducationAchievements.
     */
    data: XOR<EducationAchievementUpdateManyMutationInput, EducationAchievementUncheckedUpdateManyInput>
    /**
     * Filter which EducationAchievements to update
     */
    where?: EducationAchievementWhereInput
    /**
     * Limit how many EducationAchievements to update.
     */
    limit?: number
  }

  /**
   * EducationAchievement updateManyAndReturn
   */
  export type EducationAchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationAchievement
     */
    select?: EducationAchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EducationAchievement
     */
    omit?: EducationAchievementOmit<ExtArgs> | null
    /**
     * The data used to update EducationAchievements.
     */
    data: XOR<EducationAchievementUpdateManyMutationInput, EducationAchievementUncheckedUpdateManyInput>
    /**
     * Filter which EducationAchievements to update
     */
    where?: EducationAchievementWhereInput
    /**
     * Limit how many EducationAchievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationAchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EducationAchievement upsert
   */
  export type EducationAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationAchievement
     */
    select?: EducationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationAchievement
     */
    omit?: EducationAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the EducationAchievement to update in case it exists.
     */
    where: EducationAchievementWhereUniqueInput
    /**
     * In case the EducationAchievement found by the `where` argument doesn't exist, create a new EducationAchievement with this data.
     */
    create: XOR<EducationAchievementCreateInput, EducationAchievementUncheckedCreateInput>
    /**
     * In case the EducationAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationAchievementUpdateInput, EducationAchievementUncheckedUpdateInput>
  }

  /**
   * EducationAchievement delete
   */
  export type EducationAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationAchievement
     */
    select?: EducationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationAchievement
     */
    omit?: EducationAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationAchievementInclude<ExtArgs> | null
    /**
     * Filter which EducationAchievement to delete.
     */
    where: EducationAchievementWhereUniqueInput
  }

  /**
   * EducationAchievement deleteMany
   */
  export type EducationAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationAchievements to delete
     */
    where?: EducationAchievementWhereInput
    /**
     * Limit how many EducationAchievements to delete.
     */
    limit?: number
  }

  /**
   * EducationAchievement without action
   */
  export type EducationAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationAchievement
     */
    select?: EducationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationAchievement
     */
    omit?: EducationAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationAchievementInclude<ExtArgs> | null
  }


  /**
   * Model Certification
   */

  export type AggregateCertification = {
    _count: CertificationCountAggregateOutputType | null
    _min: CertificationMinAggregateOutputType | null
    _max: CertificationMaxAggregateOutputType | null
  }

  export type CertificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    issuer: string | null
    date: Date | null
    icon: string | null
    credentialId: string | null
    expiry: Date | null
    description: string | null
    verificationUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    issuer: string | null
    date: Date | null
    icon: string | null
    credentialId: string | null
    expiry: Date | null
    description: string | null
    verificationUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificationCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    issuer: number
    date: number
    icon: number
    credentialId: number
    expiry: number
    description: number
    verificationUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CertificationMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    issuer?: true
    date?: true
    icon?: true
    credentialId?: true
    expiry?: true
    description?: true
    verificationUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificationMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    issuer?: true
    date?: true
    icon?: true
    credentialId?: true
    expiry?: true
    description?: true
    verificationUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificationCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    issuer?: true
    date?: true
    icon?: true
    credentialId?: true
    expiry?: true
    description?: true
    verificationUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CertificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certification to aggregate.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certifications
    **/
    _count?: true | CertificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificationMaxAggregateInputType
  }

  export type GetCertificationAggregateType<T extends CertificationAggregateArgs> = {
        [P in keyof T & keyof AggregateCertification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertification[P]>
      : GetScalarType<T[P], AggregateCertification[P]>
  }




  export type CertificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithAggregationInput | CertificationOrderByWithAggregationInput[]
    by: CertificationScalarFieldEnum[] | CertificationScalarFieldEnum
    having?: CertificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificationCountAggregateInputType | true
    _min?: CertificationMinAggregateInputType
    _max?: CertificationMaxAggregateInputType
  }

  export type CertificationGroupByOutputType = {
    id: string
    userId: string
    name: string
    issuer: string
    date: Date
    icon: string | null
    credentialId: string | null
    expiry: Date | null
    description: string | null
    verificationUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: CertificationCountAggregateOutputType | null
    _min: CertificationMinAggregateOutputType | null
    _max: CertificationMaxAggregateOutputType | null
  }

  type GetCertificationGroupByPayload<T extends CertificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificationGroupByOutputType[P]>
            : GetScalarType<T[P], CertificationGroupByOutputType[P]>
        }
      >
    >


  export type CertificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    issuer?: boolean
    date?: boolean
    icon?: boolean
    credentialId?: boolean
    expiry?: boolean
    description?: boolean
    verificationUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skills?: boolean | Certification$skillsArgs<ExtArgs>
    _count?: boolean | CertificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certification"]>

  export type CertificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    issuer?: boolean
    date?: boolean
    icon?: boolean
    credentialId?: boolean
    expiry?: boolean
    description?: boolean
    verificationUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certification"]>

  export type CertificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    issuer?: boolean
    date?: boolean
    icon?: boolean
    credentialId?: boolean
    expiry?: boolean
    description?: boolean
    verificationUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certification"]>

  export type CertificationSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    issuer?: boolean
    date?: boolean
    icon?: boolean
    credentialId?: boolean
    expiry?: boolean
    description?: boolean
    verificationUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CertificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "issuer" | "date" | "icon" | "credentialId" | "expiry" | "description" | "verificationUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["certification"]>
  export type CertificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skills?: boolean | Certification$skillsArgs<ExtArgs>
    _count?: boolean | CertificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CertificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CertificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CertificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      skills: Prisma.$CertificationSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      issuer: string
      date: Date
      icon: string | null
      credentialId: string | null
      expiry: Date | null
      description: string | null
      verificationUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["certification"]>
    composites: {}
  }

  type CertificationGetPayload<S extends boolean | null | undefined | CertificationDefaultArgs> = $Result.GetResult<Prisma.$CertificationPayload, S>

  type CertificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CertificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificationCountAggregateInputType | true
    }

  export interface CertificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certification'], meta: { name: 'Certification' } }
    /**
     * Find zero or one Certification that matches the filter.
     * @param {CertificationFindUniqueArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificationFindUniqueArgs>(args: SelectSubset<T, CertificationFindUniqueArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Certification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificationFindUniqueOrThrowArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificationFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindFirstArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificationFindFirstArgs>(args?: SelectSubset<T, CertificationFindFirstArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindFirstOrThrowArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificationFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Certifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certifications
     * const certifications = await prisma.certification.findMany()
     * 
     * // Get first 10 Certifications
     * const certifications = await prisma.certification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificationWithIdOnly = await prisma.certification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificationFindManyArgs>(args?: SelectSubset<T, CertificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Certification.
     * @param {CertificationCreateArgs} args - Arguments to create a Certification.
     * @example
     * // Create one Certification
     * const Certification = await prisma.certification.create({
     *   data: {
     *     // ... data to create a Certification
     *   }
     * })
     * 
     */
    create<T extends CertificationCreateArgs>(args: SelectSubset<T, CertificationCreateArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Certifications.
     * @param {CertificationCreateManyArgs} args - Arguments to create many Certifications.
     * @example
     * // Create many Certifications
     * const certification = await prisma.certification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificationCreateManyArgs>(args?: SelectSubset<T, CertificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certifications and returns the data saved in the database.
     * @param {CertificationCreateManyAndReturnArgs} args - Arguments to create many Certifications.
     * @example
     * // Create many Certifications
     * const certification = await prisma.certification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certifications and only return the `id`
     * const certificationWithIdOnly = await prisma.certification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificationCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Certification.
     * @param {CertificationDeleteArgs} args - Arguments to delete one Certification.
     * @example
     * // Delete one Certification
     * const Certification = await prisma.certification.delete({
     *   where: {
     *     // ... filter to delete one Certification
     *   }
     * })
     * 
     */
    delete<T extends CertificationDeleteArgs>(args: SelectSubset<T, CertificationDeleteArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Certification.
     * @param {CertificationUpdateArgs} args - Arguments to update one Certification.
     * @example
     * // Update one Certification
     * const certification = await prisma.certification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificationUpdateArgs>(args: SelectSubset<T, CertificationUpdateArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Certifications.
     * @param {CertificationDeleteManyArgs} args - Arguments to filter Certifications to delete.
     * @example
     * // Delete a few Certifications
     * const { count } = await prisma.certification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificationDeleteManyArgs>(args?: SelectSubset<T, CertificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certifications
     * const certification = await prisma.certification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificationUpdateManyArgs>(args: SelectSubset<T, CertificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certifications and returns the data updated in the database.
     * @param {CertificationUpdateManyAndReturnArgs} args - Arguments to update many Certifications.
     * @example
     * // Update many Certifications
     * const certification = await prisma.certification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Certifications and only return the `id`
     * const certificationWithIdOnly = await prisma.certification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CertificationUpdateManyAndReturnArgs>(args: SelectSubset<T, CertificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Certification.
     * @param {CertificationUpsertArgs} args - Arguments to update or create a Certification.
     * @example
     * // Update or create a Certification
     * const certification = await prisma.certification.upsert({
     *   create: {
     *     // ... data to create a Certification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certification we want to update
     *   }
     * })
     */
    upsert<T extends CertificationUpsertArgs>(args: SelectSubset<T, CertificationUpsertArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationCountArgs} args - Arguments to filter Certifications to count.
     * @example
     * // Count the number of Certifications
     * const count = await prisma.certification.count({
     *   where: {
     *     // ... the filter for the Certifications we want to count
     *   }
     * })
    **/
    count<T extends CertificationCountArgs>(
      args?: Subset<T, CertificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificationAggregateArgs>(args: Subset<T, CertificationAggregateArgs>): Prisma.PrismaPromise<GetCertificationAggregateType<T>>

    /**
     * Group by Certification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificationGroupByArgs['orderBy'] }
        : { orderBy?: CertificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certification model
   */
  readonly fields: CertificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skills<T extends Certification$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Certification$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certification model
   */
  interface CertificationFieldRefs {
    readonly id: FieldRef<"Certification", 'String'>
    readonly userId: FieldRef<"Certification", 'String'>
    readonly name: FieldRef<"Certification", 'String'>
    readonly issuer: FieldRef<"Certification", 'String'>
    readonly date: FieldRef<"Certification", 'DateTime'>
    readonly icon: FieldRef<"Certification", 'String'>
    readonly credentialId: FieldRef<"Certification", 'String'>
    readonly expiry: FieldRef<"Certification", 'DateTime'>
    readonly description: FieldRef<"Certification", 'String'>
    readonly verificationUrl: FieldRef<"Certification", 'String'>
    readonly createdAt: FieldRef<"Certification", 'DateTime'>
    readonly updatedAt: FieldRef<"Certification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certification findUnique
   */
  export type CertificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification findUniqueOrThrow
   */
  export type CertificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification findFirst
   */
  export type CertificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification findFirstOrThrow
   */
  export type CertificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification findMany
   */
  export type CertificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certifications to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification create
   */
  export type CertificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Certification.
     */
    data: XOR<CertificationCreateInput, CertificationUncheckedCreateInput>
  }

  /**
   * Certification createMany
   */
  export type CertificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certifications.
     */
    data: CertificationCreateManyInput | CertificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certification createManyAndReturn
   */
  export type CertificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * The data used to create many Certifications.
     */
    data: CertificationCreateManyInput | CertificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certification update
   */
  export type CertificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Certification.
     */
    data: XOR<CertificationUpdateInput, CertificationUncheckedUpdateInput>
    /**
     * Choose, which Certification to update.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification updateMany
   */
  export type CertificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certifications.
     */
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyInput>
    /**
     * Filter which Certifications to update
     */
    where?: CertificationWhereInput
    /**
     * Limit how many Certifications to update.
     */
    limit?: number
  }

  /**
   * Certification updateManyAndReturn
   */
  export type CertificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * The data used to update Certifications.
     */
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyInput>
    /**
     * Filter which Certifications to update
     */
    where?: CertificationWhereInput
    /**
     * Limit how many Certifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certification upsert
   */
  export type CertificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Certification to update in case it exists.
     */
    where: CertificationWhereUniqueInput
    /**
     * In case the Certification found by the `where` argument doesn't exist, create a new Certification with this data.
     */
    create: XOR<CertificationCreateInput, CertificationUncheckedCreateInput>
    /**
     * In case the Certification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificationUpdateInput, CertificationUncheckedUpdateInput>
  }

  /**
   * Certification delete
   */
  export type CertificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter which Certification to delete.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification deleteMany
   */
  export type CertificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certifications to delete
     */
    where?: CertificationWhereInput
    /**
     * Limit how many Certifications to delete.
     */
    limit?: number
  }

  /**
   * Certification.skills
   */
  export type Certification$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationSkill
     */
    select?: CertificationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationSkill
     */
    omit?: CertificationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationSkillInclude<ExtArgs> | null
    where?: CertificationSkillWhereInput
    orderBy?: CertificationSkillOrderByWithRelationInput | CertificationSkillOrderByWithRelationInput[]
    cursor?: CertificationSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificationSkillScalarFieldEnum | CertificationSkillScalarFieldEnum[]
  }

  /**
   * Certification without action
   */
  export type CertificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
  }


  /**
   * Model CertificationSkill
   */

  export type AggregateCertificationSkill = {
    _count: CertificationSkillCountAggregateOutputType | null
    _min: CertificationSkillMinAggregateOutputType | null
    _max: CertificationSkillMaxAggregateOutputType | null
  }

  export type CertificationSkillMinAggregateOutputType = {
    id: string | null
    certificationId: string | null
    skill: string | null
  }

  export type CertificationSkillMaxAggregateOutputType = {
    id: string | null
    certificationId: string | null
    skill: string | null
  }

  export type CertificationSkillCountAggregateOutputType = {
    id: number
    certificationId: number
    skill: number
    _all: number
  }


  export type CertificationSkillMinAggregateInputType = {
    id?: true
    certificationId?: true
    skill?: true
  }

  export type CertificationSkillMaxAggregateInputType = {
    id?: true
    certificationId?: true
    skill?: true
  }

  export type CertificationSkillCountAggregateInputType = {
    id?: true
    certificationId?: true
    skill?: true
    _all?: true
  }

  export type CertificationSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CertificationSkill to aggregate.
     */
    where?: CertificationSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificationSkills to fetch.
     */
    orderBy?: CertificationSkillOrderByWithRelationInput | CertificationSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificationSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificationSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificationSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CertificationSkills
    **/
    _count?: true | CertificationSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificationSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificationSkillMaxAggregateInputType
  }

  export type GetCertificationSkillAggregateType<T extends CertificationSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificationSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificationSkill[P]>
      : GetScalarType<T[P], AggregateCertificationSkill[P]>
  }




  export type CertificationSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationSkillWhereInput
    orderBy?: CertificationSkillOrderByWithAggregationInput | CertificationSkillOrderByWithAggregationInput[]
    by: CertificationSkillScalarFieldEnum[] | CertificationSkillScalarFieldEnum
    having?: CertificationSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificationSkillCountAggregateInputType | true
    _min?: CertificationSkillMinAggregateInputType
    _max?: CertificationSkillMaxAggregateInputType
  }

  export type CertificationSkillGroupByOutputType = {
    id: string
    certificationId: string
    skill: string
    _count: CertificationSkillCountAggregateOutputType | null
    _min: CertificationSkillMinAggregateOutputType | null
    _max: CertificationSkillMaxAggregateOutputType | null
  }

  type GetCertificationSkillGroupByPayload<T extends CertificationSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificationSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificationSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificationSkillGroupByOutputType[P]>
            : GetScalarType<T[P], CertificationSkillGroupByOutputType[P]>
        }
      >
    >


  export type CertificationSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    certificationId?: boolean
    skill?: boolean
    certification?: boolean | CertificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificationSkill"]>

  export type CertificationSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    certificationId?: boolean
    skill?: boolean
    certification?: boolean | CertificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificationSkill"]>

  export type CertificationSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    certificationId?: boolean
    skill?: boolean
    certification?: boolean | CertificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificationSkill"]>

  export type CertificationSkillSelectScalar = {
    id?: boolean
    certificationId?: boolean
    skill?: boolean
  }

  export type CertificationSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "certificationId" | "skill", ExtArgs["result"]["certificationSkill"]>
  export type CertificationSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certification?: boolean | CertificationDefaultArgs<ExtArgs>
  }
  export type CertificationSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certification?: boolean | CertificationDefaultArgs<ExtArgs>
  }
  export type CertificationSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certification?: boolean | CertificationDefaultArgs<ExtArgs>
  }

  export type $CertificationSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CertificationSkill"
    objects: {
      certification: Prisma.$CertificationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      certificationId: string
      skill: string
    }, ExtArgs["result"]["certificationSkill"]>
    composites: {}
  }

  type CertificationSkillGetPayload<S extends boolean | null | undefined | CertificationSkillDefaultArgs> = $Result.GetResult<Prisma.$CertificationSkillPayload, S>

  type CertificationSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CertificationSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificationSkillCountAggregateInputType | true
    }

  export interface CertificationSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CertificationSkill'], meta: { name: 'CertificationSkill' } }
    /**
     * Find zero or one CertificationSkill that matches the filter.
     * @param {CertificationSkillFindUniqueArgs} args - Arguments to find a CertificationSkill
     * @example
     * // Get one CertificationSkill
     * const certificationSkill = await prisma.certificationSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificationSkillFindUniqueArgs>(args: SelectSubset<T, CertificationSkillFindUniqueArgs<ExtArgs>>): Prisma__CertificationSkillClient<$Result.GetResult<Prisma.$CertificationSkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CertificationSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificationSkillFindUniqueOrThrowArgs} args - Arguments to find a CertificationSkill
     * @example
     * // Get one CertificationSkill
     * const certificationSkill = await prisma.certificationSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificationSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificationSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificationSkillClient<$Result.GetResult<Prisma.$CertificationSkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CertificationSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationSkillFindFirstArgs} args - Arguments to find a CertificationSkill
     * @example
     * // Get one CertificationSkill
     * const certificationSkill = await prisma.certificationSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificationSkillFindFirstArgs>(args?: SelectSubset<T, CertificationSkillFindFirstArgs<ExtArgs>>): Prisma__CertificationSkillClient<$Result.GetResult<Prisma.$CertificationSkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CertificationSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationSkillFindFirstOrThrowArgs} args - Arguments to find a CertificationSkill
     * @example
     * // Get one CertificationSkill
     * const certificationSkill = await prisma.certificationSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificationSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificationSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificationSkillClient<$Result.GetResult<Prisma.$CertificationSkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CertificationSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CertificationSkills
     * const certificationSkills = await prisma.certificationSkill.findMany()
     * 
     * // Get first 10 CertificationSkills
     * const certificationSkills = await prisma.certificationSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificationSkillWithIdOnly = await prisma.certificationSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificationSkillFindManyArgs>(args?: SelectSubset<T, CertificationSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CertificationSkill.
     * @param {CertificationSkillCreateArgs} args - Arguments to create a CertificationSkill.
     * @example
     * // Create one CertificationSkill
     * const CertificationSkill = await prisma.certificationSkill.create({
     *   data: {
     *     // ... data to create a CertificationSkill
     *   }
     * })
     * 
     */
    create<T extends CertificationSkillCreateArgs>(args: SelectSubset<T, CertificationSkillCreateArgs<ExtArgs>>): Prisma__CertificationSkillClient<$Result.GetResult<Prisma.$CertificationSkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CertificationSkills.
     * @param {CertificationSkillCreateManyArgs} args - Arguments to create many CertificationSkills.
     * @example
     * // Create many CertificationSkills
     * const certificationSkill = await prisma.certificationSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificationSkillCreateManyArgs>(args?: SelectSubset<T, CertificationSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CertificationSkills and returns the data saved in the database.
     * @param {CertificationSkillCreateManyAndReturnArgs} args - Arguments to create many CertificationSkills.
     * @example
     * // Create many CertificationSkills
     * const certificationSkill = await prisma.certificationSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CertificationSkills and only return the `id`
     * const certificationSkillWithIdOnly = await prisma.certificationSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificationSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificationSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationSkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CertificationSkill.
     * @param {CertificationSkillDeleteArgs} args - Arguments to delete one CertificationSkill.
     * @example
     * // Delete one CertificationSkill
     * const CertificationSkill = await prisma.certificationSkill.delete({
     *   where: {
     *     // ... filter to delete one CertificationSkill
     *   }
     * })
     * 
     */
    delete<T extends CertificationSkillDeleteArgs>(args: SelectSubset<T, CertificationSkillDeleteArgs<ExtArgs>>): Prisma__CertificationSkillClient<$Result.GetResult<Prisma.$CertificationSkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CertificationSkill.
     * @param {CertificationSkillUpdateArgs} args - Arguments to update one CertificationSkill.
     * @example
     * // Update one CertificationSkill
     * const certificationSkill = await prisma.certificationSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificationSkillUpdateArgs>(args: SelectSubset<T, CertificationSkillUpdateArgs<ExtArgs>>): Prisma__CertificationSkillClient<$Result.GetResult<Prisma.$CertificationSkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CertificationSkills.
     * @param {CertificationSkillDeleteManyArgs} args - Arguments to filter CertificationSkills to delete.
     * @example
     * // Delete a few CertificationSkills
     * const { count } = await prisma.certificationSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificationSkillDeleteManyArgs>(args?: SelectSubset<T, CertificationSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CertificationSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CertificationSkills
     * const certificationSkill = await prisma.certificationSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificationSkillUpdateManyArgs>(args: SelectSubset<T, CertificationSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CertificationSkills and returns the data updated in the database.
     * @param {CertificationSkillUpdateManyAndReturnArgs} args - Arguments to update many CertificationSkills.
     * @example
     * // Update many CertificationSkills
     * const certificationSkill = await prisma.certificationSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CertificationSkills and only return the `id`
     * const certificationSkillWithIdOnly = await prisma.certificationSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CertificationSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, CertificationSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationSkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CertificationSkill.
     * @param {CertificationSkillUpsertArgs} args - Arguments to update or create a CertificationSkill.
     * @example
     * // Update or create a CertificationSkill
     * const certificationSkill = await prisma.certificationSkill.upsert({
     *   create: {
     *     // ... data to create a CertificationSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CertificationSkill we want to update
     *   }
     * })
     */
    upsert<T extends CertificationSkillUpsertArgs>(args: SelectSubset<T, CertificationSkillUpsertArgs<ExtArgs>>): Prisma__CertificationSkillClient<$Result.GetResult<Prisma.$CertificationSkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CertificationSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationSkillCountArgs} args - Arguments to filter CertificationSkills to count.
     * @example
     * // Count the number of CertificationSkills
     * const count = await prisma.certificationSkill.count({
     *   where: {
     *     // ... the filter for the CertificationSkills we want to count
     *   }
     * })
    **/
    count<T extends CertificationSkillCountArgs>(
      args?: Subset<T, CertificationSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificationSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CertificationSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificationSkillAggregateArgs>(args: Subset<T, CertificationSkillAggregateArgs>): Prisma.PrismaPromise<GetCertificationSkillAggregateType<T>>

    /**
     * Group by CertificationSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificationSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificationSkillGroupByArgs['orderBy'] }
        : { orderBy?: CertificationSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificationSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificationSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CertificationSkill model
   */
  readonly fields: CertificationSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CertificationSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificationSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    certification<T extends CertificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CertificationDefaultArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CertificationSkill model
   */
  interface CertificationSkillFieldRefs {
    readonly id: FieldRef<"CertificationSkill", 'String'>
    readonly certificationId: FieldRef<"CertificationSkill", 'String'>
    readonly skill: FieldRef<"CertificationSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CertificationSkill findUnique
   */
  export type CertificationSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationSkill
     */
    select?: CertificationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationSkill
     */
    omit?: CertificationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationSkillInclude<ExtArgs> | null
    /**
     * Filter, which CertificationSkill to fetch.
     */
    where: CertificationSkillWhereUniqueInput
  }

  /**
   * CertificationSkill findUniqueOrThrow
   */
  export type CertificationSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationSkill
     */
    select?: CertificationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationSkill
     */
    omit?: CertificationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationSkillInclude<ExtArgs> | null
    /**
     * Filter, which CertificationSkill to fetch.
     */
    where: CertificationSkillWhereUniqueInput
  }

  /**
   * CertificationSkill findFirst
   */
  export type CertificationSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationSkill
     */
    select?: CertificationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationSkill
     */
    omit?: CertificationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationSkillInclude<ExtArgs> | null
    /**
     * Filter, which CertificationSkill to fetch.
     */
    where?: CertificationSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificationSkills to fetch.
     */
    orderBy?: CertificationSkillOrderByWithRelationInput | CertificationSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CertificationSkills.
     */
    cursor?: CertificationSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificationSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificationSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CertificationSkills.
     */
    distinct?: CertificationSkillScalarFieldEnum | CertificationSkillScalarFieldEnum[]
  }

  /**
   * CertificationSkill findFirstOrThrow
   */
  export type CertificationSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationSkill
     */
    select?: CertificationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationSkill
     */
    omit?: CertificationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationSkillInclude<ExtArgs> | null
    /**
     * Filter, which CertificationSkill to fetch.
     */
    where?: CertificationSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificationSkills to fetch.
     */
    orderBy?: CertificationSkillOrderByWithRelationInput | CertificationSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CertificationSkills.
     */
    cursor?: CertificationSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificationSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificationSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CertificationSkills.
     */
    distinct?: CertificationSkillScalarFieldEnum | CertificationSkillScalarFieldEnum[]
  }

  /**
   * CertificationSkill findMany
   */
  export type CertificationSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationSkill
     */
    select?: CertificationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationSkill
     */
    omit?: CertificationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationSkillInclude<ExtArgs> | null
    /**
     * Filter, which CertificationSkills to fetch.
     */
    where?: CertificationSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificationSkills to fetch.
     */
    orderBy?: CertificationSkillOrderByWithRelationInput | CertificationSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CertificationSkills.
     */
    cursor?: CertificationSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificationSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificationSkills.
     */
    skip?: number
    distinct?: CertificationSkillScalarFieldEnum | CertificationSkillScalarFieldEnum[]
  }

  /**
   * CertificationSkill create
   */
  export type CertificationSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationSkill
     */
    select?: CertificationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationSkill
     */
    omit?: CertificationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a CertificationSkill.
     */
    data: XOR<CertificationSkillCreateInput, CertificationSkillUncheckedCreateInput>
  }

  /**
   * CertificationSkill createMany
   */
  export type CertificationSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CertificationSkills.
     */
    data: CertificationSkillCreateManyInput | CertificationSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CertificationSkill createManyAndReturn
   */
  export type CertificationSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationSkill
     */
    select?: CertificationSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationSkill
     */
    omit?: CertificationSkillOmit<ExtArgs> | null
    /**
     * The data used to create many CertificationSkills.
     */
    data: CertificationSkillCreateManyInput | CertificationSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CertificationSkill update
   */
  export type CertificationSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationSkill
     */
    select?: CertificationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationSkill
     */
    omit?: CertificationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a CertificationSkill.
     */
    data: XOR<CertificationSkillUpdateInput, CertificationSkillUncheckedUpdateInput>
    /**
     * Choose, which CertificationSkill to update.
     */
    where: CertificationSkillWhereUniqueInput
  }

  /**
   * CertificationSkill updateMany
   */
  export type CertificationSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CertificationSkills.
     */
    data: XOR<CertificationSkillUpdateManyMutationInput, CertificationSkillUncheckedUpdateManyInput>
    /**
     * Filter which CertificationSkills to update
     */
    where?: CertificationSkillWhereInput
    /**
     * Limit how many CertificationSkills to update.
     */
    limit?: number
  }

  /**
   * CertificationSkill updateManyAndReturn
   */
  export type CertificationSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationSkill
     */
    select?: CertificationSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationSkill
     */
    omit?: CertificationSkillOmit<ExtArgs> | null
    /**
     * The data used to update CertificationSkills.
     */
    data: XOR<CertificationSkillUpdateManyMutationInput, CertificationSkillUncheckedUpdateManyInput>
    /**
     * Filter which CertificationSkills to update
     */
    where?: CertificationSkillWhereInput
    /**
     * Limit how many CertificationSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CertificationSkill upsert
   */
  export type CertificationSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationSkill
     */
    select?: CertificationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationSkill
     */
    omit?: CertificationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the CertificationSkill to update in case it exists.
     */
    where: CertificationSkillWhereUniqueInput
    /**
     * In case the CertificationSkill found by the `where` argument doesn't exist, create a new CertificationSkill with this data.
     */
    create: XOR<CertificationSkillCreateInput, CertificationSkillUncheckedCreateInput>
    /**
     * In case the CertificationSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificationSkillUpdateInput, CertificationSkillUncheckedUpdateInput>
  }

  /**
   * CertificationSkill delete
   */
  export type CertificationSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationSkill
     */
    select?: CertificationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationSkill
     */
    omit?: CertificationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationSkillInclude<ExtArgs> | null
    /**
     * Filter which CertificationSkill to delete.
     */
    where: CertificationSkillWhereUniqueInput
  }

  /**
   * CertificationSkill deleteMany
   */
  export type CertificationSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CertificationSkills to delete
     */
    where?: CertificationSkillWhereInput
    /**
     * Limit how many CertificationSkills to delete.
     */
    limit?: number
  }

  /**
   * CertificationSkill without action
   */
  export type CertificationSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationSkill
     */
    select?: CertificationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationSkill
     */
    omit?: CertificationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationSkillInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    date: Date | null
    description: string | null
    icon: string | null
    category: string | null
    issuer: string | null
    link: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    date: Date | null
    description: string | null
    icon: string | null
    category: string | null
    issuer: string | null
    link: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    date: number
    description: number
    icon: number
    category: number
    issuer: number
    link: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AchievementMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    date?: true
    description?: true
    icon?: true
    category?: true
    issuer?: true
    link?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    date?: true
    description?: true
    icon?: true
    category?: true
    issuer?: true
    link?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    date?: true
    description?: true
    icon?: true
    category?: true
    issuer?: true
    link?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    userId: string
    title: string
    date: Date
    description: string | null
    icon: string | null
    category: string | null
    issuer: string | null
    link: string | null
    createdAt: Date
    updatedAt: Date
    _count: AchievementCountAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    date?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    issuer?: boolean
    link?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    date?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    issuer?: boolean
    link?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    date?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    issuer?: boolean
    link?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    date?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    issuer?: boolean
    link?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "date" | "description" | "icon" | "category" | "issuer" | "link" | "createdAt" | "updatedAt", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      date: Date
      description: string | null
      icon: string | null
      category: string | null
      issuer: string | null
      link: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {AchievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly userId: FieldRef<"Achievement", 'String'>
    readonly title: FieldRef<"Achievement", 'String'>
    readonly date: FieldRef<"Achievement", 'DateTime'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly icon: FieldRef<"Achievement", 'String'>
    readonly category: FieldRef<"Achievement", 'String'>
    readonly issuer: FieldRef<"Achievement", 'String'>
    readonly link: FieldRef<"Achievement", 'String'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
    readonly updatedAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement updateManyAndReturn
   */
  export type AchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostAvgAggregateOutputType = {
    readTime: number | null
    likes: number | null
    comments: number | null
    shares: number | null
    views: number | null
  }

  export type BlogPostSumAggregateOutputType = {
    readTime: number | null
    likes: number | null
    comments: number | null
    shares: number | null
    views: number | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: string | null
    userId: string | null
    slug: string | null
    title: string | null
    excerpt: string | null
    content: string | null
    date: Date | null
    readTime: number | null
    image: string | null
    likes: number | null
    comments: number | null
    shares: number | null
    views: number | null
    category: string | null
    author: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    slug: string | null
    title: string | null
    excerpt: string | null
    content: string | null
    date: Date | null
    readTime: number | null
    image: string | null
    likes: number | null
    comments: number | null
    shares: number | null
    views: number | null
    category: string | null
    author: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    userId: number
    slug: number
    title: number
    excerpt: number
    content: number
    date: number
    readTime: number
    image: number
    likes: number
    comments: number
    shares: number
    views: number
    category: number
    author: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogPostAvgAggregateInputType = {
    readTime?: true
    likes?: true
    comments?: true
    shares?: true
    views?: true
  }

  export type BlogPostSumAggregateInputType = {
    readTime?: true
    likes?: true
    comments?: true
    shares?: true
    views?: true
  }

  export type BlogPostMinAggregateInputType = {
    id?: true
    userId?: true
    slug?: true
    title?: true
    excerpt?: true
    content?: true
    date?: true
    readTime?: true
    image?: true
    likes?: true
    comments?: true
    shares?: true
    views?: true
    category?: true
    author?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    userId?: true
    slug?: true
    title?: true
    excerpt?: true
    content?: true
    date?: true
    readTime?: true
    image?: true
    likes?: true
    comments?: true
    shares?: true
    views?: true
    category?: true
    author?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    userId?: true
    slug?: true
    title?: true
    excerpt?: true
    content?: true
    date?: true
    readTime?: true
    image?: true
    likes?: true
    comments?: true
    shares?: true
    views?: true
    category?: true
    author?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _avg?: BlogPostAvgAggregateInputType
    _sum?: BlogPostSumAggregateInputType
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: string
    userId: string
    slug: string
    title: string
    excerpt: string
    content: string
    date: Date
    readTime: number
    image: string | null
    likes: number
    comments: number
    shares: number
    views: number
    category: string
    author: string
    createdAt: Date
    updatedAt: Date
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    slug?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    date?: boolean
    readTime?: boolean
    image?: boolean
    likes?: boolean
    comments?: boolean
    shares?: boolean
    views?: boolean
    category?: boolean
    author?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tags?: boolean | BlogPost$tagsArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    slug?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    date?: boolean
    readTime?: boolean
    image?: boolean
    likes?: boolean
    comments?: boolean
    shares?: boolean
    views?: boolean
    category?: boolean
    author?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    slug?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    date?: boolean
    readTime?: boolean
    image?: boolean
    likes?: boolean
    comments?: boolean
    shares?: boolean
    views?: boolean
    category?: boolean
    author?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    userId?: boolean
    slug?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    date?: boolean
    readTime?: boolean
    image?: boolean
    likes?: boolean
    comments?: boolean
    shares?: boolean
    views?: boolean
    category?: boolean
    author?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "slug" | "title" | "excerpt" | "content" | "date" | "readTime" | "image" | "likes" | "comments" | "shares" | "views" | "category" | "author" | "createdAt" | "updatedAt", ExtArgs["result"]["blogPost"]>
  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tags?: boolean | BlogPost$tagsArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlogPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tags: Prisma.$BlogTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      slug: string
      title: string
      excerpt: string
      content: string
      date: Date
      readTime: number
      image: string | null
      likes: number
      comments: number
      shares: number
      views: number
      category: string
      author: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts and returns the data updated in the database.
     * @param {BlogPostUpdateManyAndReturnArgs} args - Arguments to update many BlogPosts.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogPostUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends BlogPost$tagsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'String'>
    readonly userId: FieldRef<"BlogPost", 'String'>
    readonly slug: FieldRef<"BlogPost", 'String'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly excerpt: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly date: FieldRef<"BlogPost", 'DateTime'>
    readonly readTime: FieldRef<"BlogPost", 'Int'>
    readonly image: FieldRef<"BlogPost", 'String'>
    readonly likes: FieldRef<"BlogPost", 'Int'>
    readonly comments: FieldRef<"BlogPost", 'Int'>
    readonly shares: FieldRef<"BlogPost", 'Int'>
    readonly views: FieldRef<"BlogPost", 'Int'>
    readonly category: FieldRef<"BlogPost", 'String'>
    readonly author: FieldRef<"BlogPost", 'String'>
    readonly createdAt: FieldRef<"BlogPost", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
  }

  /**
   * BlogPost updateManyAndReturn
   */
  export type BlogPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to delete.
     */
    limit?: number
  }

  /**
   * BlogPost.tags
   */
  export type BlogPost$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    where?: BlogTagWhereInput
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    cursor?: BlogTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model BlogTag
   */

  export type AggregateBlogTag = {
    _count: BlogTagCountAggregateOutputType | null
    _min: BlogTagMinAggregateOutputType | null
    _max: BlogTagMaxAggregateOutputType | null
  }

  export type BlogTagMinAggregateOutputType = {
    id: string | null
    blogId: string | null
    tag: string | null
  }

  export type BlogTagMaxAggregateOutputType = {
    id: string | null
    blogId: string | null
    tag: string | null
  }

  export type BlogTagCountAggregateOutputType = {
    id: number
    blogId: number
    tag: number
    _all: number
  }


  export type BlogTagMinAggregateInputType = {
    id?: true
    blogId?: true
    tag?: true
  }

  export type BlogTagMaxAggregateInputType = {
    id?: true
    blogId?: true
    tag?: true
  }

  export type BlogTagCountAggregateInputType = {
    id?: true
    blogId?: true
    tag?: true
    _all?: true
  }

  export type BlogTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogTag to aggregate.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogTags
    **/
    _count?: true | BlogTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogTagMaxAggregateInputType
  }

  export type GetBlogTagAggregateType<T extends BlogTagAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogTag[P]>
      : GetScalarType<T[P], AggregateBlogTag[P]>
  }




  export type BlogTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogTagWhereInput
    orderBy?: BlogTagOrderByWithAggregationInput | BlogTagOrderByWithAggregationInput[]
    by: BlogTagScalarFieldEnum[] | BlogTagScalarFieldEnum
    having?: BlogTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogTagCountAggregateInputType | true
    _min?: BlogTagMinAggregateInputType
    _max?: BlogTagMaxAggregateInputType
  }

  export type BlogTagGroupByOutputType = {
    id: string
    blogId: string
    tag: string
    _count: BlogTagCountAggregateOutputType | null
    _min: BlogTagMinAggregateOutputType | null
    _max: BlogTagMaxAggregateOutputType | null
  }

  type GetBlogTagGroupByPayload<T extends BlogTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogTagGroupByOutputType[P]>
            : GetScalarType<T[P], BlogTagGroupByOutputType[P]>
        }
      >
    >


  export type BlogTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blogId?: boolean
    tag?: boolean
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogTag"]>

  export type BlogTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blogId?: boolean
    tag?: boolean
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogTag"]>

  export type BlogTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blogId?: boolean
    tag?: boolean
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogTag"]>

  export type BlogTagSelectScalar = {
    id?: boolean
    blogId?: boolean
    tag?: boolean
  }

  export type BlogTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "blogId" | "tag", ExtArgs["result"]["blogTag"]>
  export type BlogTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type BlogTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type BlogTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }

  export type $BlogTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogTag"
    objects: {
      blogPost: Prisma.$BlogPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      blogId: string
      tag: string
    }, ExtArgs["result"]["blogTag"]>
    composites: {}
  }

  type BlogTagGetPayload<S extends boolean | null | undefined | BlogTagDefaultArgs> = $Result.GetResult<Prisma.$BlogTagPayload, S>

  type BlogTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogTagCountAggregateInputType | true
    }

  export interface BlogTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogTag'], meta: { name: 'BlogTag' } }
    /**
     * Find zero or one BlogTag that matches the filter.
     * @param {BlogTagFindUniqueArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogTagFindUniqueArgs>(args: SelectSubset<T, BlogTagFindUniqueArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogTagFindUniqueOrThrowArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogTagFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindFirstArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogTagFindFirstArgs>(args?: SelectSubset<T, BlogTagFindFirstArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindFirstOrThrowArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogTagFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogTags
     * const blogTags = await prisma.blogTag.findMany()
     * 
     * // Get first 10 BlogTags
     * const blogTags = await prisma.blogTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogTagWithIdOnly = await prisma.blogTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogTagFindManyArgs>(args?: SelectSubset<T, BlogTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogTag.
     * @param {BlogTagCreateArgs} args - Arguments to create a BlogTag.
     * @example
     * // Create one BlogTag
     * const BlogTag = await prisma.blogTag.create({
     *   data: {
     *     // ... data to create a BlogTag
     *   }
     * })
     * 
     */
    create<T extends BlogTagCreateArgs>(args: SelectSubset<T, BlogTagCreateArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogTags.
     * @param {BlogTagCreateManyArgs} args - Arguments to create many BlogTags.
     * @example
     * // Create many BlogTags
     * const blogTag = await prisma.blogTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogTagCreateManyArgs>(args?: SelectSubset<T, BlogTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogTags and returns the data saved in the database.
     * @param {BlogTagCreateManyAndReturnArgs} args - Arguments to create many BlogTags.
     * @example
     * // Create many BlogTags
     * const blogTag = await prisma.blogTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogTags and only return the `id`
     * const blogTagWithIdOnly = await prisma.blogTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogTagCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogTag.
     * @param {BlogTagDeleteArgs} args - Arguments to delete one BlogTag.
     * @example
     * // Delete one BlogTag
     * const BlogTag = await prisma.blogTag.delete({
     *   where: {
     *     // ... filter to delete one BlogTag
     *   }
     * })
     * 
     */
    delete<T extends BlogTagDeleteArgs>(args: SelectSubset<T, BlogTagDeleteArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogTag.
     * @param {BlogTagUpdateArgs} args - Arguments to update one BlogTag.
     * @example
     * // Update one BlogTag
     * const blogTag = await prisma.blogTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogTagUpdateArgs>(args: SelectSubset<T, BlogTagUpdateArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogTags.
     * @param {BlogTagDeleteManyArgs} args - Arguments to filter BlogTags to delete.
     * @example
     * // Delete a few BlogTags
     * const { count } = await prisma.blogTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogTagDeleteManyArgs>(args?: SelectSubset<T, BlogTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogTags
     * const blogTag = await prisma.blogTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogTagUpdateManyArgs>(args: SelectSubset<T, BlogTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogTags and returns the data updated in the database.
     * @param {BlogTagUpdateManyAndReturnArgs} args - Arguments to update many BlogTags.
     * @example
     * // Update many BlogTags
     * const blogTag = await prisma.blogTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogTags and only return the `id`
     * const blogTagWithIdOnly = await prisma.blogTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogTagUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogTag.
     * @param {BlogTagUpsertArgs} args - Arguments to update or create a BlogTag.
     * @example
     * // Update or create a BlogTag
     * const blogTag = await prisma.blogTag.upsert({
     *   create: {
     *     // ... data to create a BlogTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogTag we want to update
     *   }
     * })
     */
    upsert<T extends BlogTagUpsertArgs>(args: SelectSubset<T, BlogTagUpsertArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagCountArgs} args - Arguments to filter BlogTags to count.
     * @example
     * // Count the number of BlogTags
     * const count = await prisma.blogTag.count({
     *   where: {
     *     // ... the filter for the BlogTags we want to count
     *   }
     * })
    **/
    count<T extends BlogTagCountArgs>(
      args?: Subset<T, BlogTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogTagAggregateArgs>(args: Subset<T, BlogTagAggregateArgs>): Prisma.PrismaPromise<GetBlogTagAggregateType<T>>

    /**
     * Group by BlogTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogTagGroupByArgs['orderBy'] }
        : { orderBy?: BlogTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogTag model
   */
  readonly fields: BlogTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blogPost<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogTag model
   */
  interface BlogTagFieldRefs {
    readonly id: FieldRef<"BlogTag", 'String'>
    readonly blogId: FieldRef<"BlogTag", 'String'>
    readonly tag: FieldRef<"BlogTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BlogTag findUnique
   */
  export type BlogTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag findUniqueOrThrow
   */
  export type BlogTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag findFirst
   */
  export type BlogTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogTags.
     */
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag findFirstOrThrow
   */
  export type BlogTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogTags.
     */
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag findMany
   */
  export type BlogTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTags to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag create
   */
  export type BlogTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogTag.
     */
    data: XOR<BlogTagCreateInput, BlogTagUncheckedCreateInput>
  }

  /**
   * BlogTag createMany
   */
  export type BlogTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogTags.
     */
    data: BlogTagCreateManyInput | BlogTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogTag createManyAndReturn
   */
  export type BlogTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * The data used to create many BlogTags.
     */
    data: BlogTagCreateManyInput | BlogTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogTag update
   */
  export type BlogTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogTag.
     */
    data: XOR<BlogTagUpdateInput, BlogTagUncheckedUpdateInput>
    /**
     * Choose, which BlogTag to update.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag updateMany
   */
  export type BlogTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogTags.
     */
    data: XOR<BlogTagUpdateManyMutationInput, BlogTagUncheckedUpdateManyInput>
    /**
     * Filter which BlogTags to update
     */
    where?: BlogTagWhereInput
    /**
     * Limit how many BlogTags to update.
     */
    limit?: number
  }

  /**
   * BlogTag updateManyAndReturn
   */
  export type BlogTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * The data used to update BlogTags.
     */
    data: XOR<BlogTagUpdateManyMutationInput, BlogTagUncheckedUpdateManyInput>
    /**
     * Filter which BlogTags to update
     */
    where?: BlogTagWhereInput
    /**
     * Limit how many BlogTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogTag upsert
   */
  export type BlogTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogTag to update in case it exists.
     */
    where: BlogTagWhereUniqueInput
    /**
     * In case the BlogTag found by the `where` argument doesn't exist, create a new BlogTag with this data.
     */
    create: XOR<BlogTagCreateInput, BlogTagUncheckedCreateInput>
    /**
     * In case the BlogTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogTagUpdateInput, BlogTagUncheckedUpdateInput>
  }

  /**
   * BlogTag delete
   */
  export type BlogTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter which BlogTag to delete.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag deleteMany
   */
  export type BlogTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogTags to delete
     */
    where?: BlogTagWhereInput
    /**
     * Limit how many BlogTags to delete.
     */
    limit?: number
  }

  /**
   * BlogTag without action
   */
  export type BlogTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
  }


  /**
   * Model Testimonial
   */

  export type AggregateTestimonial = {
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  export type TestimonialAvgAggregateOutputType = {
    rating: number | null
  }

  export type TestimonialSumAggregateOutputType = {
    rating: number | null
  }

  export type TestimonialMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    position: string | null
    company: string | null
    text: string | null
    avatar: string | null
    rating: number | null
    date: Date | null
    relation: string | null
    projectLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestimonialMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    position: string | null
    company: string | null
    text: string | null
    avatar: string | null
    rating: number | null
    date: Date | null
    relation: string | null
    projectLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestimonialCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    position: number
    company: number
    text: number
    avatar: number
    rating: number
    date: number
    relation: number
    projectLink: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestimonialAvgAggregateInputType = {
    rating?: true
  }

  export type TestimonialSumAggregateInputType = {
    rating?: true
  }

  export type TestimonialMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    position?: true
    company?: true
    text?: true
    avatar?: true
    rating?: true
    date?: true
    relation?: true
    projectLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestimonialMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    position?: true
    company?: true
    text?: true
    avatar?: true
    rating?: true
    date?: true
    relation?: true
    projectLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestimonialCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    position?: true
    company?: true
    text?: true
    avatar?: true
    rating?: true
    date?: true
    relation?: true
    projectLink?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestimonialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonial to aggregate.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Testimonials
    **/
    _count?: true | TestimonialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestimonialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestimonialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialMaxAggregateInputType
  }

  export type GetTestimonialAggregateType<T extends TestimonialAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonial[P]>
      : GetScalarType<T[P], AggregateTestimonial[P]>
  }




  export type TestimonialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithAggregationInput | TestimonialOrderByWithAggregationInput[]
    by: TestimonialScalarFieldEnum[] | TestimonialScalarFieldEnum
    having?: TestimonialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialCountAggregateInputType | true
    _avg?: TestimonialAvgAggregateInputType
    _sum?: TestimonialSumAggregateInputType
    _min?: TestimonialMinAggregateInputType
    _max?: TestimonialMaxAggregateInputType
  }

  export type TestimonialGroupByOutputType = {
    id: string
    userId: string
    name: string
    position: string
    company: string
    text: string
    avatar: string | null
    rating: number
    date: Date
    relation: string
    projectLink: string | null
    createdAt: Date
    updatedAt: Date
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  type GetTestimonialGroupByPayload<T extends TestimonialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
        }
      >
    >


  export type TestimonialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    position?: boolean
    company?: boolean
    text?: boolean
    avatar?: boolean
    rating?: boolean
    date?: boolean
    relation?: boolean
    projectLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    projectTestimonials?: boolean | Testimonial$projectTestimonialsArgs<ExtArgs>
    _count?: boolean | TestimonialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    position?: boolean
    company?: boolean
    text?: boolean
    avatar?: boolean
    rating?: boolean
    date?: boolean
    relation?: boolean
    projectLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    position?: boolean
    company?: boolean
    text?: boolean
    avatar?: boolean
    rating?: boolean
    date?: boolean
    relation?: boolean
    projectLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    position?: boolean
    company?: boolean
    text?: boolean
    avatar?: boolean
    rating?: boolean
    date?: boolean
    relation?: boolean
    projectLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestimonialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "position" | "company" | "text" | "avatar" | "rating" | "date" | "relation" | "projectLink" | "createdAt" | "updatedAt", ExtArgs["result"]["testimonial"]>
  export type TestimonialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    projectTestimonials?: boolean | Testimonial$projectTestimonialsArgs<ExtArgs>
    _count?: boolean | TestimonialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestimonialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TestimonialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TestimonialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Testimonial"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      projectTestimonials: Prisma.$ProjectTestimonialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      position: string
      company: string
      text: string
      avatar: string | null
      rating: number
      date: Date
      relation: string
      projectLink: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testimonial"]>
    composites: {}
  }

  type TestimonialGetPayload<S extends boolean | null | undefined | TestimonialDefaultArgs> = $Result.GetResult<Prisma.$TestimonialPayload, S>

  type TestimonialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestimonialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestimonialCountAggregateInputType | true
    }

  export interface TestimonialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Testimonial'], meta: { name: 'Testimonial' } }
    /**
     * Find zero or one Testimonial that matches the filter.
     * @param {TestimonialFindUniqueArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestimonialFindUniqueArgs>(args: SelectSubset<T, TestimonialFindUniqueArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Testimonial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestimonialFindUniqueOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestimonialFindUniqueOrThrowArgs>(args: SelectSubset<T, TestimonialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testimonial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestimonialFindFirstArgs>(args?: SelectSubset<T, TestimonialFindFirstArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testimonial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestimonialFindFirstOrThrowArgs>(args?: SelectSubset<T, TestimonialFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Testimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testimonials
     * const testimonials = await prisma.testimonial.findMany()
     * 
     * // Get first 10 Testimonials
     * const testimonials = await prisma.testimonial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestimonialFindManyArgs>(args?: SelectSubset<T, TestimonialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Testimonial.
     * @param {TestimonialCreateArgs} args - Arguments to create a Testimonial.
     * @example
     * // Create one Testimonial
     * const Testimonial = await prisma.testimonial.create({
     *   data: {
     *     // ... data to create a Testimonial
     *   }
     * })
     * 
     */
    create<T extends TestimonialCreateArgs>(args: SelectSubset<T, TestimonialCreateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Testimonials.
     * @param {TestimonialCreateManyArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestimonialCreateManyArgs>(args?: SelectSubset<T, TestimonialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Testimonials and returns the data saved in the database.
     * @param {TestimonialCreateManyAndReturnArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Testimonials and only return the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestimonialCreateManyAndReturnArgs>(args?: SelectSubset<T, TestimonialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Testimonial.
     * @param {TestimonialDeleteArgs} args - Arguments to delete one Testimonial.
     * @example
     * // Delete one Testimonial
     * const Testimonial = await prisma.testimonial.delete({
     *   where: {
     *     // ... filter to delete one Testimonial
     *   }
     * })
     * 
     */
    delete<T extends TestimonialDeleteArgs>(args: SelectSubset<T, TestimonialDeleteArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Testimonial.
     * @param {TestimonialUpdateArgs} args - Arguments to update one Testimonial.
     * @example
     * // Update one Testimonial
     * const testimonial = await prisma.testimonial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestimonialUpdateArgs>(args: SelectSubset<T, TestimonialUpdateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Testimonials.
     * @param {TestimonialDeleteManyArgs} args - Arguments to filter Testimonials to delete.
     * @example
     * // Delete a few Testimonials
     * const { count } = await prisma.testimonial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestimonialDeleteManyArgs>(args?: SelectSubset<T, TestimonialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testimonials
     * const testimonial = await prisma.testimonial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestimonialUpdateManyArgs>(args: SelectSubset<T, TestimonialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials and returns the data updated in the database.
     * @param {TestimonialUpdateManyAndReturnArgs} args - Arguments to update many Testimonials.
     * @example
     * // Update many Testimonials
     * const testimonial = await prisma.testimonial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Testimonials and only return the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestimonialUpdateManyAndReturnArgs>(args: SelectSubset<T, TestimonialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Testimonial.
     * @param {TestimonialUpsertArgs} args - Arguments to update or create a Testimonial.
     * @example
     * // Update or create a Testimonial
     * const testimonial = await prisma.testimonial.upsert({
     *   create: {
     *     // ... data to create a Testimonial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testimonial we want to update
     *   }
     * })
     */
    upsert<T extends TestimonialUpsertArgs>(args: SelectSubset<T, TestimonialUpsertArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialCountArgs} args - Arguments to filter Testimonials to count.
     * @example
     * // Count the number of Testimonials
     * const count = await prisma.testimonial.count({
     *   where: {
     *     // ... the filter for the Testimonials we want to count
     *   }
     * })
    **/
    count<T extends TestimonialCountArgs>(
      args?: Subset<T, TestimonialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialAggregateArgs>(args: Subset<T, TestimonialAggregateArgs>): Prisma.PrismaPromise<GetTestimonialAggregateType<T>>

    /**
     * Group by Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestimonialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestimonialGroupByArgs['orderBy'] }
        : { orderBy?: TestimonialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestimonialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Testimonial model
   */
  readonly fields: TestimonialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Testimonial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestimonialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projectTestimonials<T extends Testimonial$projectTestimonialsArgs<ExtArgs> = {}>(args?: Subset<T, Testimonial$projectTestimonialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTestimonialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Testimonial model
   */
  interface TestimonialFieldRefs {
    readonly id: FieldRef<"Testimonial", 'String'>
    readonly userId: FieldRef<"Testimonial", 'String'>
    readonly name: FieldRef<"Testimonial", 'String'>
    readonly position: FieldRef<"Testimonial", 'String'>
    readonly company: FieldRef<"Testimonial", 'String'>
    readonly text: FieldRef<"Testimonial", 'String'>
    readonly avatar: FieldRef<"Testimonial", 'String'>
    readonly rating: FieldRef<"Testimonial", 'Int'>
    readonly date: FieldRef<"Testimonial", 'DateTime'>
    readonly relation: FieldRef<"Testimonial", 'String'>
    readonly projectLink: FieldRef<"Testimonial", 'String'>
    readonly createdAt: FieldRef<"Testimonial", 'DateTime'>
    readonly updatedAt: FieldRef<"Testimonial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Testimonial findUnique
   */
  export type TestimonialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findUniqueOrThrow
   */
  export type TestimonialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findFirst
   */
  export type TestimonialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findFirstOrThrow
   */
  export type TestimonialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findMany
   */
  export type TestimonialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonials to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial create
   */
  export type TestimonialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * The data needed to create a Testimonial.
     */
    data: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
  }

  /**
   * Testimonial createMany
   */
  export type TestimonialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Testimonial createManyAndReturn
   */
  export type TestimonialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Testimonial update
   */
  export type TestimonialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * The data needed to update a Testimonial.
     */
    data: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
    /**
     * Choose, which Testimonial to update.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial updateMany
   */
  export type TestimonialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Testimonials.
     */
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyInput>
    /**
     * Filter which Testimonials to update
     */
    where?: TestimonialWhereInput
    /**
     * Limit how many Testimonials to update.
     */
    limit?: number
  }

  /**
   * Testimonial updateManyAndReturn
   */
  export type TestimonialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * The data used to update Testimonials.
     */
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyInput>
    /**
     * Filter which Testimonials to update
     */
    where?: TestimonialWhereInput
    /**
     * Limit how many Testimonials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Testimonial upsert
   */
  export type TestimonialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * The filter to search for the Testimonial to update in case it exists.
     */
    where: TestimonialWhereUniqueInput
    /**
     * In case the Testimonial found by the `where` argument doesn't exist, create a new Testimonial with this data.
     */
    create: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
    /**
     * In case the Testimonial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
  }

  /**
   * Testimonial delete
   */
  export type TestimonialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter which Testimonial to delete.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial deleteMany
   */
  export type TestimonialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonials to delete
     */
    where?: TestimonialWhereInput
    /**
     * Limit how many Testimonials to delete.
     */
    limit?: number
  }

  /**
   * Testimonial.projectTestimonials
   */
  export type Testimonial$projectTestimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTestimonial
     */
    select?: ProjectTestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTestimonial
     */
    omit?: ProjectTestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTestimonialInclude<ExtArgs> | null
    where?: ProjectTestimonialWhereInput
    orderBy?: ProjectTestimonialOrderByWithRelationInput | ProjectTestimonialOrderByWithRelationInput[]
    cursor?: ProjectTestimonialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTestimonialScalarFieldEnum | ProjectTestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial without action
   */
  export type TestimonialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    value: string | null
    icon: string | null
    isPublic: boolean | null
    link: string | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    value: string | null
    icon: string | null
    isPublic: boolean | null
    link: string | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    value: number
    icon: number
    isPublic: number
    link: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    value?: true
    icon?: true
    isPublic?: true
    link?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    value?: true
    icon?: true
    isPublic?: true
    link?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    value?: true
    icon?: true
    isPublic?: true
    link?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    userId: string
    type: string
    value: string
    icon: string | null
    isPublic: boolean
    link: string | null
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    value?: boolean
    icon?: boolean
    isPublic?: boolean
    link?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    value?: boolean
    icon?: boolean
    isPublic?: boolean
    link?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    value?: boolean
    icon?: boolean
    isPublic?: boolean
    link?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    value?: boolean
    icon?: boolean
    isPublic?: boolean
    link?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "value" | "icon" | "isPublic" | "link", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      value: string
      icon: string | null
      isPublic: boolean
      link: string | null
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly userId: FieldRef<"Contact", 'String'>
    readonly type: FieldRef<"Contact", 'String'>
    readonly value: FieldRef<"Contact", 'String'>
    readonly icon: FieldRef<"Contact", 'String'>
    readonly isPublic: FieldRef<"Contact", 'Boolean'>
    readonly link: FieldRef<"Contact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model SocialMedia
   */

  export type AggregateSocialMedia = {
    _count: SocialMediaCountAggregateOutputType | null
    _min: SocialMediaMinAggregateOutputType | null
    _max: SocialMediaMaxAggregateOutputType | null
  }

  export type SocialMediaMinAggregateOutputType = {
    id: string | null
    userId: string | null
    platform: string | null
    url: string | null
    icon: string | null
    username: string | null
  }

  export type SocialMediaMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    platform: string | null
    url: string | null
    icon: string | null
    username: string | null
  }

  export type SocialMediaCountAggregateOutputType = {
    id: number
    userId: number
    platform: number
    url: number
    icon: number
    username: number
    _all: number
  }


  export type SocialMediaMinAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    url?: true
    icon?: true
    username?: true
  }

  export type SocialMediaMaxAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    url?: true
    icon?: true
    username?: true
  }

  export type SocialMediaCountAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    url?: true
    icon?: true
    username?: true
    _all?: true
  }

  export type SocialMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialMedia to aggregate.
     */
    where?: SocialMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMedias to fetch.
     */
    orderBy?: SocialMediaOrderByWithRelationInput | SocialMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialMedias
    **/
    _count?: true | SocialMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialMediaMaxAggregateInputType
  }

  export type GetSocialMediaAggregateType<T extends SocialMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialMedia[P]>
      : GetScalarType<T[P], AggregateSocialMedia[P]>
  }




  export type SocialMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialMediaWhereInput
    orderBy?: SocialMediaOrderByWithAggregationInput | SocialMediaOrderByWithAggregationInput[]
    by: SocialMediaScalarFieldEnum[] | SocialMediaScalarFieldEnum
    having?: SocialMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialMediaCountAggregateInputType | true
    _min?: SocialMediaMinAggregateInputType
    _max?: SocialMediaMaxAggregateInputType
  }

  export type SocialMediaGroupByOutputType = {
    id: string
    userId: string
    platform: string
    url: string
    icon: string | null
    username: string
    _count: SocialMediaCountAggregateOutputType | null
    _min: SocialMediaMinAggregateOutputType | null
    _max: SocialMediaMaxAggregateOutputType | null
  }

  type GetSocialMediaGroupByPayload<T extends SocialMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialMediaGroupByOutputType[P]>
            : GetScalarType<T[P], SocialMediaGroupByOutputType[P]>
        }
      >
    >


  export type SocialMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    url?: boolean
    icon?: boolean
    username?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialMedia"]>

  export type SocialMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    url?: boolean
    icon?: boolean
    username?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialMedia"]>

  export type SocialMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    url?: boolean
    icon?: boolean
    username?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialMedia"]>

  export type SocialMediaSelectScalar = {
    id?: boolean
    userId?: boolean
    platform?: boolean
    url?: boolean
    icon?: boolean
    username?: boolean
  }

  export type SocialMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "platform" | "url" | "icon" | "username", ExtArgs["result"]["socialMedia"]>
  export type SocialMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SocialMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SocialMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SocialMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialMedia"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      platform: string
      url: string
      icon: string | null
      username: string
    }, ExtArgs["result"]["socialMedia"]>
    composites: {}
  }

  type SocialMediaGetPayload<S extends boolean | null | undefined | SocialMediaDefaultArgs> = $Result.GetResult<Prisma.$SocialMediaPayload, S>

  type SocialMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialMediaCountAggregateInputType | true
    }

  export interface SocialMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialMedia'], meta: { name: 'SocialMedia' } }
    /**
     * Find zero or one SocialMedia that matches the filter.
     * @param {SocialMediaFindUniqueArgs} args - Arguments to find a SocialMedia
     * @example
     * // Get one SocialMedia
     * const socialMedia = await prisma.socialMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialMediaFindUniqueArgs>(args: SelectSubset<T, SocialMediaFindUniqueArgs<ExtArgs>>): Prisma__SocialMediaClient<$Result.GetResult<Prisma.$SocialMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialMediaFindUniqueOrThrowArgs} args - Arguments to find a SocialMedia
     * @example
     * // Get one SocialMedia
     * const socialMedia = await prisma.socialMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialMediaClient<$Result.GetResult<Prisma.$SocialMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaFindFirstArgs} args - Arguments to find a SocialMedia
     * @example
     * // Get one SocialMedia
     * const socialMedia = await prisma.socialMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialMediaFindFirstArgs>(args?: SelectSubset<T, SocialMediaFindFirstArgs<ExtArgs>>): Prisma__SocialMediaClient<$Result.GetResult<Prisma.$SocialMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaFindFirstOrThrowArgs} args - Arguments to find a SocialMedia
     * @example
     * // Get one SocialMedia
     * const socialMedia = await prisma.socialMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialMediaClient<$Result.GetResult<Prisma.$SocialMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialMedias
     * const socialMedias = await prisma.socialMedia.findMany()
     * 
     * // Get first 10 SocialMedias
     * const socialMedias = await prisma.socialMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialMediaWithIdOnly = await prisma.socialMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialMediaFindManyArgs>(args?: SelectSubset<T, SocialMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialMedia.
     * @param {SocialMediaCreateArgs} args - Arguments to create a SocialMedia.
     * @example
     * // Create one SocialMedia
     * const SocialMedia = await prisma.socialMedia.create({
     *   data: {
     *     // ... data to create a SocialMedia
     *   }
     * })
     * 
     */
    create<T extends SocialMediaCreateArgs>(args: SelectSubset<T, SocialMediaCreateArgs<ExtArgs>>): Prisma__SocialMediaClient<$Result.GetResult<Prisma.$SocialMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialMedias.
     * @param {SocialMediaCreateManyArgs} args - Arguments to create many SocialMedias.
     * @example
     * // Create many SocialMedias
     * const socialMedia = await prisma.socialMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialMediaCreateManyArgs>(args?: SelectSubset<T, SocialMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialMedias and returns the data saved in the database.
     * @param {SocialMediaCreateManyAndReturnArgs} args - Arguments to create many SocialMedias.
     * @example
     * // Create many SocialMedias
     * const socialMedia = await prisma.socialMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialMedias and only return the `id`
     * const socialMediaWithIdOnly = await prisma.socialMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SocialMedia.
     * @param {SocialMediaDeleteArgs} args - Arguments to delete one SocialMedia.
     * @example
     * // Delete one SocialMedia
     * const SocialMedia = await prisma.socialMedia.delete({
     *   where: {
     *     // ... filter to delete one SocialMedia
     *   }
     * })
     * 
     */
    delete<T extends SocialMediaDeleteArgs>(args: SelectSubset<T, SocialMediaDeleteArgs<ExtArgs>>): Prisma__SocialMediaClient<$Result.GetResult<Prisma.$SocialMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialMedia.
     * @param {SocialMediaUpdateArgs} args - Arguments to update one SocialMedia.
     * @example
     * // Update one SocialMedia
     * const socialMedia = await prisma.socialMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialMediaUpdateArgs>(args: SelectSubset<T, SocialMediaUpdateArgs<ExtArgs>>): Prisma__SocialMediaClient<$Result.GetResult<Prisma.$SocialMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialMedias.
     * @param {SocialMediaDeleteManyArgs} args - Arguments to filter SocialMedias to delete.
     * @example
     * // Delete a few SocialMedias
     * const { count } = await prisma.socialMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialMediaDeleteManyArgs>(args?: SelectSubset<T, SocialMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialMedias
     * const socialMedia = await prisma.socialMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialMediaUpdateManyArgs>(args: SelectSubset<T, SocialMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialMedias and returns the data updated in the database.
     * @param {SocialMediaUpdateManyAndReturnArgs} args - Arguments to update many SocialMedias.
     * @example
     * // Update many SocialMedias
     * const socialMedia = await prisma.socialMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SocialMedias and only return the `id`
     * const socialMediaWithIdOnly = await prisma.socialMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SocialMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, SocialMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SocialMedia.
     * @param {SocialMediaUpsertArgs} args - Arguments to update or create a SocialMedia.
     * @example
     * // Update or create a SocialMedia
     * const socialMedia = await prisma.socialMedia.upsert({
     *   create: {
     *     // ... data to create a SocialMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialMedia we want to update
     *   }
     * })
     */
    upsert<T extends SocialMediaUpsertArgs>(args: SelectSubset<T, SocialMediaUpsertArgs<ExtArgs>>): Prisma__SocialMediaClient<$Result.GetResult<Prisma.$SocialMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaCountArgs} args - Arguments to filter SocialMedias to count.
     * @example
     * // Count the number of SocialMedias
     * const count = await prisma.socialMedia.count({
     *   where: {
     *     // ... the filter for the SocialMedias we want to count
     *   }
     * })
    **/
    count<T extends SocialMediaCountArgs>(
      args?: Subset<T, SocialMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialMediaAggregateArgs>(args: Subset<T, SocialMediaAggregateArgs>): Prisma.PrismaPromise<GetSocialMediaAggregateType<T>>

    /**
     * Group by SocialMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialMediaGroupByArgs['orderBy'] }
        : { orderBy?: SocialMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialMedia model
   */
  readonly fields: SocialMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialMedia model
   */
  interface SocialMediaFieldRefs {
    readonly id: FieldRef<"SocialMedia", 'String'>
    readonly userId: FieldRef<"SocialMedia", 'String'>
    readonly platform: FieldRef<"SocialMedia", 'String'>
    readonly url: FieldRef<"SocialMedia", 'String'>
    readonly icon: FieldRef<"SocialMedia", 'String'>
    readonly username: FieldRef<"SocialMedia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SocialMedia findUnique
   */
  export type SocialMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMedia
     */
    select?: SocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMedia
     */
    omit?: SocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaInclude<ExtArgs> | null
    /**
     * Filter, which SocialMedia to fetch.
     */
    where: SocialMediaWhereUniqueInput
  }

  /**
   * SocialMedia findUniqueOrThrow
   */
  export type SocialMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMedia
     */
    select?: SocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMedia
     */
    omit?: SocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaInclude<ExtArgs> | null
    /**
     * Filter, which SocialMedia to fetch.
     */
    where: SocialMediaWhereUniqueInput
  }

  /**
   * SocialMedia findFirst
   */
  export type SocialMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMedia
     */
    select?: SocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMedia
     */
    omit?: SocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaInclude<ExtArgs> | null
    /**
     * Filter, which SocialMedia to fetch.
     */
    where?: SocialMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMedias to fetch.
     */
    orderBy?: SocialMediaOrderByWithRelationInput | SocialMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialMedias.
     */
    cursor?: SocialMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialMedias.
     */
    distinct?: SocialMediaScalarFieldEnum | SocialMediaScalarFieldEnum[]
  }

  /**
   * SocialMedia findFirstOrThrow
   */
  export type SocialMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMedia
     */
    select?: SocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMedia
     */
    omit?: SocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaInclude<ExtArgs> | null
    /**
     * Filter, which SocialMedia to fetch.
     */
    where?: SocialMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMedias to fetch.
     */
    orderBy?: SocialMediaOrderByWithRelationInput | SocialMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialMedias.
     */
    cursor?: SocialMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialMedias.
     */
    distinct?: SocialMediaScalarFieldEnum | SocialMediaScalarFieldEnum[]
  }

  /**
   * SocialMedia findMany
   */
  export type SocialMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMedia
     */
    select?: SocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMedia
     */
    omit?: SocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaInclude<ExtArgs> | null
    /**
     * Filter, which SocialMedias to fetch.
     */
    where?: SocialMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMedias to fetch.
     */
    orderBy?: SocialMediaOrderByWithRelationInput | SocialMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialMedias.
     */
    cursor?: SocialMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMedias.
     */
    skip?: number
    distinct?: SocialMediaScalarFieldEnum | SocialMediaScalarFieldEnum[]
  }

  /**
   * SocialMedia create
   */
  export type SocialMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMedia
     */
    select?: SocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMedia
     */
    omit?: SocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialMedia.
     */
    data: XOR<SocialMediaCreateInput, SocialMediaUncheckedCreateInput>
  }

  /**
   * SocialMedia createMany
   */
  export type SocialMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialMedias.
     */
    data: SocialMediaCreateManyInput | SocialMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialMedia createManyAndReturn
   */
  export type SocialMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMedia
     */
    select?: SocialMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMedia
     */
    omit?: SocialMediaOmit<ExtArgs> | null
    /**
     * The data used to create many SocialMedias.
     */
    data: SocialMediaCreateManyInput | SocialMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialMedia update
   */
  export type SocialMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMedia
     */
    select?: SocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMedia
     */
    omit?: SocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialMedia.
     */
    data: XOR<SocialMediaUpdateInput, SocialMediaUncheckedUpdateInput>
    /**
     * Choose, which SocialMedia to update.
     */
    where: SocialMediaWhereUniqueInput
  }

  /**
   * SocialMedia updateMany
   */
  export type SocialMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialMedias.
     */
    data: XOR<SocialMediaUpdateManyMutationInput, SocialMediaUncheckedUpdateManyInput>
    /**
     * Filter which SocialMedias to update
     */
    where?: SocialMediaWhereInput
    /**
     * Limit how many SocialMedias to update.
     */
    limit?: number
  }

  /**
   * SocialMedia updateManyAndReturn
   */
  export type SocialMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMedia
     */
    select?: SocialMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMedia
     */
    omit?: SocialMediaOmit<ExtArgs> | null
    /**
     * The data used to update SocialMedias.
     */
    data: XOR<SocialMediaUpdateManyMutationInput, SocialMediaUncheckedUpdateManyInput>
    /**
     * Filter which SocialMedias to update
     */
    where?: SocialMediaWhereInput
    /**
     * Limit how many SocialMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialMedia upsert
   */
  export type SocialMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMedia
     */
    select?: SocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMedia
     */
    omit?: SocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialMedia to update in case it exists.
     */
    where: SocialMediaWhereUniqueInput
    /**
     * In case the SocialMedia found by the `where` argument doesn't exist, create a new SocialMedia with this data.
     */
    create: XOR<SocialMediaCreateInput, SocialMediaUncheckedCreateInput>
    /**
     * In case the SocialMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialMediaUpdateInput, SocialMediaUncheckedUpdateInput>
  }

  /**
   * SocialMedia delete
   */
  export type SocialMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMedia
     */
    select?: SocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMedia
     */
    omit?: SocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaInclude<ExtArgs> | null
    /**
     * Filter which SocialMedia to delete.
     */
    where: SocialMediaWhereUniqueInput
  }

  /**
   * SocialMedia deleteMany
   */
  export type SocialMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialMedias to delete
     */
    where?: SocialMediaWhereInput
    /**
     * Limit how many SocialMedias to delete.
     */
    limit?: number
  }

  /**
   * SocialMedia without action
   */
  export type SocialMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMedia
     */
    select?: SocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMedia
     */
    omit?: SocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaInclude<ExtArgs> | null
  }


  /**
   * Model DevStats
   */

  export type AggregateDevStats = {
    _count: DevStatsCountAggregateOutputType | null
    _avg: DevStatsAvgAggregateOutputType | null
    _sum: DevStatsSumAggregateOutputType | null
    _min: DevStatsMinAggregateOutputType | null
    _max: DevStatsMaxAggregateOutputType | null
  }

  export type DevStatsAvgAggregateOutputType = {
    repos: number | null
    stars: number | null
    contributions: number | null
    rating: number | null
    followers: number | null
    following: number | null
    streak: number | null
    commits: number | null
    prsOpened: number | null
    issuesClosed: number | null
  }

  export type DevStatsSumAggregateOutputType = {
    repos: number | null
    stars: number | null
    contributions: number | null
    rating: number | null
    followers: number | null
    following: number | null
    streak: number | null
    commits: number | null
    prsOpened: number | null
    issuesClosed: number | null
  }

  export type DevStatsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    repos: number | null
    stars: number | null
    contributions: number | null
    rating: number | null
    followers: number | null
    following: number | null
    streak: number | null
    commits: number | null
    prsOpened: number | null
    issuesClosed: number | null
    rank: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DevStatsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    repos: number | null
    stars: number | null
    contributions: number | null
    rating: number | null
    followers: number | null
    following: number | null
    streak: number | null
    commits: number | null
    prsOpened: number | null
    issuesClosed: number | null
    rank: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DevStatsCountAggregateOutputType = {
    id: number
    userId: number
    repos: number
    stars: number
    contributions: number
    rating: number
    followers: number
    following: number
    streak: number
    commits: number
    prsOpened: number
    issuesClosed: number
    rank: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DevStatsAvgAggregateInputType = {
    repos?: true
    stars?: true
    contributions?: true
    rating?: true
    followers?: true
    following?: true
    streak?: true
    commits?: true
    prsOpened?: true
    issuesClosed?: true
  }

  export type DevStatsSumAggregateInputType = {
    repos?: true
    stars?: true
    contributions?: true
    rating?: true
    followers?: true
    following?: true
    streak?: true
    commits?: true
    prsOpened?: true
    issuesClosed?: true
  }

  export type DevStatsMinAggregateInputType = {
    id?: true
    userId?: true
    repos?: true
    stars?: true
    contributions?: true
    rating?: true
    followers?: true
    following?: true
    streak?: true
    commits?: true
    prsOpened?: true
    issuesClosed?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DevStatsMaxAggregateInputType = {
    id?: true
    userId?: true
    repos?: true
    stars?: true
    contributions?: true
    rating?: true
    followers?: true
    following?: true
    streak?: true
    commits?: true
    prsOpened?: true
    issuesClosed?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DevStatsCountAggregateInputType = {
    id?: true
    userId?: true
    repos?: true
    stars?: true
    contributions?: true
    rating?: true
    followers?: true
    following?: true
    streak?: true
    commits?: true
    prsOpened?: true
    issuesClosed?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DevStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DevStats to aggregate.
     */
    where?: DevStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevStats to fetch.
     */
    orderBy?: DevStatsOrderByWithRelationInput | DevStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DevStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DevStats
    **/
    _count?: true | DevStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DevStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DevStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DevStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DevStatsMaxAggregateInputType
  }

  export type GetDevStatsAggregateType<T extends DevStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateDevStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevStats[P]>
      : GetScalarType<T[P], AggregateDevStats[P]>
  }




  export type DevStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DevStatsWhereInput
    orderBy?: DevStatsOrderByWithAggregationInput | DevStatsOrderByWithAggregationInput[]
    by: DevStatsScalarFieldEnum[] | DevStatsScalarFieldEnum
    having?: DevStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DevStatsCountAggregateInputType | true
    _avg?: DevStatsAvgAggregateInputType
    _sum?: DevStatsSumAggregateInputType
    _min?: DevStatsMinAggregateInputType
    _max?: DevStatsMaxAggregateInputType
  }

  export type DevStatsGroupByOutputType = {
    id: string
    userId: string
    repos: number
    stars: number
    contributions: number
    rating: number
    followers: number
    following: number
    streak: number
    commits: number
    prsOpened: number
    issuesClosed: number
    rank: string | null
    createdAt: Date
    updatedAt: Date
    _count: DevStatsCountAggregateOutputType | null
    _avg: DevStatsAvgAggregateOutputType | null
    _sum: DevStatsSumAggregateOutputType | null
    _min: DevStatsMinAggregateOutputType | null
    _max: DevStatsMaxAggregateOutputType | null
  }

  type GetDevStatsGroupByPayload<T extends DevStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DevStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DevStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DevStatsGroupByOutputType[P]>
            : GetScalarType<T[P], DevStatsGroupByOutputType[P]>
        }
      >
    >


  export type DevStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    repos?: boolean
    stars?: boolean
    contributions?: boolean
    rating?: boolean
    followers?: boolean
    following?: boolean
    streak?: boolean
    commits?: boolean
    prsOpened?: boolean
    issuesClosed?: boolean
    rank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["devStats"]>

  export type DevStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    repos?: boolean
    stars?: boolean
    contributions?: boolean
    rating?: boolean
    followers?: boolean
    following?: boolean
    streak?: boolean
    commits?: boolean
    prsOpened?: boolean
    issuesClosed?: boolean
    rank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["devStats"]>

  export type DevStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    repos?: boolean
    stars?: boolean
    contributions?: boolean
    rating?: boolean
    followers?: boolean
    following?: boolean
    streak?: boolean
    commits?: boolean
    prsOpened?: boolean
    issuesClosed?: boolean
    rank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["devStats"]>

  export type DevStatsSelectScalar = {
    id?: boolean
    userId?: boolean
    repos?: boolean
    stars?: boolean
    contributions?: boolean
    rating?: boolean
    followers?: boolean
    following?: boolean
    streak?: boolean
    commits?: boolean
    prsOpened?: boolean
    issuesClosed?: boolean
    rank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DevStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "repos" | "stars" | "contributions" | "rating" | "followers" | "following" | "streak" | "commits" | "prsOpened" | "issuesClosed" | "rank" | "createdAt" | "updatedAt", ExtArgs["result"]["devStats"]>
  export type DevStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DevStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DevStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DevStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DevStats"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      repos: number
      stars: number
      contributions: number
      rating: number
      followers: number
      following: number
      streak: number
      commits: number
      prsOpened: number
      issuesClosed: number
      rank: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["devStats"]>
    composites: {}
  }

  type DevStatsGetPayload<S extends boolean | null | undefined | DevStatsDefaultArgs> = $Result.GetResult<Prisma.$DevStatsPayload, S>

  type DevStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DevStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DevStatsCountAggregateInputType | true
    }

  export interface DevStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DevStats'], meta: { name: 'DevStats' } }
    /**
     * Find zero or one DevStats that matches the filter.
     * @param {DevStatsFindUniqueArgs} args - Arguments to find a DevStats
     * @example
     * // Get one DevStats
     * const devStats = await prisma.devStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DevStatsFindUniqueArgs>(args: SelectSubset<T, DevStatsFindUniqueArgs<ExtArgs>>): Prisma__DevStatsClient<$Result.GetResult<Prisma.$DevStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DevStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DevStatsFindUniqueOrThrowArgs} args - Arguments to find a DevStats
     * @example
     * // Get one DevStats
     * const devStats = await prisma.devStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DevStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, DevStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DevStatsClient<$Result.GetResult<Prisma.$DevStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DevStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevStatsFindFirstArgs} args - Arguments to find a DevStats
     * @example
     * // Get one DevStats
     * const devStats = await prisma.devStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DevStatsFindFirstArgs>(args?: SelectSubset<T, DevStatsFindFirstArgs<ExtArgs>>): Prisma__DevStatsClient<$Result.GetResult<Prisma.$DevStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DevStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevStatsFindFirstOrThrowArgs} args - Arguments to find a DevStats
     * @example
     * // Get one DevStats
     * const devStats = await prisma.devStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DevStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, DevStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DevStatsClient<$Result.GetResult<Prisma.$DevStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DevStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DevStats
     * const devStats = await prisma.devStats.findMany()
     * 
     * // Get first 10 DevStats
     * const devStats = await prisma.devStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const devStatsWithIdOnly = await prisma.devStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DevStatsFindManyArgs>(args?: SelectSubset<T, DevStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DevStats.
     * @param {DevStatsCreateArgs} args - Arguments to create a DevStats.
     * @example
     * // Create one DevStats
     * const DevStats = await prisma.devStats.create({
     *   data: {
     *     // ... data to create a DevStats
     *   }
     * })
     * 
     */
    create<T extends DevStatsCreateArgs>(args: SelectSubset<T, DevStatsCreateArgs<ExtArgs>>): Prisma__DevStatsClient<$Result.GetResult<Prisma.$DevStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DevStats.
     * @param {DevStatsCreateManyArgs} args - Arguments to create many DevStats.
     * @example
     * // Create many DevStats
     * const devStats = await prisma.devStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DevStatsCreateManyArgs>(args?: SelectSubset<T, DevStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DevStats and returns the data saved in the database.
     * @param {DevStatsCreateManyAndReturnArgs} args - Arguments to create many DevStats.
     * @example
     * // Create many DevStats
     * const devStats = await prisma.devStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DevStats and only return the `id`
     * const devStatsWithIdOnly = await prisma.devStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DevStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, DevStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DevStats.
     * @param {DevStatsDeleteArgs} args - Arguments to delete one DevStats.
     * @example
     * // Delete one DevStats
     * const DevStats = await prisma.devStats.delete({
     *   where: {
     *     // ... filter to delete one DevStats
     *   }
     * })
     * 
     */
    delete<T extends DevStatsDeleteArgs>(args: SelectSubset<T, DevStatsDeleteArgs<ExtArgs>>): Prisma__DevStatsClient<$Result.GetResult<Prisma.$DevStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DevStats.
     * @param {DevStatsUpdateArgs} args - Arguments to update one DevStats.
     * @example
     * // Update one DevStats
     * const devStats = await prisma.devStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DevStatsUpdateArgs>(args: SelectSubset<T, DevStatsUpdateArgs<ExtArgs>>): Prisma__DevStatsClient<$Result.GetResult<Prisma.$DevStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DevStats.
     * @param {DevStatsDeleteManyArgs} args - Arguments to filter DevStats to delete.
     * @example
     * // Delete a few DevStats
     * const { count } = await prisma.devStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DevStatsDeleteManyArgs>(args?: SelectSubset<T, DevStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DevStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DevStats
     * const devStats = await prisma.devStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DevStatsUpdateManyArgs>(args: SelectSubset<T, DevStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DevStats and returns the data updated in the database.
     * @param {DevStatsUpdateManyAndReturnArgs} args - Arguments to update many DevStats.
     * @example
     * // Update many DevStats
     * const devStats = await prisma.devStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DevStats and only return the `id`
     * const devStatsWithIdOnly = await prisma.devStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DevStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, DevStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DevStats.
     * @param {DevStatsUpsertArgs} args - Arguments to update or create a DevStats.
     * @example
     * // Update or create a DevStats
     * const devStats = await prisma.devStats.upsert({
     *   create: {
     *     // ... data to create a DevStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DevStats we want to update
     *   }
     * })
     */
    upsert<T extends DevStatsUpsertArgs>(args: SelectSubset<T, DevStatsUpsertArgs<ExtArgs>>): Prisma__DevStatsClient<$Result.GetResult<Prisma.$DevStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DevStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevStatsCountArgs} args - Arguments to filter DevStats to count.
     * @example
     * // Count the number of DevStats
     * const count = await prisma.devStats.count({
     *   where: {
     *     // ... the filter for the DevStats we want to count
     *   }
     * })
    **/
    count<T extends DevStatsCountArgs>(
      args?: Subset<T, DevStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DevStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DevStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DevStatsAggregateArgs>(args: Subset<T, DevStatsAggregateArgs>): Prisma.PrismaPromise<GetDevStatsAggregateType<T>>

    /**
     * Group by DevStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DevStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DevStatsGroupByArgs['orderBy'] }
        : { orderBy?: DevStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DevStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDevStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DevStats model
   */
  readonly fields: DevStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DevStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DevStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DevStats model
   */
  interface DevStatsFieldRefs {
    readonly id: FieldRef<"DevStats", 'String'>
    readonly userId: FieldRef<"DevStats", 'String'>
    readonly repos: FieldRef<"DevStats", 'Int'>
    readonly stars: FieldRef<"DevStats", 'Int'>
    readonly contributions: FieldRef<"DevStats", 'Int'>
    readonly rating: FieldRef<"DevStats", 'Float'>
    readonly followers: FieldRef<"DevStats", 'Int'>
    readonly following: FieldRef<"DevStats", 'Int'>
    readonly streak: FieldRef<"DevStats", 'Int'>
    readonly commits: FieldRef<"DevStats", 'Int'>
    readonly prsOpened: FieldRef<"DevStats", 'Int'>
    readonly issuesClosed: FieldRef<"DevStats", 'Int'>
    readonly rank: FieldRef<"DevStats", 'String'>
    readonly createdAt: FieldRef<"DevStats", 'DateTime'>
    readonly updatedAt: FieldRef<"DevStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DevStats findUnique
   */
  export type DevStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevStats
     */
    select?: DevStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevStats
     */
    omit?: DevStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevStatsInclude<ExtArgs> | null
    /**
     * Filter, which DevStats to fetch.
     */
    where: DevStatsWhereUniqueInput
  }

  /**
   * DevStats findUniqueOrThrow
   */
  export type DevStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevStats
     */
    select?: DevStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevStats
     */
    omit?: DevStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevStatsInclude<ExtArgs> | null
    /**
     * Filter, which DevStats to fetch.
     */
    where: DevStatsWhereUniqueInput
  }

  /**
   * DevStats findFirst
   */
  export type DevStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevStats
     */
    select?: DevStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevStats
     */
    omit?: DevStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevStatsInclude<ExtArgs> | null
    /**
     * Filter, which DevStats to fetch.
     */
    where?: DevStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevStats to fetch.
     */
    orderBy?: DevStatsOrderByWithRelationInput | DevStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DevStats.
     */
    cursor?: DevStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DevStats.
     */
    distinct?: DevStatsScalarFieldEnum | DevStatsScalarFieldEnum[]
  }

  /**
   * DevStats findFirstOrThrow
   */
  export type DevStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevStats
     */
    select?: DevStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevStats
     */
    omit?: DevStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevStatsInclude<ExtArgs> | null
    /**
     * Filter, which DevStats to fetch.
     */
    where?: DevStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevStats to fetch.
     */
    orderBy?: DevStatsOrderByWithRelationInput | DevStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DevStats.
     */
    cursor?: DevStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DevStats.
     */
    distinct?: DevStatsScalarFieldEnum | DevStatsScalarFieldEnum[]
  }

  /**
   * DevStats findMany
   */
  export type DevStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevStats
     */
    select?: DevStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevStats
     */
    omit?: DevStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevStatsInclude<ExtArgs> | null
    /**
     * Filter, which DevStats to fetch.
     */
    where?: DevStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevStats to fetch.
     */
    orderBy?: DevStatsOrderByWithRelationInput | DevStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DevStats.
     */
    cursor?: DevStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevStats.
     */
    skip?: number
    distinct?: DevStatsScalarFieldEnum | DevStatsScalarFieldEnum[]
  }

  /**
   * DevStats create
   */
  export type DevStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevStats
     */
    select?: DevStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevStats
     */
    omit?: DevStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a DevStats.
     */
    data: XOR<DevStatsCreateInput, DevStatsUncheckedCreateInput>
  }

  /**
   * DevStats createMany
   */
  export type DevStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DevStats.
     */
    data: DevStatsCreateManyInput | DevStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DevStats createManyAndReturn
   */
  export type DevStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevStats
     */
    select?: DevStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DevStats
     */
    omit?: DevStatsOmit<ExtArgs> | null
    /**
     * The data used to create many DevStats.
     */
    data: DevStatsCreateManyInput | DevStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DevStats update
   */
  export type DevStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevStats
     */
    select?: DevStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevStats
     */
    omit?: DevStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a DevStats.
     */
    data: XOR<DevStatsUpdateInput, DevStatsUncheckedUpdateInput>
    /**
     * Choose, which DevStats to update.
     */
    where: DevStatsWhereUniqueInput
  }

  /**
   * DevStats updateMany
   */
  export type DevStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DevStats.
     */
    data: XOR<DevStatsUpdateManyMutationInput, DevStatsUncheckedUpdateManyInput>
    /**
     * Filter which DevStats to update
     */
    where?: DevStatsWhereInput
    /**
     * Limit how many DevStats to update.
     */
    limit?: number
  }

  /**
   * DevStats updateManyAndReturn
   */
  export type DevStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevStats
     */
    select?: DevStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DevStats
     */
    omit?: DevStatsOmit<ExtArgs> | null
    /**
     * The data used to update DevStats.
     */
    data: XOR<DevStatsUpdateManyMutationInput, DevStatsUncheckedUpdateManyInput>
    /**
     * Filter which DevStats to update
     */
    where?: DevStatsWhereInput
    /**
     * Limit how many DevStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DevStats upsert
   */
  export type DevStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevStats
     */
    select?: DevStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevStats
     */
    omit?: DevStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the DevStats to update in case it exists.
     */
    where: DevStatsWhereUniqueInput
    /**
     * In case the DevStats found by the `where` argument doesn't exist, create a new DevStats with this data.
     */
    create: XOR<DevStatsCreateInput, DevStatsUncheckedCreateInput>
    /**
     * In case the DevStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DevStatsUpdateInput, DevStatsUncheckedUpdateInput>
  }

  /**
   * DevStats delete
   */
  export type DevStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevStats
     */
    select?: DevStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevStats
     */
    omit?: DevStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevStatsInclude<ExtArgs> | null
    /**
     * Filter which DevStats to delete.
     */
    where: DevStatsWhereUniqueInput
  }

  /**
   * DevStats deleteMany
   */
  export type DevStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DevStats to delete
     */
    where?: DevStatsWhereInput
    /**
     * Limit how many DevStats to delete.
     */
    limit?: number
  }

  /**
   * DevStats without action
   */
  export type DevStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevStats
     */
    select?: DevStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevStats
     */
    omit?: DevStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevStatsInclude<ExtArgs> | null
  }


  /**
   * Model ContributionData
   */

  export type AggregateContributionData = {
    _count: ContributionDataCountAggregateOutputType | null
    _avg: ContributionDataAvgAggregateOutputType | null
    _sum: ContributionDataSumAggregateOutputType | null
    _min: ContributionDataMinAggregateOutputType | null
    _max: ContributionDataMaxAggregateOutputType | null
  }

  export type ContributionDataAvgAggregateOutputType = {
    year: number | null
    total: number | null
  }

  export type ContributionDataSumAggregateOutputType = {
    year: number | null
    total: number | null
  }

  export type ContributionDataMinAggregateOutputType = {
    id: string | null
    userId: string | null
    year: number | null
    total: number | null
    startRange: Date | null
    endRange: Date | null
  }

  export type ContributionDataMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    year: number | null
    total: number | null
    startRange: Date | null
    endRange: Date | null
  }

  export type ContributionDataCountAggregateOutputType = {
    id: number
    userId: number
    year: number
    total: number
    startRange: number
    endRange: number
    _all: number
  }


  export type ContributionDataAvgAggregateInputType = {
    year?: true
    total?: true
  }

  export type ContributionDataSumAggregateInputType = {
    year?: true
    total?: true
  }

  export type ContributionDataMinAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    total?: true
    startRange?: true
    endRange?: true
  }

  export type ContributionDataMaxAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    total?: true
    startRange?: true
    endRange?: true
  }

  export type ContributionDataCountAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    total?: true
    startRange?: true
    endRange?: true
    _all?: true
  }

  export type ContributionDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContributionData to aggregate.
     */
    where?: ContributionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContributionData to fetch.
     */
    orderBy?: ContributionDataOrderByWithRelationInput | ContributionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContributionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContributionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContributionData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContributionData
    **/
    _count?: true | ContributionDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContributionDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContributionDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContributionDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContributionDataMaxAggregateInputType
  }

  export type GetContributionDataAggregateType<T extends ContributionDataAggregateArgs> = {
        [P in keyof T & keyof AggregateContributionData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContributionData[P]>
      : GetScalarType<T[P], AggregateContributionData[P]>
  }




  export type ContributionDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContributionDataWhereInput
    orderBy?: ContributionDataOrderByWithAggregationInput | ContributionDataOrderByWithAggregationInput[]
    by: ContributionDataScalarFieldEnum[] | ContributionDataScalarFieldEnum
    having?: ContributionDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContributionDataCountAggregateInputType | true
    _avg?: ContributionDataAvgAggregateInputType
    _sum?: ContributionDataSumAggregateInputType
    _min?: ContributionDataMinAggregateInputType
    _max?: ContributionDataMaxAggregateInputType
  }

  export type ContributionDataGroupByOutputType = {
    id: string
    userId: string
    year: number
    total: number
    startRange: Date
    endRange: Date
    _count: ContributionDataCountAggregateOutputType | null
    _avg: ContributionDataAvgAggregateOutputType | null
    _sum: ContributionDataSumAggregateOutputType | null
    _min: ContributionDataMinAggregateOutputType | null
    _max: ContributionDataMaxAggregateOutputType | null
  }

  type GetContributionDataGroupByPayload<T extends ContributionDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContributionDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContributionDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContributionDataGroupByOutputType[P]>
            : GetScalarType<T[P], ContributionDataGroupByOutputType[P]>
        }
      >
    >


  export type ContributionDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    total?: boolean
    startRange?: boolean
    endRange?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    days?: boolean | ContributionData$daysArgs<ExtArgs>
    _count?: boolean | ContributionDataCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contributionData"]>

  export type ContributionDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    total?: boolean
    startRange?: boolean
    endRange?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contributionData"]>

  export type ContributionDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    total?: boolean
    startRange?: boolean
    endRange?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contributionData"]>

  export type ContributionDataSelectScalar = {
    id?: boolean
    userId?: boolean
    year?: boolean
    total?: boolean
    startRange?: boolean
    endRange?: boolean
  }

  export type ContributionDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "year" | "total" | "startRange" | "endRange", ExtArgs["result"]["contributionData"]>
  export type ContributionDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    days?: boolean | ContributionData$daysArgs<ExtArgs>
    _count?: boolean | ContributionDataCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContributionDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContributionDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContributionDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContributionData"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      days: Prisma.$ContributionDayPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      year: number
      total: number
      startRange: Date
      endRange: Date
    }, ExtArgs["result"]["contributionData"]>
    composites: {}
  }

  type ContributionDataGetPayload<S extends boolean | null | undefined | ContributionDataDefaultArgs> = $Result.GetResult<Prisma.$ContributionDataPayload, S>

  type ContributionDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContributionDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContributionDataCountAggregateInputType | true
    }

  export interface ContributionDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContributionData'], meta: { name: 'ContributionData' } }
    /**
     * Find zero or one ContributionData that matches the filter.
     * @param {ContributionDataFindUniqueArgs} args - Arguments to find a ContributionData
     * @example
     * // Get one ContributionData
     * const contributionData = await prisma.contributionData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContributionDataFindUniqueArgs>(args: SelectSubset<T, ContributionDataFindUniqueArgs<ExtArgs>>): Prisma__ContributionDataClient<$Result.GetResult<Prisma.$ContributionDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContributionData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContributionDataFindUniqueOrThrowArgs} args - Arguments to find a ContributionData
     * @example
     * // Get one ContributionData
     * const contributionData = await prisma.contributionData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContributionDataFindUniqueOrThrowArgs>(args: SelectSubset<T, ContributionDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContributionDataClient<$Result.GetResult<Prisma.$ContributionDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContributionData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContributionDataFindFirstArgs} args - Arguments to find a ContributionData
     * @example
     * // Get one ContributionData
     * const contributionData = await prisma.contributionData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContributionDataFindFirstArgs>(args?: SelectSubset<T, ContributionDataFindFirstArgs<ExtArgs>>): Prisma__ContributionDataClient<$Result.GetResult<Prisma.$ContributionDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContributionData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContributionDataFindFirstOrThrowArgs} args - Arguments to find a ContributionData
     * @example
     * // Get one ContributionData
     * const contributionData = await prisma.contributionData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContributionDataFindFirstOrThrowArgs>(args?: SelectSubset<T, ContributionDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContributionDataClient<$Result.GetResult<Prisma.$ContributionDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContributionData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContributionDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContributionData
     * const contributionData = await prisma.contributionData.findMany()
     * 
     * // Get first 10 ContributionData
     * const contributionData = await prisma.contributionData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contributionDataWithIdOnly = await prisma.contributionData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContributionDataFindManyArgs>(args?: SelectSubset<T, ContributionDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContributionDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContributionData.
     * @param {ContributionDataCreateArgs} args - Arguments to create a ContributionData.
     * @example
     * // Create one ContributionData
     * const ContributionData = await prisma.contributionData.create({
     *   data: {
     *     // ... data to create a ContributionData
     *   }
     * })
     * 
     */
    create<T extends ContributionDataCreateArgs>(args: SelectSubset<T, ContributionDataCreateArgs<ExtArgs>>): Prisma__ContributionDataClient<$Result.GetResult<Prisma.$ContributionDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContributionData.
     * @param {ContributionDataCreateManyArgs} args - Arguments to create many ContributionData.
     * @example
     * // Create many ContributionData
     * const contributionData = await prisma.contributionData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContributionDataCreateManyArgs>(args?: SelectSubset<T, ContributionDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContributionData and returns the data saved in the database.
     * @param {ContributionDataCreateManyAndReturnArgs} args - Arguments to create many ContributionData.
     * @example
     * // Create many ContributionData
     * const contributionData = await prisma.contributionData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContributionData and only return the `id`
     * const contributionDataWithIdOnly = await prisma.contributionData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContributionDataCreateManyAndReturnArgs>(args?: SelectSubset<T, ContributionDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContributionDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContributionData.
     * @param {ContributionDataDeleteArgs} args - Arguments to delete one ContributionData.
     * @example
     * // Delete one ContributionData
     * const ContributionData = await prisma.contributionData.delete({
     *   where: {
     *     // ... filter to delete one ContributionData
     *   }
     * })
     * 
     */
    delete<T extends ContributionDataDeleteArgs>(args: SelectSubset<T, ContributionDataDeleteArgs<ExtArgs>>): Prisma__ContributionDataClient<$Result.GetResult<Prisma.$ContributionDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContributionData.
     * @param {ContributionDataUpdateArgs} args - Arguments to update one ContributionData.
     * @example
     * // Update one ContributionData
     * const contributionData = await prisma.contributionData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContributionDataUpdateArgs>(args: SelectSubset<T, ContributionDataUpdateArgs<ExtArgs>>): Prisma__ContributionDataClient<$Result.GetResult<Prisma.$ContributionDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContributionData.
     * @param {ContributionDataDeleteManyArgs} args - Arguments to filter ContributionData to delete.
     * @example
     * // Delete a few ContributionData
     * const { count } = await prisma.contributionData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContributionDataDeleteManyArgs>(args?: SelectSubset<T, ContributionDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContributionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContributionDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContributionData
     * const contributionData = await prisma.contributionData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContributionDataUpdateManyArgs>(args: SelectSubset<T, ContributionDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContributionData and returns the data updated in the database.
     * @param {ContributionDataUpdateManyAndReturnArgs} args - Arguments to update many ContributionData.
     * @example
     * // Update many ContributionData
     * const contributionData = await prisma.contributionData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContributionData and only return the `id`
     * const contributionDataWithIdOnly = await prisma.contributionData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContributionDataUpdateManyAndReturnArgs>(args: SelectSubset<T, ContributionDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContributionDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContributionData.
     * @param {ContributionDataUpsertArgs} args - Arguments to update or create a ContributionData.
     * @example
     * // Update or create a ContributionData
     * const contributionData = await prisma.contributionData.upsert({
     *   create: {
     *     // ... data to create a ContributionData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContributionData we want to update
     *   }
     * })
     */
    upsert<T extends ContributionDataUpsertArgs>(args: SelectSubset<T, ContributionDataUpsertArgs<ExtArgs>>): Prisma__ContributionDataClient<$Result.GetResult<Prisma.$ContributionDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContributionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContributionDataCountArgs} args - Arguments to filter ContributionData to count.
     * @example
     * // Count the number of ContributionData
     * const count = await prisma.contributionData.count({
     *   where: {
     *     // ... the filter for the ContributionData we want to count
     *   }
     * })
    **/
    count<T extends ContributionDataCountArgs>(
      args?: Subset<T, ContributionDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContributionDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContributionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContributionDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContributionDataAggregateArgs>(args: Subset<T, ContributionDataAggregateArgs>): Prisma.PrismaPromise<GetContributionDataAggregateType<T>>

    /**
     * Group by ContributionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContributionDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContributionDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContributionDataGroupByArgs['orderBy'] }
        : { orderBy?: ContributionDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContributionDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContributionDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContributionData model
   */
  readonly fields: ContributionDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContributionData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContributionDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    days<T extends ContributionData$daysArgs<ExtArgs> = {}>(args?: Subset<T, ContributionData$daysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContributionDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContributionData model
   */
  interface ContributionDataFieldRefs {
    readonly id: FieldRef<"ContributionData", 'String'>
    readonly userId: FieldRef<"ContributionData", 'String'>
    readonly year: FieldRef<"ContributionData", 'Int'>
    readonly total: FieldRef<"ContributionData", 'Int'>
    readonly startRange: FieldRef<"ContributionData", 'DateTime'>
    readonly endRange: FieldRef<"ContributionData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContributionData findUnique
   */
  export type ContributionDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionData
     */
    select?: ContributionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionData
     */
    omit?: ContributionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDataInclude<ExtArgs> | null
    /**
     * Filter, which ContributionData to fetch.
     */
    where: ContributionDataWhereUniqueInput
  }

  /**
   * ContributionData findUniqueOrThrow
   */
  export type ContributionDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionData
     */
    select?: ContributionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionData
     */
    omit?: ContributionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDataInclude<ExtArgs> | null
    /**
     * Filter, which ContributionData to fetch.
     */
    where: ContributionDataWhereUniqueInput
  }

  /**
   * ContributionData findFirst
   */
  export type ContributionDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionData
     */
    select?: ContributionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionData
     */
    omit?: ContributionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDataInclude<ExtArgs> | null
    /**
     * Filter, which ContributionData to fetch.
     */
    where?: ContributionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContributionData to fetch.
     */
    orderBy?: ContributionDataOrderByWithRelationInput | ContributionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContributionData.
     */
    cursor?: ContributionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContributionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContributionData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContributionData.
     */
    distinct?: ContributionDataScalarFieldEnum | ContributionDataScalarFieldEnum[]
  }

  /**
   * ContributionData findFirstOrThrow
   */
  export type ContributionDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionData
     */
    select?: ContributionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionData
     */
    omit?: ContributionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDataInclude<ExtArgs> | null
    /**
     * Filter, which ContributionData to fetch.
     */
    where?: ContributionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContributionData to fetch.
     */
    orderBy?: ContributionDataOrderByWithRelationInput | ContributionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContributionData.
     */
    cursor?: ContributionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContributionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContributionData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContributionData.
     */
    distinct?: ContributionDataScalarFieldEnum | ContributionDataScalarFieldEnum[]
  }

  /**
   * ContributionData findMany
   */
  export type ContributionDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionData
     */
    select?: ContributionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionData
     */
    omit?: ContributionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDataInclude<ExtArgs> | null
    /**
     * Filter, which ContributionData to fetch.
     */
    where?: ContributionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContributionData to fetch.
     */
    orderBy?: ContributionDataOrderByWithRelationInput | ContributionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContributionData.
     */
    cursor?: ContributionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContributionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContributionData.
     */
    skip?: number
    distinct?: ContributionDataScalarFieldEnum | ContributionDataScalarFieldEnum[]
  }

  /**
   * ContributionData create
   */
  export type ContributionDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionData
     */
    select?: ContributionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionData
     */
    omit?: ContributionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDataInclude<ExtArgs> | null
    /**
     * The data needed to create a ContributionData.
     */
    data: XOR<ContributionDataCreateInput, ContributionDataUncheckedCreateInput>
  }

  /**
   * ContributionData createMany
   */
  export type ContributionDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContributionData.
     */
    data: ContributionDataCreateManyInput | ContributionDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContributionData createManyAndReturn
   */
  export type ContributionDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionData
     */
    select?: ContributionDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionData
     */
    omit?: ContributionDataOmit<ExtArgs> | null
    /**
     * The data used to create many ContributionData.
     */
    data: ContributionDataCreateManyInput | ContributionDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContributionData update
   */
  export type ContributionDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionData
     */
    select?: ContributionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionData
     */
    omit?: ContributionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDataInclude<ExtArgs> | null
    /**
     * The data needed to update a ContributionData.
     */
    data: XOR<ContributionDataUpdateInput, ContributionDataUncheckedUpdateInput>
    /**
     * Choose, which ContributionData to update.
     */
    where: ContributionDataWhereUniqueInput
  }

  /**
   * ContributionData updateMany
   */
  export type ContributionDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContributionData.
     */
    data: XOR<ContributionDataUpdateManyMutationInput, ContributionDataUncheckedUpdateManyInput>
    /**
     * Filter which ContributionData to update
     */
    where?: ContributionDataWhereInput
    /**
     * Limit how many ContributionData to update.
     */
    limit?: number
  }

  /**
   * ContributionData updateManyAndReturn
   */
  export type ContributionDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionData
     */
    select?: ContributionDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionData
     */
    omit?: ContributionDataOmit<ExtArgs> | null
    /**
     * The data used to update ContributionData.
     */
    data: XOR<ContributionDataUpdateManyMutationInput, ContributionDataUncheckedUpdateManyInput>
    /**
     * Filter which ContributionData to update
     */
    where?: ContributionDataWhereInput
    /**
     * Limit how many ContributionData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContributionData upsert
   */
  export type ContributionDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionData
     */
    select?: ContributionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionData
     */
    omit?: ContributionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDataInclude<ExtArgs> | null
    /**
     * The filter to search for the ContributionData to update in case it exists.
     */
    where: ContributionDataWhereUniqueInput
    /**
     * In case the ContributionData found by the `where` argument doesn't exist, create a new ContributionData with this data.
     */
    create: XOR<ContributionDataCreateInput, ContributionDataUncheckedCreateInput>
    /**
     * In case the ContributionData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContributionDataUpdateInput, ContributionDataUncheckedUpdateInput>
  }

  /**
   * ContributionData delete
   */
  export type ContributionDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionData
     */
    select?: ContributionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionData
     */
    omit?: ContributionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDataInclude<ExtArgs> | null
    /**
     * Filter which ContributionData to delete.
     */
    where: ContributionDataWhereUniqueInput
  }

  /**
   * ContributionData deleteMany
   */
  export type ContributionDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContributionData to delete
     */
    where?: ContributionDataWhereInput
    /**
     * Limit how many ContributionData to delete.
     */
    limit?: number
  }

  /**
   * ContributionData.days
   */
  export type ContributionData$daysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionDay
     */
    select?: ContributionDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionDay
     */
    omit?: ContributionDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDayInclude<ExtArgs> | null
    where?: ContributionDayWhereInput
    orderBy?: ContributionDayOrderByWithRelationInput | ContributionDayOrderByWithRelationInput[]
    cursor?: ContributionDayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContributionDayScalarFieldEnum | ContributionDayScalarFieldEnum[]
  }

  /**
   * ContributionData without action
   */
  export type ContributionDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionData
     */
    select?: ContributionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionData
     */
    omit?: ContributionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDataInclude<ExtArgs> | null
  }


  /**
   * Model ContributionDay
   */

  export type AggregateContributionDay = {
    _count: ContributionDayCountAggregateOutputType | null
    _avg: ContributionDayAvgAggregateOutputType | null
    _sum: ContributionDaySumAggregateOutputType | null
    _min: ContributionDayMinAggregateOutputType | null
    _max: ContributionDayMaxAggregateOutputType | null
  }

  export type ContributionDayAvgAggregateOutputType = {
    count: number | null
    level: number | null
  }

  export type ContributionDaySumAggregateOutputType = {
    count: number | null
    level: number | null
  }

  export type ContributionDayMinAggregateOutputType = {
    id: string | null
    contributionDataId: string | null
    date: Date | null
    count: number | null
    level: number | null
  }

  export type ContributionDayMaxAggregateOutputType = {
    id: string | null
    contributionDataId: string | null
    date: Date | null
    count: number | null
    level: number | null
  }

  export type ContributionDayCountAggregateOutputType = {
    id: number
    contributionDataId: number
    date: number
    count: number
    level: number
    _all: number
  }


  export type ContributionDayAvgAggregateInputType = {
    count?: true
    level?: true
  }

  export type ContributionDaySumAggregateInputType = {
    count?: true
    level?: true
  }

  export type ContributionDayMinAggregateInputType = {
    id?: true
    contributionDataId?: true
    date?: true
    count?: true
    level?: true
  }

  export type ContributionDayMaxAggregateInputType = {
    id?: true
    contributionDataId?: true
    date?: true
    count?: true
    level?: true
  }

  export type ContributionDayCountAggregateInputType = {
    id?: true
    contributionDataId?: true
    date?: true
    count?: true
    level?: true
    _all?: true
  }

  export type ContributionDayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContributionDay to aggregate.
     */
    where?: ContributionDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContributionDays to fetch.
     */
    orderBy?: ContributionDayOrderByWithRelationInput | ContributionDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContributionDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContributionDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContributionDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContributionDays
    **/
    _count?: true | ContributionDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContributionDayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContributionDaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContributionDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContributionDayMaxAggregateInputType
  }

  export type GetContributionDayAggregateType<T extends ContributionDayAggregateArgs> = {
        [P in keyof T & keyof AggregateContributionDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContributionDay[P]>
      : GetScalarType<T[P], AggregateContributionDay[P]>
  }




  export type ContributionDayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContributionDayWhereInput
    orderBy?: ContributionDayOrderByWithAggregationInput | ContributionDayOrderByWithAggregationInput[]
    by: ContributionDayScalarFieldEnum[] | ContributionDayScalarFieldEnum
    having?: ContributionDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContributionDayCountAggregateInputType | true
    _avg?: ContributionDayAvgAggregateInputType
    _sum?: ContributionDaySumAggregateInputType
    _min?: ContributionDayMinAggregateInputType
    _max?: ContributionDayMaxAggregateInputType
  }

  export type ContributionDayGroupByOutputType = {
    id: string
    contributionDataId: string
    date: Date
    count: number
    level: number
    _count: ContributionDayCountAggregateOutputType | null
    _avg: ContributionDayAvgAggregateOutputType | null
    _sum: ContributionDaySumAggregateOutputType | null
    _min: ContributionDayMinAggregateOutputType | null
    _max: ContributionDayMaxAggregateOutputType | null
  }

  type GetContributionDayGroupByPayload<T extends ContributionDayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContributionDayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContributionDayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContributionDayGroupByOutputType[P]>
            : GetScalarType<T[P], ContributionDayGroupByOutputType[P]>
        }
      >
    >


  export type ContributionDaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contributionDataId?: boolean
    date?: boolean
    count?: boolean
    level?: boolean
    contributionData?: boolean | ContributionDataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contributionDay"]>

  export type ContributionDaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contributionDataId?: boolean
    date?: boolean
    count?: boolean
    level?: boolean
    contributionData?: boolean | ContributionDataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contributionDay"]>

  export type ContributionDaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contributionDataId?: boolean
    date?: boolean
    count?: boolean
    level?: boolean
    contributionData?: boolean | ContributionDataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contributionDay"]>

  export type ContributionDaySelectScalar = {
    id?: boolean
    contributionDataId?: boolean
    date?: boolean
    count?: boolean
    level?: boolean
  }

  export type ContributionDayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contributionDataId" | "date" | "count" | "level", ExtArgs["result"]["contributionDay"]>
  export type ContributionDayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contributionData?: boolean | ContributionDataDefaultArgs<ExtArgs>
  }
  export type ContributionDayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contributionData?: boolean | ContributionDataDefaultArgs<ExtArgs>
  }
  export type ContributionDayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contributionData?: boolean | ContributionDataDefaultArgs<ExtArgs>
  }

  export type $ContributionDayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContributionDay"
    objects: {
      contributionData: Prisma.$ContributionDataPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contributionDataId: string
      date: Date
      count: number
      level: number
    }, ExtArgs["result"]["contributionDay"]>
    composites: {}
  }

  type ContributionDayGetPayload<S extends boolean | null | undefined | ContributionDayDefaultArgs> = $Result.GetResult<Prisma.$ContributionDayPayload, S>

  type ContributionDayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContributionDayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContributionDayCountAggregateInputType | true
    }

  export interface ContributionDayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContributionDay'], meta: { name: 'ContributionDay' } }
    /**
     * Find zero or one ContributionDay that matches the filter.
     * @param {ContributionDayFindUniqueArgs} args - Arguments to find a ContributionDay
     * @example
     * // Get one ContributionDay
     * const contributionDay = await prisma.contributionDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContributionDayFindUniqueArgs>(args: SelectSubset<T, ContributionDayFindUniqueArgs<ExtArgs>>): Prisma__ContributionDayClient<$Result.GetResult<Prisma.$ContributionDayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContributionDay that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContributionDayFindUniqueOrThrowArgs} args - Arguments to find a ContributionDay
     * @example
     * // Get one ContributionDay
     * const contributionDay = await prisma.contributionDay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContributionDayFindUniqueOrThrowArgs>(args: SelectSubset<T, ContributionDayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContributionDayClient<$Result.GetResult<Prisma.$ContributionDayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContributionDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContributionDayFindFirstArgs} args - Arguments to find a ContributionDay
     * @example
     * // Get one ContributionDay
     * const contributionDay = await prisma.contributionDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContributionDayFindFirstArgs>(args?: SelectSubset<T, ContributionDayFindFirstArgs<ExtArgs>>): Prisma__ContributionDayClient<$Result.GetResult<Prisma.$ContributionDayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContributionDay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContributionDayFindFirstOrThrowArgs} args - Arguments to find a ContributionDay
     * @example
     * // Get one ContributionDay
     * const contributionDay = await prisma.contributionDay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContributionDayFindFirstOrThrowArgs>(args?: SelectSubset<T, ContributionDayFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContributionDayClient<$Result.GetResult<Prisma.$ContributionDayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContributionDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContributionDayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContributionDays
     * const contributionDays = await prisma.contributionDay.findMany()
     * 
     * // Get first 10 ContributionDays
     * const contributionDays = await prisma.contributionDay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contributionDayWithIdOnly = await prisma.contributionDay.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContributionDayFindManyArgs>(args?: SelectSubset<T, ContributionDayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContributionDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContributionDay.
     * @param {ContributionDayCreateArgs} args - Arguments to create a ContributionDay.
     * @example
     * // Create one ContributionDay
     * const ContributionDay = await prisma.contributionDay.create({
     *   data: {
     *     // ... data to create a ContributionDay
     *   }
     * })
     * 
     */
    create<T extends ContributionDayCreateArgs>(args: SelectSubset<T, ContributionDayCreateArgs<ExtArgs>>): Prisma__ContributionDayClient<$Result.GetResult<Prisma.$ContributionDayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContributionDays.
     * @param {ContributionDayCreateManyArgs} args - Arguments to create many ContributionDays.
     * @example
     * // Create many ContributionDays
     * const contributionDay = await prisma.contributionDay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContributionDayCreateManyArgs>(args?: SelectSubset<T, ContributionDayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContributionDays and returns the data saved in the database.
     * @param {ContributionDayCreateManyAndReturnArgs} args - Arguments to create many ContributionDays.
     * @example
     * // Create many ContributionDays
     * const contributionDay = await prisma.contributionDay.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContributionDays and only return the `id`
     * const contributionDayWithIdOnly = await prisma.contributionDay.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContributionDayCreateManyAndReturnArgs>(args?: SelectSubset<T, ContributionDayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContributionDayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContributionDay.
     * @param {ContributionDayDeleteArgs} args - Arguments to delete one ContributionDay.
     * @example
     * // Delete one ContributionDay
     * const ContributionDay = await prisma.contributionDay.delete({
     *   where: {
     *     // ... filter to delete one ContributionDay
     *   }
     * })
     * 
     */
    delete<T extends ContributionDayDeleteArgs>(args: SelectSubset<T, ContributionDayDeleteArgs<ExtArgs>>): Prisma__ContributionDayClient<$Result.GetResult<Prisma.$ContributionDayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContributionDay.
     * @param {ContributionDayUpdateArgs} args - Arguments to update one ContributionDay.
     * @example
     * // Update one ContributionDay
     * const contributionDay = await prisma.contributionDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContributionDayUpdateArgs>(args: SelectSubset<T, ContributionDayUpdateArgs<ExtArgs>>): Prisma__ContributionDayClient<$Result.GetResult<Prisma.$ContributionDayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContributionDays.
     * @param {ContributionDayDeleteManyArgs} args - Arguments to filter ContributionDays to delete.
     * @example
     * // Delete a few ContributionDays
     * const { count } = await prisma.contributionDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContributionDayDeleteManyArgs>(args?: SelectSubset<T, ContributionDayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContributionDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContributionDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContributionDays
     * const contributionDay = await prisma.contributionDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContributionDayUpdateManyArgs>(args: SelectSubset<T, ContributionDayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContributionDays and returns the data updated in the database.
     * @param {ContributionDayUpdateManyAndReturnArgs} args - Arguments to update many ContributionDays.
     * @example
     * // Update many ContributionDays
     * const contributionDay = await prisma.contributionDay.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContributionDays and only return the `id`
     * const contributionDayWithIdOnly = await prisma.contributionDay.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContributionDayUpdateManyAndReturnArgs>(args: SelectSubset<T, ContributionDayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContributionDayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContributionDay.
     * @param {ContributionDayUpsertArgs} args - Arguments to update or create a ContributionDay.
     * @example
     * // Update or create a ContributionDay
     * const contributionDay = await prisma.contributionDay.upsert({
     *   create: {
     *     // ... data to create a ContributionDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContributionDay we want to update
     *   }
     * })
     */
    upsert<T extends ContributionDayUpsertArgs>(args: SelectSubset<T, ContributionDayUpsertArgs<ExtArgs>>): Prisma__ContributionDayClient<$Result.GetResult<Prisma.$ContributionDayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContributionDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContributionDayCountArgs} args - Arguments to filter ContributionDays to count.
     * @example
     * // Count the number of ContributionDays
     * const count = await prisma.contributionDay.count({
     *   where: {
     *     // ... the filter for the ContributionDays we want to count
     *   }
     * })
    **/
    count<T extends ContributionDayCountArgs>(
      args?: Subset<T, ContributionDayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContributionDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContributionDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContributionDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContributionDayAggregateArgs>(args: Subset<T, ContributionDayAggregateArgs>): Prisma.PrismaPromise<GetContributionDayAggregateType<T>>

    /**
     * Group by ContributionDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContributionDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContributionDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContributionDayGroupByArgs['orderBy'] }
        : { orderBy?: ContributionDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContributionDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContributionDayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContributionDay model
   */
  readonly fields: ContributionDayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContributionDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContributionDayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contributionData<T extends ContributionDataDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContributionDataDefaultArgs<ExtArgs>>): Prisma__ContributionDataClient<$Result.GetResult<Prisma.$ContributionDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContributionDay model
   */
  interface ContributionDayFieldRefs {
    readonly id: FieldRef<"ContributionDay", 'String'>
    readonly contributionDataId: FieldRef<"ContributionDay", 'String'>
    readonly date: FieldRef<"ContributionDay", 'DateTime'>
    readonly count: FieldRef<"ContributionDay", 'Int'>
    readonly level: FieldRef<"ContributionDay", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContributionDay findUnique
   */
  export type ContributionDayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionDay
     */
    select?: ContributionDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionDay
     */
    omit?: ContributionDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDayInclude<ExtArgs> | null
    /**
     * Filter, which ContributionDay to fetch.
     */
    where: ContributionDayWhereUniqueInput
  }

  /**
   * ContributionDay findUniqueOrThrow
   */
  export type ContributionDayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionDay
     */
    select?: ContributionDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionDay
     */
    omit?: ContributionDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDayInclude<ExtArgs> | null
    /**
     * Filter, which ContributionDay to fetch.
     */
    where: ContributionDayWhereUniqueInput
  }

  /**
   * ContributionDay findFirst
   */
  export type ContributionDayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionDay
     */
    select?: ContributionDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionDay
     */
    omit?: ContributionDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDayInclude<ExtArgs> | null
    /**
     * Filter, which ContributionDay to fetch.
     */
    where?: ContributionDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContributionDays to fetch.
     */
    orderBy?: ContributionDayOrderByWithRelationInput | ContributionDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContributionDays.
     */
    cursor?: ContributionDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContributionDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContributionDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContributionDays.
     */
    distinct?: ContributionDayScalarFieldEnum | ContributionDayScalarFieldEnum[]
  }

  /**
   * ContributionDay findFirstOrThrow
   */
  export type ContributionDayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionDay
     */
    select?: ContributionDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionDay
     */
    omit?: ContributionDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDayInclude<ExtArgs> | null
    /**
     * Filter, which ContributionDay to fetch.
     */
    where?: ContributionDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContributionDays to fetch.
     */
    orderBy?: ContributionDayOrderByWithRelationInput | ContributionDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContributionDays.
     */
    cursor?: ContributionDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContributionDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContributionDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContributionDays.
     */
    distinct?: ContributionDayScalarFieldEnum | ContributionDayScalarFieldEnum[]
  }

  /**
   * ContributionDay findMany
   */
  export type ContributionDayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionDay
     */
    select?: ContributionDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionDay
     */
    omit?: ContributionDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDayInclude<ExtArgs> | null
    /**
     * Filter, which ContributionDays to fetch.
     */
    where?: ContributionDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContributionDays to fetch.
     */
    orderBy?: ContributionDayOrderByWithRelationInput | ContributionDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContributionDays.
     */
    cursor?: ContributionDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContributionDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContributionDays.
     */
    skip?: number
    distinct?: ContributionDayScalarFieldEnum | ContributionDayScalarFieldEnum[]
  }

  /**
   * ContributionDay create
   */
  export type ContributionDayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionDay
     */
    select?: ContributionDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionDay
     */
    omit?: ContributionDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDayInclude<ExtArgs> | null
    /**
     * The data needed to create a ContributionDay.
     */
    data: XOR<ContributionDayCreateInput, ContributionDayUncheckedCreateInput>
  }

  /**
   * ContributionDay createMany
   */
  export type ContributionDayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContributionDays.
     */
    data: ContributionDayCreateManyInput | ContributionDayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContributionDay createManyAndReturn
   */
  export type ContributionDayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionDay
     */
    select?: ContributionDaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionDay
     */
    omit?: ContributionDayOmit<ExtArgs> | null
    /**
     * The data used to create many ContributionDays.
     */
    data: ContributionDayCreateManyInput | ContributionDayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContributionDay update
   */
  export type ContributionDayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionDay
     */
    select?: ContributionDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionDay
     */
    omit?: ContributionDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDayInclude<ExtArgs> | null
    /**
     * The data needed to update a ContributionDay.
     */
    data: XOR<ContributionDayUpdateInput, ContributionDayUncheckedUpdateInput>
    /**
     * Choose, which ContributionDay to update.
     */
    where: ContributionDayWhereUniqueInput
  }

  /**
   * ContributionDay updateMany
   */
  export type ContributionDayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContributionDays.
     */
    data: XOR<ContributionDayUpdateManyMutationInput, ContributionDayUncheckedUpdateManyInput>
    /**
     * Filter which ContributionDays to update
     */
    where?: ContributionDayWhereInput
    /**
     * Limit how many ContributionDays to update.
     */
    limit?: number
  }

  /**
   * ContributionDay updateManyAndReturn
   */
  export type ContributionDayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionDay
     */
    select?: ContributionDaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionDay
     */
    omit?: ContributionDayOmit<ExtArgs> | null
    /**
     * The data used to update ContributionDays.
     */
    data: XOR<ContributionDayUpdateManyMutationInput, ContributionDayUncheckedUpdateManyInput>
    /**
     * Filter which ContributionDays to update
     */
    where?: ContributionDayWhereInput
    /**
     * Limit how many ContributionDays to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContributionDay upsert
   */
  export type ContributionDayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionDay
     */
    select?: ContributionDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionDay
     */
    omit?: ContributionDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDayInclude<ExtArgs> | null
    /**
     * The filter to search for the ContributionDay to update in case it exists.
     */
    where: ContributionDayWhereUniqueInput
    /**
     * In case the ContributionDay found by the `where` argument doesn't exist, create a new ContributionDay with this data.
     */
    create: XOR<ContributionDayCreateInput, ContributionDayUncheckedCreateInput>
    /**
     * In case the ContributionDay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContributionDayUpdateInput, ContributionDayUncheckedUpdateInput>
  }

  /**
   * ContributionDay delete
   */
  export type ContributionDayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionDay
     */
    select?: ContributionDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionDay
     */
    omit?: ContributionDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDayInclude<ExtArgs> | null
    /**
     * Filter which ContributionDay to delete.
     */
    where: ContributionDayWhereUniqueInput
  }

  /**
   * ContributionDay deleteMany
   */
  export type ContributionDayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContributionDays to delete
     */
    where?: ContributionDayWhereInput
    /**
     * Limit how many ContributionDays to delete.
     */
    limit?: number
  }

  /**
   * ContributionDay without action
   */
  export type ContributionDayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContributionDay
     */
    select?: ContributionDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContributionDay
     */
    omit?: ContributionDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContributionDayInclude<ExtArgs> | null
  }


  /**
   * Model TimelineEvent
   */

  export type AggregateTimelineEvent = {
    _count: TimelineEventCountAggregateOutputType | null
    _min: TimelineEventMinAggregateOutputType | null
    _max: TimelineEventMaxAggregateOutputType | null
  }

  export type TimelineEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    type: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    icon: string | null
    color: string | null
  }

  export type TimelineEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    type: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    icon: string | null
    color: string | null
  }

  export type TimelineEventCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    type: number
    title: number
    subtitle: number
    description: number
    icon: number
    color: number
    _all: number
  }


  export type TimelineEventMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    type?: true
    title?: true
    subtitle?: true
    description?: true
    icon?: true
    color?: true
  }

  export type TimelineEventMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    type?: true
    title?: true
    subtitle?: true
    description?: true
    icon?: true
    color?: true
  }

  export type TimelineEventCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    type?: true
    title?: true
    subtitle?: true
    description?: true
    icon?: true
    color?: true
    _all?: true
  }

  export type TimelineEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimelineEvent to aggregate.
     */
    where?: TimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineEvents to fetch.
     */
    orderBy?: TimelineEventOrderByWithRelationInput | TimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimelineEvents
    **/
    _count?: true | TimelineEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimelineEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimelineEventMaxAggregateInputType
  }

  export type GetTimelineEventAggregateType<T extends TimelineEventAggregateArgs> = {
        [P in keyof T & keyof AggregateTimelineEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimelineEvent[P]>
      : GetScalarType<T[P], AggregateTimelineEvent[P]>
  }




  export type TimelineEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimelineEventWhereInput
    orderBy?: TimelineEventOrderByWithAggregationInput | TimelineEventOrderByWithAggregationInput[]
    by: TimelineEventScalarFieldEnum[] | TimelineEventScalarFieldEnum
    having?: TimelineEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimelineEventCountAggregateInputType | true
    _min?: TimelineEventMinAggregateInputType
    _max?: TimelineEventMaxAggregateInputType
  }

  export type TimelineEventGroupByOutputType = {
    id: string
    userId: string
    date: Date
    type: string
    title: string
    subtitle: string | null
    description: string | null
    icon: string | null
    color: string | null
    _count: TimelineEventCountAggregateOutputType | null
    _min: TimelineEventMinAggregateOutputType | null
    _max: TimelineEventMaxAggregateOutputType | null
  }

  type GetTimelineEventGroupByPayload<T extends TimelineEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimelineEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimelineEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimelineEventGroupByOutputType[P]>
            : GetScalarType<T[P], TimelineEventGroupByOutputType[P]>
        }
      >
    >


  export type TimelineEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    type?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timelineEvent"]>

  export type TimelineEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    type?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timelineEvent"]>

  export type TimelineEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    type?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timelineEvent"]>

  export type TimelineEventSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    type?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
  }

  export type TimelineEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "type" | "title" | "subtitle" | "description" | "icon" | "color", ExtArgs["result"]["timelineEvent"]>
  export type TimelineEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TimelineEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TimelineEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TimelineEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimelineEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      type: string
      title: string
      subtitle: string | null
      description: string | null
      icon: string | null
      color: string | null
    }, ExtArgs["result"]["timelineEvent"]>
    composites: {}
  }

  type TimelineEventGetPayload<S extends boolean | null | undefined | TimelineEventDefaultArgs> = $Result.GetResult<Prisma.$TimelineEventPayload, S>

  type TimelineEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimelineEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimelineEventCountAggregateInputType | true
    }

  export interface TimelineEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimelineEvent'], meta: { name: 'TimelineEvent' } }
    /**
     * Find zero or one TimelineEvent that matches the filter.
     * @param {TimelineEventFindUniqueArgs} args - Arguments to find a TimelineEvent
     * @example
     * // Get one TimelineEvent
     * const timelineEvent = await prisma.timelineEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimelineEventFindUniqueArgs>(args: SelectSubset<T, TimelineEventFindUniqueArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimelineEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimelineEventFindUniqueOrThrowArgs} args - Arguments to find a TimelineEvent
     * @example
     * // Get one TimelineEvent
     * const timelineEvent = await prisma.timelineEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimelineEventFindUniqueOrThrowArgs>(args: SelectSubset<T, TimelineEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimelineEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineEventFindFirstArgs} args - Arguments to find a TimelineEvent
     * @example
     * // Get one TimelineEvent
     * const timelineEvent = await prisma.timelineEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimelineEventFindFirstArgs>(args?: SelectSubset<T, TimelineEventFindFirstArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimelineEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineEventFindFirstOrThrowArgs} args - Arguments to find a TimelineEvent
     * @example
     * // Get one TimelineEvent
     * const timelineEvent = await prisma.timelineEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimelineEventFindFirstOrThrowArgs>(args?: SelectSubset<T, TimelineEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimelineEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimelineEvents
     * const timelineEvents = await prisma.timelineEvent.findMany()
     * 
     * // Get first 10 TimelineEvents
     * const timelineEvents = await prisma.timelineEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timelineEventWithIdOnly = await prisma.timelineEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimelineEventFindManyArgs>(args?: SelectSubset<T, TimelineEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimelineEvent.
     * @param {TimelineEventCreateArgs} args - Arguments to create a TimelineEvent.
     * @example
     * // Create one TimelineEvent
     * const TimelineEvent = await prisma.timelineEvent.create({
     *   data: {
     *     // ... data to create a TimelineEvent
     *   }
     * })
     * 
     */
    create<T extends TimelineEventCreateArgs>(args: SelectSubset<T, TimelineEventCreateArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimelineEvents.
     * @param {TimelineEventCreateManyArgs} args - Arguments to create many TimelineEvents.
     * @example
     * // Create many TimelineEvents
     * const timelineEvent = await prisma.timelineEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimelineEventCreateManyArgs>(args?: SelectSubset<T, TimelineEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimelineEvents and returns the data saved in the database.
     * @param {TimelineEventCreateManyAndReturnArgs} args - Arguments to create many TimelineEvents.
     * @example
     * // Create many TimelineEvents
     * const timelineEvent = await prisma.timelineEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimelineEvents and only return the `id`
     * const timelineEventWithIdOnly = await prisma.timelineEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimelineEventCreateManyAndReturnArgs>(args?: SelectSubset<T, TimelineEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimelineEvent.
     * @param {TimelineEventDeleteArgs} args - Arguments to delete one TimelineEvent.
     * @example
     * // Delete one TimelineEvent
     * const TimelineEvent = await prisma.timelineEvent.delete({
     *   where: {
     *     // ... filter to delete one TimelineEvent
     *   }
     * })
     * 
     */
    delete<T extends TimelineEventDeleteArgs>(args: SelectSubset<T, TimelineEventDeleteArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimelineEvent.
     * @param {TimelineEventUpdateArgs} args - Arguments to update one TimelineEvent.
     * @example
     * // Update one TimelineEvent
     * const timelineEvent = await prisma.timelineEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimelineEventUpdateArgs>(args: SelectSubset<T, TimelineEventUpdateArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimelineEvents.
     * @param {TimelineEventDeleteManyArgs} args - Arguments to filter TimelineEvents to delete.
     * @example
     * // Delete a few TimelineEvents
     * const { count } = await prisma.timelineEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimelineEventDeleteManyArgs>(args?: SelectSubset<T, TimelineEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimelineEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimelineEvents
     * const timelineEvent = await prisma.timelineEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimelineEventUpdateManyArgs>(args: SelectSubset<T, TimelineEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimelineEvents and returns the data updated in the database.
     * @param {TimelineEventUpdateManyAndReturnArgs} args - Arguments to update many TimelineEvents.
     * @example
     * // Update many TimelineEvents
     * const timelineEvent = await prisma.timelineEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimelineEvents and only return the `id`
     * const timelineEventWithIdOnly = await prisma.timelineEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimelineEventUpdateManyAndReturnArgs>(args: SelectSubset<T, TimelineEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimelineEvent.
     * @param {TimelineEventUpsertArgs} args - Arguments to update or create a TimelineEvent.
     * @example
     * // Update or create a TimelineEvent
     * const timelineEvent = await prisma.timelineEvent.upsert({
     *   create: {
     *     // ... data to create a TimelineEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimelineEvent we want to update
     *   }
     * })
     */
    upsert<T extends TimelineEventUpsertArgs>(args: SelectSubset<T, TimelineEventUpsertArgs<ExtArgs>>): Prisma__TimelineEventClient<$Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimelineEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineEventCountArgs} args - Arguments to filter TimelineEvents to count.
     * @example
     * // Count the number of TimelineEvents
     * const count = await prisma.timelineEvent.count({
     *   where: {
     *     // ... the filter for the TimelineEvents we want to count
     *   }
     * })
    **/
    count<T extends TimelineEventCountArgs>(
      args?: Subset<T, TimelineEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimelineEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimelineEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimelineEventAggregateArgs>(args: Subset<T, TimelineEventAggregateArgs>): Prisma.PrismaPromise<GetTimelineEventAggregateType<T>>

    /**
     * Group by TimelineEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimelineEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimelineEventGroupByArgs['orderBy'] }
        : { orderBy?: TimelineEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimelineEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimelineEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimelineEvent model
   */
  readonly fields: TimelineEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimelineEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimelineEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimelineEvent model
   */
  interface TimelineEventFieldRefs {
    readonly id: FieldRef<"TimelineEvent", 'String'>
    readonly userId: FieldRef<"TimelineEvent", 'String'>
    readonly date: FieldRef<"TimelineEvent", 'DateTime'>
    readonly type: FieldRef<"TimelineEvent", 'String'>
    readonly title: FieldRef<"TimelineEvent", 'String'>
    readonly subtitle: FieldRef<"TimelineEvent", 'String'>
    readonly description: FieldRef<"TimelineEvent", 'String'>
    readonly icon: FieldRef<"TimelineEvent", 'String'>
    readonly color: FieldRef<"TimelineEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TimelineEvent findUnique
   */
  export type TimelineEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineEvent
     */
    omit?: TimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TimelineEvent to fetch.
     */
    where: TimelineEventWhereUniqueInput
  }

  /**
   * TimelineEvent findUniqueOrThrow
   */
  export type TimelineEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineEvent
     */
    omit?: TimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TimelineEvent to fetch.
     */
    where: TimelineEventWhereUniqueInput
  }

  /**
   * TimelineEvent findFirst
   */
  export type TimelineEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineEvent
     */
    omit?: TimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TimelineEvent to fetch.
     */
    where?: TimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineEvents to fetch.
     */
    orderBy?: TimelineEventOrderByWithRelationInput | TimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimelineEvents.
     */
    cursor?: TimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimelineEvents.
     */
    distinct?: TimelineEventScalarFieldEnum | TimelineEventScalarFieldEnum[]
  }

  /**
   * TimelineEvent findFirstOrThrow
   */
  export type TimelineEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineEvent
     */
    omit?: TimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TimelineEvent to fetch.
     */
    where?: TimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineEvents to fetch.
     */
    orderBy?: TimelineEventOrderByWithRelationInput | TimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimelineEvents.
     */
    cursor?: TimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimelineEvents.
     */
    distinct?: TimelineEventScalarFieldEnum | TimelineEventScalarFieldEnum[]
  }

  /**
   * TimelineEvent findMany
   */
  export type TimelineEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineEvent
     */
    omit?: TimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TimelineEvents to fetch.
     */
    where?: TimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineEvents to fetch.
     */
    orderBy?: TimelineEventOrderByWithRelationInput | TimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimelineEvents.
     */
    cursor?: TimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineEvents.
     */
    skip?: number
    distinct?: TimelineEventScalarFieldEnum | TimelineEventScalarFieldEnum[]
  }

  /**
   * TimelineEvent create
   */
  export type TimelineEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineEvent
     */
    omit?: TimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * The data needed to create a TimelineEvent.
     */
    data: XOR<TimelineEventCreateInput, TimelineEventUncheckedCreateInput>
  }

  /**
   * TimelineEvent createMany
   */
  export type TimelineEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimelineEvents.
     */
    data: TimelineEventCreateManyInput | TimelineEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimelineEvent createManyAndReturn
   */
  export type TimelineEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineEvent
     */
    omit?: TimelineEventOmit<ExtArgs> | null
    /**
     * The data used to create many TimelineEvents.
     */
    data: TimelineEventCreateManyInput | TimelineEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimelineEvent update
   */
  export type TimelineEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineEvent
     */
    omit?: TimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * The data needed to update a TimelineEvent.
     */
    data: XOR<TimelineEventUpdateInput, TimelineEventUncheckedUpdateInput>
    /**
     * Choose, which TimelineEvent to update.
     */
    where: TimelineEventWhereUniqueInput
  }

  /**
   * TimelineEvent updateMany
   */
  export type TimelineEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimelineEvents.
     */
    data: XOR<TimelineEventUpdateManyMutationInput, TimelineEventUncheckedUpdateManyInput>
    /**
     * Filter which TimelineEvents to update
     */
    where?: TimelineEventWhereInput
    /**
     * Limit how many TimelineEvents to update.
     */
    limit?: number
  }

  /**
   * TimelineEvent updateManyAndReturn
   */
  export type TimelineEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineEvent
     */
    omit?: TimelineEventOmit<ExtArgs> | null
    /**
     * The data used to update TimelineEvents.
     */
    data: XOR<TimelineEventUpdateManyMutationInput, TimelineEventUncheckedUpdateManyInput>
    /**
     * Filter which TimelineEvents to update
     */
    where?: TimelineEventWhereInput
    /**
     * Limit how many TimelineEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimelineEvent upsert
   */
  export type TimelineEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineEvent
     */
    omit?: TimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * The filter to search for the TimelineEvent to update in case it exists.
     */
    where: TimelineEventWhereUniqueInput
    /**
     * In case the TimelineEvent found by the `where` argument doesn't exist, create a new TimelineEvent with this data.
     */
    create: XOR<TimelineEventCreateInput, TimelineEventUncheckedCreateInput>
    /**
     * In case the TimelineEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimelineEventUpdateInput, TimelineEventUncheckedUpdateInput>
  }

  /**
   * TimelineEvent delete
   */
  export type TimelineEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineEvent
     */
    omit?: TimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
    /**
     * Filter which TimelineEvent to delete.
     */
    where: TimelineEventWhereUniqueInput
  }

  /**
   * TimelineEvent deleteMany
   */
  export type TimelineEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimelineEvents to delete
     */
    where?: TimelineEventWhereInput
    /**
     * Limit how many TimelineEvents to delete.
     */
    limit?: number
  }

  /**
   * TimelineEvent without action
   */
  export type TimelineEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineEvent
     */
    select?: TimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineEvent
     */
    omit?: TimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineEventInclude<ExtArgs> | null
  }


  /**
   * Model ProjectTestimonial
   */

  export type AggregateProjectTestimonial = {
    _count: ProjectTestimonialCountAggregateOutputType | null
    _min: ProjectTestimonialMinAggregateOutputType | null
    _max: ProjectTestimonialMaxAggregateOutputType | null
  }

  export type ProjectTestimonialMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    testimonialId: string | null
  }

  export type ProjectTestimonialMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    testimonialId: string | null
  }

  export type ProjectTestimonialCountAggregateOutputType = {
    id: number
    projectId: number
    testimonialId: number
    _all: number
  }


  export type ProjectTestimonialMinAggregateInputType = {
    id?: true
    projectId?: true
    testimonialId?: true
  }

  export type ProjectTestimonialMaxAggregateInputType = {
    id?: true
    projectId?: true
    testimonialId?: true
  }

  export type ProjectTestimonialCountAggregateInputType = {
    id?: true
    projectId?: true
    testimonialId?: true
    _all?: true
  }

  export type ProjectTestimonialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTestimonial to aggregate.
     */
    where?: ProjectTestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTestimonials to fetch.
     */
    orderBy?: ProjectTestimonialOrderByWithRelationInput | ProjectTestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectTestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTestimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTestimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTestimonials
    **/
    _count?: true | ProjectTestimonialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTestimonialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTestimonialMaxAggregateInputType
  }

  export type GetProjectTestimonialAggregateType<T extends ProjectTestimonialAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectTestimonial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectTestimonial[P]>
      : GetScalarType<T[P], AggregateProjectTestimonial[P]>
  }




  export type ProjectTestimonialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTestimonialWhereInput
    orderBy?: ProjectTestimonialOrderByWithAggregationInput | ProjectTestimonialOrderByWithAggregationInput[]
    by: ProjectTestimonialScalarFieldEnum[] | ProjectTestimonialScalarFieldEnum
    having?: ProjectTestimonialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTestimonialCountAggregateInputType | true
    _min?: ProjectTestimonialMinAggregateInputType
    _max?: ProjectTestimonialMaxAggregateInputType
  }

  export type ProjectTestimonialGroupByOutputType = {
    id: string
    projectId: string
    testimonialId: string
    _count: ProjectTestimonialCountAggregateOutputType | null
    _min: ProjectTestimonialMinAggregateOutputType | null
    _max: ProjectTestimonialMaxAggregateOutputType | null
  }

  type GetProjectTestimonialGroupByPayload<T extends ProjectTestimonialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectTestimonialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectTestimonialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectTestimonialGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectTestimonialGroupByOutputType[P]>
        }
      >
    >


  export type ProjectTestimonialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    testimonialId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    testimonial?: boolean | TestimonialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectTestimonial"]>

  export type ProjectTestimonialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    testimonialId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    testimonial?: boolean | TestimonialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectTestimonial"]>

  export type ProjectTestimonialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    testimonialId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    testimonial?: boolean | TestimonialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectTestimonial"]>

  export type ProjectTestimonialSelectScalar = {
    id?: boolean
    projectId?: boolean
    testimonialId?: boolean
  }

  export type ProjectTestimonialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "testimonialId", ExtArgs["result"]["projectTestimonial"]>
  export type ProjectTestimonialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    testimonial?: boolean | TestimonialDefaultArgs<ExtArgs>
  }
  export type ProjectTestimonialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    testimonial?: boolean | TestimonialDefaultArgs<ExtArgs>
  }
  export type ProjectTestimonialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    testimonial?: boolean | TestimonialDefaultArgs<ExtArgs>
  }

  export type $ProjectTestimonialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectTestimonial"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      testimonial: Prisma.$TestimonialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      testimonialId: string
    }, ExtArgs["result"]["projectTestimonial"]>
    composites: {}
  }

  type ProjectTestimonialGetPayload<S extends boolean | null | undefined | ProjectTestimonialDefaultArgs> = $Result.GetResult<Prisma.$ProjectTestimonialPayload, S>

  type ProjectTestimonialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectTestimonialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectTestimonialCountAggregateInputType | true
    }

  export interface ProjectTestimonialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectTestimonial'], meta: { name: 'ProjectTestimonial' } }
    /**
     * Find zero or one ProjectTestimonial that matches the filter.
     * @param {ProjectTestimonialFindUniqueArgs} args - Arguments to find a ProjectTestimonial
     * @example
     * // Get one ProjectTestimonial
     * const projectTestimonial = await prisma.projectTestimonial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectTestimonialFindUniqueArgs>(args: SelectSubset<T, ProjectTestimonialFindUniqueArgs<ExtArgs>>): Prisma__ProjectTestimonialClient<$Result.GetResult<Prisma.$ProjectTestimonialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectTestimonial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectTestimonialFindUniqueOrThrowArgs} args - Arguments to find a ProjectTestimonial
     * @example
     * // Get one ProjectTestimonial
     * const projectTestimonial = await prisma.projectTestimonial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectTestimonialFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectTestimonialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectTestimonialClient<$Result.GetResult<Prisma.$ProjectTestimonialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectTestimonial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTestimonialFindFirstArgs} args - Arguments to find a ProjectTestimonial
     * @example
     * // Get one ProjectTestimonial
     * const projectTestimonial = await prisma.projectTestimonial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectTestimonialFindFirstArgs>(args?: SelectSubset<T, ProjectTestimonialFindFirstArgs<ExtArgs>>): Prisma__ProjectTestimonialClient<$Result.GetResult<Prisma.$ProjectTestimonialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectTestimonial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTestimonialFindFirstOrThrowArgs} args - Arguments to find a ProjectTestimonial
     * @example
     * // Get one ProjectTestimonial
     * const projectTestimonial = await prisma.projectTestimonial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectTestimonialFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectTestimonialFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectTestimonialClient<$Result.GetResult<Prisma.$ProjectTestimonialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectTestimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTestimonialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTestimonials
     * const projectTestimonials = await prisma.projectTestimonial.findMany()
     * 
     * // Get first 10 ProjectTestimonials
     * const projectTestimonials = await prisma.projectTestimonial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectTestimonialWithIdOnly = await prisma.projectTestimonial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectTestimonialFindManyArgs>(args?: SelectSubset<T, ProjectTestimonialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTestimonialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectTestimonial.
     * @param {ProjectTestimonialCreateArgs} args - Arguments to create a ProjectTestimonial.
     * @example
     * // Create one ProjectTestimonial
     * const ProjectTestimonial = await prisma.projectTestimonial.create({
     *   data: {
     *     // ... data to create a ProjectTestimonial
     *   }
     * })
     * 
     */
    create<T extends ProjectTestimonialCreateArgs>(args: SelectSubset<T, ProjectTestimonialCreateArgs<ExtArgs>>): Prisma__ProjectTestimonialClient<$Result.GetResult<Prisma.$ProjectTestimonialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectTestimonials.
     * @param {ProjectTestimonialCreateManyArgs} args - Arguments to create many ProjectTestimonials.
     * @example
     * // Create many ProjectTestimonials
     * const projectTestimonial = await prisma.projectTestimonial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectTestimonialCreateManyArgs>(args?: SelectSubset<T, ProjectTestimonialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectTestimonials and returns the data saved in the database.
     * @param {ProjectTestimonialCreateManyAndReturnArgs} args - Arguments to create many ProjectTestimonials.
     * @example
     * // Create many ProjectTestimonials
     * const projectTestimonial = await prisma.projectTestimonial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectTestimonials and only return the `id`
     * const projectTestimonialWithIdOnly = await prisma.projectTestimonial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectTestimonialCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectTestimonialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTestimonialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectTestimonial.
     * @param {ProjectTestimonialDeleteArgs} args - Arguments to delete one ProjectTestimonial.
     * @example
     * // Delete one ProjectTestimonial
     * const ProjectTestimonial = await prisma.projectTestimonial.delete({
     *   where: {
     *     // ... filter to delete one ProjectTestimonial
     *   }
     * })
     * 
     */
    delete<T extends ProjectTestimonialDeleteArgs>(args: SelectSubset<T, ProjectTestimonialDeleteArgs<ExtArgs>>): Prisma__ProjectTestimonialClient<$Result.GetResult<Prisma.$ProjectTestimonialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectTestimonial.
     * @param {ProjectTestimonialUpdateArgs} args - Arguments to update one ProjectTestimonial.
     * @example
     * // Update one ProjectTestimonial
     * const projectTestimonial = await prisma.projectTestimonial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectTestimonialUpdateArgs>(args: SelectSubset<T, ProjectTestimonialUpdateArgs<ExtArgs>>): Prisma__ProjectTestimonialClient<$Result.GetResult<Prisma.$ProjectTestimonialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectTestimonials.
     * @param {ProjectTestimonialDeleteManyArgs} args - Arguments to filter ProjectTestimonials to delete.
     * @example
     * // Delete a few ProjectTestimonials
     * const { count } = await prisma.projectTestimonial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectTestimonialDeleteManyArgs>(args?: SelectSubset<T, ProjectTestimonialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTestimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTestimonialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTestimonials
     * const projectTestimonial = await prisma.projectTestimonial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectTestimonialUpdateManyArgs>(args: SelectSubset<T, ProjectTestimonialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTestimonials and returns the data updated in the database.
     * @param {ProjectTestimonialUpdateManyAndReturnArgs} args - Arguments to update many ProjectTestimonials.
     * @example
     * // Update many ProjectTestimonials
     * const projectTestimonial = await prisma.projectTestimonial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectTestimonials and only return the `id`
     * const projectTestimonialWithIdOnly = await prisma.projectTestimonial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectTestimonialUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectTestimonialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTestimonialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectTestimonial.
     * @param {ProjectTestimonialUpsertArgs} args - Arguments to update or create a ProjectTestimonial.
     * @example
     * // Update or create a ProjectTestimonial
     * const projectTestimonial = await prisma.projectTestimonial.upsert({
     *   create: {
     *     // ... data to create a ProjectTestimonial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectTestimonial we want to update
     *   }
     * })
     */
    upsert<T extends ProjectTestimonialUpsertArgs>(args: SelectSubset<T, ProjectTestimonialUpsertArgs<ExtArgs>>): Prisma__ProjectTestimonialClient<$Result.GetResult<Prisma.$ProjectTestimonialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectTestimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTestimonialCountArgs} args - Arguments to filter ProjectTestimonials to count.
     * @example
     * // Count the number of ProjectTestimonials
     * const count = await prisma.projectTestimonial.count({
     *   where: {
     *     // ... the filter for the ProjectTestimonials we want to count
     *   }
     * })
    **/
    count<T extends ProjectTestimonialCountArgs>(
      args?: Subset<T, ProjectTestimonialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTestimonialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectTestimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTestimonialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTestimonialAggregateArgs>(args: Subset<T, ProjectTestimonialAggregateArgs>): Prisma.PrismaPromise<GetProjectTestimonialAggregateType<T>>

    /**
     * Group by ProjectTestimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTestimonialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectTestimonialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectTestimonialGroupByArgs['orderBy'] }
        : { orderBy?: ProjectTestimonialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectTestimonialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTestimonialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectTestimonial model
   */
  readonly fields: ProjectTestimonialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectTestimonial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectTestimonialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    testimonial<T extends TestimonialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestimonialDefaultArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectTestimonial model
   */
  interface ProjectTestimonialFieldRefs {
    readonly id: FieldRef<"ProjectTestimonial", 'String'>
    readonly projectId: FieldRef<"ProjectTestimonial", 'String'>
    readonly testimonialId: FieldRef<"ProjectTestimonial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectTestimonial findUnique
   */
  export type ProjectTestimonialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTestimonial
     */
    select?: ProjectTestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTestimonial
     */
    omit?: ProjectTestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTestimonialInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTestimonial to fetch.
     */
    where: ProjectTestimonialWhereUniqueInput
  }

  /**
   * ProjectTestimonial findUniqueOrThrow
   */
  export type ProjectTestimonialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTestimonial
     */
    select?: ProjectTestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTestimonial
     */
    omit?: ProjectTestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTestimonialInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTestimonial to fetch.
     */
    where: ProjectTestimonialWhereUniqueInput
  }

  /**
   * ProjectTestimonial findFirst
   */
  export type ProjectTestimonialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTestimonial
     */
    select?: ProjectTestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTestimonial
     */
    omit?: ProjectTestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTestimonialInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTestimonial to fetch.
     */
    where?: ProjectTestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTestimonials to fetch.
     */
    orderBy?: ProjectTestimonialOrderByWithRelationInput | ProjectTestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTestimonials.
     */
    cursor?: ProjectTestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTestimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTestimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTestimonials.
     */
    distinct?: ProjectTestimonialScalarFieldEnum | ProjectTestimonialScalarFieldEnum[]
  }

  /**
   * ProjectTestimonial findFirstOrThrow
   */
  export type ProjectTestimonialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTestimonial
     */
    select?: ProjectTestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTestimonial
     */
    omit?: ProjectTestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTestimonialInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTestimonial to fetch.
     */
    where?: ProjectTestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTestimonials to fetch.
     */
    orderBy?: ProjectTestimonialOrderByWithRelationInput | ProjectTestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTestimonials.
     */
    cursor?: ProjectTestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTestimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTestimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTestimonials.
     */
    distinct?: ProjectTestimonialScalarFieldEnum | ProjectTestimonialScalarFieldEnum[]
  }

  /**
   * ProjectTestimonial findMany
   */
  export type ProjectTestimonialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTestimonial
     */
    select?: ProjectTestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTestimonial
     */
    omit?: ProjectTestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTestimonialInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTestimonials to fetch.
     */
    where?: ProjectTestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTestimonials to fetch.
     */
    orderBy?: ProjectTestimonialOrderByWithRelationInput | ProjectTestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTestimonials.
     */
    cursor?: ProjectTestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTestimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTestimonials.
     */
    skip?: number
    distinct?: ProjectTestimonialScalarFieldEnum | ProjectTestimonialScalarFieldEnum[]
  }

  /**
   * ProjectTestimonial create
   */
  export type ProjectTestimonialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTestimonial
     */
    select?: ProjectTestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTestimonial
     */
    omit?: ProjectTestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTestimonialInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectTestimonial.
     */
    data: XOR<ProjectTestimonialCreateInput, ProjectTestimonialUncheckedCreateInput>
  }

  /**
   * ProjectTestimonial createMany
   */
  export type ProjectTestimonialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectTestimonials.
     */
    data: ProjectTestimonialCreateManyInput | ProjectTestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectTestimonial createManyAndReturn
   */
  export type ProjectTestimonialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTestimonial
     */
    select?: ProjectTestimonialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTestimonial
     */
    omit?: ProjectTestimonialOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectTestimonials.
     */
    data: ProjectTestimonialCreateManyInput | ProjectTestimonialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTestimonialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectTestimonial update
   */
  export type ProjectTestimonialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTestimonial
     */
    select?: ProjectTestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTestimonial
     */
    omit?: ProjectTestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTestimonialInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectTestimonial.
     */
    data: XOR<ProjectTestimonialUpdateInput, ProjectTestimonialUncheckedUpdateInput>
    /**
     * Choose, which ProjectTestimonial to update.
     */
    where: ProjectTestimonialWhereUniqueInput
  }

  /**
   * ProjectTestimonial updateMany
   */
  export type ProjectTestimonialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectTestimonials.
     */
    data: XOR<ProjectTestimonialUpdateManyMutationInput, ProjectTestimonialUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTestimonials to update
     */
    where?: ProjectTestimonialWhereInput
    /**
     * Limit how many ProjectTestimonials to update.
     */
    limit?: number
  }

  /**
   * ProjectTestimonial updateManyAndReturn
   */
  export type ProjectTestimonialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTestimonial
     */
    select?: ProjectTestimonialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTestimonial
     */
    omit?: ProjectTestimonialOmit<ExtArgs> | null
    /**
     * The data used to update ProjectTestimonials.
     */
    data: XOR<ProjectTestimonialUpdateManyMutationInput, ProjectTestimonialUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTestimonials to update
     */
    where?: ProjectTestimonialWhereInput
    /**
     * Limit how many ProjectTestimonials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTestimonialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectTestimonial upsert
   */
  export type ProjectTestimonialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTestimonial
     */
    select?: ProjectTestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTestimonial
     */
    omit?: ProjectTestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTestimonialInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectTestimonial to update in case it exists.
     */
    where: ProjectTestimonialWhereUniqueInput
    /**
     * In case the ProjectTestimonial found by the `where` argument doesn't exist, create a new ProjectTestimonial with this data.
     */
    create: XOR<ProjectTestimonialCreateInput, ProjectTestimonialUncheckedCreateInput>
    /**
     * In case the ProjectTestimonial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectTestimonialUpdateInput, ProjectTestimonialUncheckedUpdateInput>
  }

  /**
   * ProjectTestimonial delete
   */
  export type ProjectTestimonialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTestimonial
     */
    select?: ProjectTestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTestimonial
     */
    omit?: ProjectTestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTestimonialInclude<ExtArgs> | null
    /**
     * Filter which ProjectTestimonial to delete.
     */
    where: ProjectTestimonialWhereUniqueInput
  }

  /**
   * ProjectTestimonial deleteMany
   */
  export type ProjectTestimonialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTestimonials to delete
     */
    where?: ProjectTestimonialWhereInput
    /**
     * Limit how many ProjectTestimonials to delete.
     */
    limit?: number
  }

  /**
   * ProjectTestimonial without action
   */
  export type ProjectTestimonialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTestimonial
     */
    select?: ProjectTestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTestimonial
     */
    omit?: ProjectTestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTestimonialInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    username: 'username',
    email: 'email',
    phone: 'phone',
    location: 'location',
    bio: 'bio',
    website: 'website',
    avatar: 'avatar',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    percentage: 'percentage',
    color: 'color',
    icon: 'icon',
    category: 'category',
    description: 'description',
    years: 'years',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    slug: 'slug',
    description: 'description',
    longDescription: 'longDescription',
    category: 'category',
    image: 'image',
    demoUrl: 'demoUrl',
    githubUrl: 'githubUrl',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    branches: 'branches',
    stars: 'stars',
    views: 'views',
    forks: 'forks',
    issues: 'issues',
    commits: 'commits',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectFeatureScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    feature: 'feature'
  };

  export type ProjectFeatureScalarFieldEnum = (typeof ProjectFeatureScalarFieldEnum)[keyof typeof ProjectFeatureScalarFieldEnum]


  export const ProjectTechStackScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    tech: 'tech'
  };

  export type ProjectTechStackScalarFieldEnum = (typeof ProjectTechStackScalarFieldEnum)[keyof typeof ProjectTechStackScalarFieldEnum]


  export const ProjectCollaboratorScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    username: 'username'
  };

  export type ProjectCollaboratorScalarFieldEnum = (typeof ProjectCollaboratorScalarFieldEnum)[keyof typeof ProjectCollaboratorScalarFieldEnum]


  export const ProjectLearningScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    learning: 'learning'
  };

  export type ProjectLearningScalarFieldEnum = (typeof ProjectLearningScalarFieldEnum)[keyof typeof ProjectLearningScalarFieldEnum]


  export const WorkExperienceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    company: 'company',
    position: 'position',
    period: 'period',
    description: 'description',
    location: 'location',
    type: 'type',
    logo: 'logo',
    website: 'website',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkExperienceScalarFieldEnum = (typeof WorkExperienceScalarFieldEnum)[keyof typeof WorkExperienceScalarFieldEnum]


  export const WorkResponsibilityScalarFieldEnum: {
    id: 'id',
    experienceId: 'experienceId',
    responsibility: 'responsibility'
  };

  export type WorkResponsibilityScalarFieldEnum = (typeof WorkResponsibilityScalarFieldEnum)[keyof typeof WorkResponsibilityScalarFieldEnum]


  export const WorkTechnologyScalarFieldEnum: {
    id: 'id',
    experienceId: 'experienceId',
    technology: 'technology'
  };

  export type WorkTechnologyScalarFieldEnum = (typeof WorkTechnologyScalarFieldEnum)[keyof typeof WorkTechnologyScalarFieldEnum]


  export const WorkAchievementScalarFieldEnum: {
    id: 'id',
    experienceId: 'experienceId',
    achievement: 'achievement'
  };

  export type WorkAchievementScalarFieldEnum = (typeof WorkAchievementScalarFieldEnum)[keyof typeof WorkAchievementScalarFieldEnum]


  export const EducationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    institution: 'institution',
    degree: 'degree',
    field: 'field',
    period: 'period',
    description: 'description',
    gpa: 'gpa',
    location: 'location',
    logo: 'logo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EducationScalarFieldEnum = (typeof EducationScalarFieldEnum)[keyof typeof EducationScalarFieldEnum]


  export const EducationAchievementScalarFieldEnum: {
    id: 'id',
    educationId: 'educationId',
    achievement: 'achievement'
  };

  export type EducationAchievementScalarFieldEnum = (typeof EducationAchievementScalarFieldEnum)[keyof typeof EducationAchievementScalarFieldEnum]


  export const CertificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    issuer: 'issuer',
    date: 'date',
    icon: 'icon',
    credentialId: 'credentialId',
    expiry: 'expiry',
    description: 'description',
    verificationUrl: 'verificationUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CertificationScalarFieldEnum = (typeof CertificationScalarFieldEnum)[keyof typeof CertificationScalarFieldEnum]


  export const CertificationSkillScalarFieldEnum: {
    id: 'id',
    certificationId: 'certificationId',
    skill: 'skill'
  };

  export type CertificationSkillScalarFieldEnum = (typeof CertificationSkillScalarFieldEnum)[keyof typeof CertificationSkillScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    date: 'date',
    description: 'description',
    icon: 'icon',
    category: 'category',
    issuer: 'issuer',
    link: 'link',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    slug: 'slug',
    title: 'title',
    excerpt: 'excerpt',
    content: 'content',
    date: 'date',
    readTime: 'readTime',
    image: 'image',
    likes: 'likes',
    comments: 'comments',
    shares: 'shares',
    views: 'views',
    category: 'category',
    author: 'author',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const BlogTagScalarFieldEnum: {
    id: 'id',
    blogId: 'blogId',
    tag: 'tag'
  };

  export type BlogTagScalarFieldEnum = (typeof BlogTagScalarFieldEnum)[keyof typeof BlogTagScalarFieldEnum]


  export const TestimonialScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    position: 'position',
    company: 'company',
    text: 'text',
    avatar: 'avatar',
    rating: 'rating',
    date: 'date',
    relation: 'relation',
    projectLink: 'projectLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestimonialScalarFieldEnum = (typeof TestimonialScalarFieldEnum)[keyof typeof TestimonialScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    value: 'value',
    icon: 'icon',
    isPublic: 'isPublic',
    link: 'link'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const SocialMediaScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    platform: 'platform',
    url: 'url',
    icon: 'icon',
    username: 'username'
  };

  export type SocialMediaScalarFieldEnum = (typeof SocialMediaScalarFieldEnum)[keyof typeof SocialMediaScalarFieldEnum]


  export const DevStatsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    repos: 'repos',
    stars: 'stars',
    contributions: 'contributions',
    rating: 'rating',
    followers: 'followers',
    following: 'following',
    streak: 'streak',
    commits: 'commits',
    prsOpened: 'prsOpened',
    issuesClosed: 'issuesClosed',
    rank: 'rank',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DevStatsScalarFieldEnum = (typeof DevStatsScalarFieldEnum)[keyof typeof DevStatsScalarFieldEnum]


  export const ContributionDataScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    year: 'year',
    total: 'total',
    startRange: 'startRange',
    endRange: 'endRange'
  };

  export type ContributionDataScalarFieldEnum = (typeof ContributionDataScalarFieldEnum)[keyof typeof ContributionDataScalarFieldEnum]


  export const ContributionDayScalarFieldEnum: {
    id: 'id',
    contributionDataId: 'contributionDataId',
    date: 'date',
    count: 'count',
    level: 'level'
  };

  export type ContributionDayScalarFieldEnum = (typeof ContributionDayScalarFieldEnum)[keyof typeof ContributionDayScalarFieldEnum]


  export const TimelineEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    type: 'type',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    icon: 'icon',
    color: 'color'
  };

  export type TimelineEventScalarFieldEnum = (typeof TimelineEventScalarFieldEnum)[keyof typeof TimelineEventScalarFieldEnum]


  export const ProjectTestimonialScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    testimonialId: 'testimonialId'
  };

  export type ProjectTestimonialScalarFieldEnum = (typeof ProjectTestimonialScalarFieldEnum)[keyof typeof ProjectTestimonialScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    website?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    skills?: SkillListRelationFilter
    projects?: ProjectListRelationFilter
    workExperiences?: WorkExperienceListRelationFilter
    educations?: EducationListRelationFilter
    certifications?: CertificationListRelationFilter
    achievements?: AchievementListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    testimonials?: TestimonialListRelationFilter
    contacts?: ContactListRelationFilter
    socialMedia?: SocialMediaListRelationFilter
    devStats?: XOR<DevStatsNullableScalarRelationFilter, DevStatsWhereInput> | null
    contributionData?: ContributionDataListRelationFilter
    timelineEvents?: TimelineEventListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    skills?: SkillOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    workExperiences?: WorkExperienceOrderByRelationAggregateInput
    educations?: EducationOrderByRelationAggregateInput
    certifications?: CertificationOrderByRelationAggregateInput
    achievements?: AchievementOrderByRelationAggregateInput
    blogPosts?: BlogPostOrderByRelationAggregateInput
    testimonials?: TestimonialOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    socialMedia?: SocialMediaOrderByRelationAggregateInput
    devStats?: DevStatsOrderByWithRelationInput
    contributionData?: ContributionDataOrderByRelationAggregateInput
    timelineEvents?: TimelineEventOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    website?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    skills?: SkillListRelationFilter
    projects?: ProjectListRelationFilter
    workExperiences?: WorkExperienceListRelationFilter
    educations?: EducationListRelationFilter
    certifications?: CertificationListRelationFilter
    achievements?: AchievementListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    testimonials?: TestimonialListRelationFilter
    contacts?: ContactListRelationFilter
    socialMedia?: SocialMediaListRelationFilter
    devStats?: XOR<DevStatsNullableScalarRelationFilter, DevStatsWhereInput> | null
    contributionData?: ContributionDataListRelationFilter
    timelineEvents?: TimelineEventListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    location?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    website?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: StringFilter<"Skill"> | string
    userId?: StringFilter<"Skill"> | string
    name?: StringFilter<"Skill"> | string
    percentage?: IntFilter<"Skill"> | number
    color?: StringNullableFilter<"Skill"> | string | null
    icon?: StringNullableFilter<"Skill"> | string | null
    category?: StringNullableFilter<"Skill"> | string | null
    description?: StringNullableFilter<"Skill"> | string | null
    years?: FloatNullableFilter<"Skill"> | number | null
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    projects?: ProjectListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    years?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    projects?: ProjectOrderByRelationAggregateInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    userId?: StringFilter<"Skill"> | string
    name?: StringFilter<"Skill"> | string
    percentage?: IntFilter<"Skill"> | number
    color?: StringNullableFilter<"Skill"> | string | null
    icon?: StringNullableFilter<"Skill"> | string | null
    category?: StringNullableFilter<"Skill"> | string | null
    description?: StringNullableFilter<"Skill"> | string | null
    years?: FloatNullableFilter<"Skill"> | number | null
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    projects?: ProjectListRelationFilter
  }, "id">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    years?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SkillCountOrderByAggregateInput
    _avg?: SkillAvgOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
    _sum?: SkillSumOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Skill"> | string
    userId?: StringWithAggregatesFilter<"Skill"> | string
    name?: StringWithAggregatesFilter<"Skill"> | string
    percentage?: IntWithAggregatesFilter<"Skill"> | number
    color?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    category?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    description?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    years?: FloatNullableWithAggregatesFilter<"Skill"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    userId?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    slug?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    longDescription?: StringFilter<"Project"> | string
    category?: StringFilter<"Project"> | string
    image?: StringNullableFilter<"Project"> | string | null
    demoUrl?: StringNullableFilter<"Project"> | string | null
    githubUrl?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    branches?: IntNullableFilter<"Project"> | number | null
    stars?: IntNullableFilter<"Project"> | number | null
    views?: IntNullableFilter<"Project"> | number | null
    forks?: IntNullableFilter<"Project"> | number | null
    issues?: IntNullableFilter<"Project"> | number | null
    commits?: IntNullableFilter<"Project"> | number | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    features?: ProjectFeatureListRelationFilter
    techStack?: ProjectTechStackListRelationFilter
    collaborators?: ProjectCollaboratorListRelationFilter
    learnings?: ProjectLearningListRelationFilter
    testimonials?: ProjectTestimonialListRelationFilter
    skills?: SkillListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    longDescription?: SortOrder
    category?: SortOrder
    image?: SortOrderInput | SortOrder
    demoUrl?: SortOrderInput | SortOrder
    githubUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    branches?: SortOrderInput | SortOrder
    stars?: SortOrderInput | SortOrder
    views?: SortOrderInput | SortOrder
    forks?: SortOrderInput | SortOrder
    issues?: SortOrderInput | SortOrder
    commits?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    features?: ProjectFeatureOrderByRelationAggregateInput
    techStack?: ProjectTechStackOrderByRelationAggregateInput
    collaborators?: ProjectCollaboratorOrderByRelationAggregateInput
    learnings?: ProjectLearningOrderByRelationAggregateInput
    testimonials?: ProjectTestimonialOrderByRelationAggregateInput
    skills?: SkillOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    userId?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    longDescription?: StringFilter<"Project"> | string
    category?: StringFilter<"Project"> | string
    image?: StringNullableFilter<"Project"> | string | null
    demoUrl?: StringNullableFilter<"Project"> | string | null
    githubUrl?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    branches?: IntNullableFilter<"Project"> | number | null
    stars?: IntNullableFilter<"Project"> | number | null
    views?: IntNullableFilter<"Project"> | number | null
    forks?: IntNullableFilter<"Project"> | number | null
    issues?: IntNullableFilter<"Project"> | number | null
    commits?: IntNullableFilter<"Project"> | number | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    features?: ProjectFeatureListRelationFilter
    techStack?: ProjectTechStackListRelationFilter
    collaborators?: ProjectCollaboratorListRelationFilter
    learnings?: ProjectLearningListRelationFilter
    testimonials?: ProjectTestimonialListRelationFilter
    skills?: SkillListRelationFilter
  }, "id" | "slug">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    longDescription?: SortOrder
    category?: SortOrder
    image?: SortOrderInput | SortOrder
    demoUrl?: SortOrderInput | SortOrder
    githubUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    branches?: SortOrderInput | SortOrder
    stars?: SortOrderInput | SortOrder
    views?: SortOrderInput | SortOrder
    forks?: SortOrderInput | SortOrder
    issues?: SortOrderInput | SortOrder
    commits?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    userId?: StringWithAggregatesFilter<"Project"> | string
    title?: StringWithAggregatesFilter<"Project"> | string
    slug?: StringWithAggregatesFilter<"Project"> | string
    description?: StringWithAggregatesFilter<"Project"> | string
    longDescription?: StringWithAggregatesFilter<"Project"> | string
    category?: StringWithAggregatesFilter<"Project"> | string
    image?: StringNullableWithAggregatesFilter<"Project"> | string | null
    demoUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    githubUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    status?: StringWithAggregatesFilter<"Project"> | string
    startDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    branches?: IntNullableWithAggregatesFilter<"Project"> | number | null
    stars?: IntNullableWithAggregatesFilter<"Project"> | number | null
    views?: IntNullableWithAggregatesFilter<"Project"> | number | null
    forks?: IntNullableWithAggregatesFilter<"Project"> | number | null
    issues?: IntNullableWithAggregatesFilter<"Project"> | number | null
    commits?: IntNullableWithAggregatesFilter<"Project"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectFeatureWhereInput = {
    AND?: ProjectFeatureWhereInput | ProjectFeatureWhereInput[]
    OR?: ProjectFeatureWhereInput[]
    NOT?: ProjectFeatureWhereInput | ProjectFeatureWhereInput[]
    id?: StringFilter<"ProjectFeature"> | string
    projectId?: StringFilter<"ProjectFeature"> | string
    feature?: StringFilter<"ProjectFeature"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectFeatureOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    feature?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectFeatureWhereInput | ProjectFeatureWhereInput[]
    OR?: ProjectFeatureWhereInput[]
    NOT?: ProjectFeatureWhereInput | ProjectFeatureWhereInput[]
    projectId?: StringFilter<"ProjectFeature"> | string
    feature?: StringFilter<"ProjectFeature"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    feature?: SortOrder
    _count?: ProjectFeatureCountOrderByAggregateInput
    _max?: ProjectFeatureMaxOrderByAggregateInput
    _min?: ProjectFeatureMinOrderByAggregateInput
  }

  export type ProjectFeatureScalarWhereWithAggregatesInput = {
    AND?: ProjectFeatureScalarWhereWithAggregatesInput | ProjectFeatureScalarWhereWithAggregatesInput[]
    OR?: ProjectFeatureScalarWhereWithAggregatesInput[]
    NOT?: ProjectFeatureScalarWhereWithAggregatesInput | ProjectFeatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectFeature"> | string
    projectId?: StringWithAggregatesFilter<"ProjectFeature"> | string
    feature?: StringWithAggregatesFilter<"ProjectFeature"> | string
  }

  export type ProjectTechStackWhereInput = {
    AND?: ProjectTechStackWhereInput | ProjectTechStackWhereInput[]
    OR?: ProjectTechStackWhereInput[]
    NOT?: ProjectTechStackWhereInput | ProjectTechStackWhereInput[]
    id?: StringFilter<"ProjectTechStack"> | string
    projectId?: StringFilter<"ProjectTechStack"> | string
    tech?: StringFilter<"ProjectTechStack"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectTechStackOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    tech?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectTechStackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectTechStackWhereInput | ProjectTechStackWhereInput[]
    OR?: ProjectTechStackWhereInput[]
    NOT?: ProjectTechStackWhereInput | ProjectTechStackWhereInput[]
    projectId?: StringFilter<"ProjectTechStack"> | string
    tech?: StringFilter<"ProjectTechStack"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectTechStackOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    tech?: SortOrder
    _count?: ProjectTechStackCountOrderByAggregateInput
    _max?: ProjectTechStackMaxOrderByAggregateInput
    _min?: ProjectTechStackMinOrderByAggregateInput
  }

  export type ProjectTechStackScalarWhereWithAggregatesInput = {
    AND?: ProjectTechStackScalarWhereWithAggregatesInput | ProjectTechStackScalarWhereWithAggregatesInput[]
    OR?: ProjectTechStackScalarWhereWithAggregatesInput[]
    NOT?: ProjectTechStackScalarWhereWithAggregatesInput | ProjectTechStackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectTechStack"> | string
    projectId?: StringWithAggregatesFilter<"ProjectTechStack"> | string
    tech?: StringWithAggregatesFilter<"ProjectTechStack"> | string
  }

  export type ProjectCollaboratorWhereInput = {
    AND?: ProjectCollaboratorWhereInput | ProjectCollaboratorWhereInput[]
    OR?: ProjectCollaboratorWhereInput[]
    NOT?: ProjectCollaboratorWhereInput | ProjectCollaboratorWhereInput[]
    id?: StringFilter<"ProjectCollaborator"> | string
    projectId?: StringFilter<"ProjectCollaborator"> | string
    name?: StringFilter<"ProjectCollaborator"> | string
    username?: StringFilter<"ProjectCollaborator"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectCollaboratorOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    username?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectCollaboratorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectCollaboratorWhereInput | ProjectCollaboratorWhereInput[]
    OR?: ProjectCollaboratorWhereInput[]
    NOT?: ProjectCollaboratorWhereInput | ProjectCollaboratorWhereInput[]
    projectId?: StringFilter<"ProjectCollaborator"> | string
    name?: StringFilter<"ProjectCollaborator"> | string
    username?: StringFilter<"ProjectCollaborator"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectCollaboratorOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    username?: SortOrder
    _count?: ProjectCollaboratorCountOrderByAggregateInput
    _max?: ProjectCollaboratorMaxOrderByAggregateInput
    _min?: ProjectCollaboratorMinOrderByAggregateInput
  }

  export type ProjectCollaboratorScalarWhereWithAggregatesInput = {
    AND?: ProjectCollaboratorScalarWhereWithAggregatesInput | ProjectCollaboratorScalarWhereWithAggregatesInput[]
    OR?: ProjectCollaboratorScalarWhereWithAggregatesInput[]
    NOT?: ProjectCollaboratorScalarWhereWithAggregatesInput | ProjectCollaboratorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectCollaborator"> | string
    projectId?: StringWithAggregatesFilter<"ProjectCollaborator"> | string
    name?: StringWithAggregatesFilter<"ProjectCollaborator"> | string
    username?: StringWithAggregatesFilter<"ProjectCollaborator"> | string
  }

  export type ProjectLearningWhereInput = {
    AND?: ProjectLearningWhereInput | ProjectLearningWhereInput[]
    OR?: ProjectLearningWhereInput[]
    NOT?: ProjectLearningWhereInput | ProjectLearningWhereInput[]
    id?: StringFilter<"ProjectLearning"> | string
    projectId?: StringFilter<"ProjectLearning"> | string
    learning?: StringFilter<"ProjectLearning"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectLearningOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    learning?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectLearningWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectLearningWhereInput | ProjectLearningWhereInput[]
    OR?: ProjectLearningWhereInput[]
    NOT?: ProjectLearningWhereInput | ProjectLearningWhereInput[]
    projectId?: StringFilter<"ProjectLearning"> | string
    learning?: StringFilter<"ProjectLearning"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectLearningOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    learning?: SortOrder
    _count?: ProjectLearningCountOrderByAggregateInput
    _max?: ProjectLearningMaxOrderByAggregateInput
    _min?: ProjectLearningMinOrderByAggregateInput
  }

  export type ProjectLearningScalarWhereWithAggregatesInput = {
    AND?: ProjectLearningScalarWhereWithAggregatesInput | ProjectLearningScalarWhereWithAggregatesInput[]
    OR?: ProjectLearningScalarWhereWithAggregatesInput[]
    NOT?: ProjectLearningScalarWhereWithAggregatesInput | ProjectLearningScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectLearning"> | string
    projectId?: StringWithAggregatesFilter<"ProjectLearning"> | string
    learning?: StringWithAggregatesFilter<"ProjectLearning"> | string
  }

  export type WorkExperienceWhereInput = {
    AND?: WorkExperienceWhereInput | WorkExperienceWhereInput[]
    OR?: WorkExperienceWhereInput[]
    NOT?: WorkExperienceWhereInput | WorkExperienceWhereInput[]
    id?: StringFilter<"WorkExperience"> | string
    userId?: StringFilter<"WorkExperience"> | string
    company?: StringFilter<"WorkExperience"> | string
    position?: StringFilter<"WorkExperience"> | string
    period?: StringFilter<"WorkExperience"> | string
    description?: StringNullableFilter<"WorkExperience"> | string | null
    location?: StringNullableFilter<"WorkExperience"> | string | null
    type?: StringNullableFilter<"WorkExperience"> | string | null
    logo?: StringNullableFilter<"WorkExperience"> | string | null
    website?: StringNullableFilter<"WorkExperience"> | string | null
    createdAt?: DateTimeFilter<"WorkExperience"> | Date | string
    updatedAt?: DateTimeFilter<"WorkExperience"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    responsibilities?: WorkResponsibilityListRelationFilter
    technologies?: WorkTechnologyListRelationFilter
    achievements?: WorkAchievementListRelationFilter
  }

  export type WorkExperienceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    position?: SortOrder
    period?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    responsibilities?: WorkResponsibilityOrderByRelationAggregateInput
    technologies?: WorkTechnologyOrderByRelationAggregateInput
    achievements?: WorkAchievementOrderByRelationAggregateInput
  }

  export type WorkExperienceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkExperienceWhereInput | WorkExperienceWhereInput[]
    OR?: WorkExperienceWhereInput[]
    NOT?: WorkExperienceWhereInput | WorkExperienceWhereInput[]
    userId?: StringFilter<"WorkExperience"> | string
    company?: StringFilter<"WorkExperience"> | string
    position?: StringFilter<"WorkExperience"> | string
    period?: StringFilter<"WorkExperience"> | string
    description?: StringNullableFilter<"WorkExperience"> | string | null
    location?: StringNullableFilter<"WorkExperience"> | string | null
    type?: StringNullableFilter<"WorkExperience"> | string | null
    logo?: StringNullableFilter<"WorkExperience"> | string | null
    website?: StringNullableFilter<"WorkExperience"> | string | null
    createdAt?: DateTimeFilter<"WorkExperience"> | Date | string
    updatedAt?: DateTimeFilter<"WorkExperience"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    responsibilities?: WorkResponsibilityListRelationFilter
    technologies?: WorkTechnologyListRelationFilter
    achievements?: WorkAchievementListRelationFilter
  }, "id">

  export type WorkExperienceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    position?: SortOrder
    period?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkExperienceCountOrderByAggregateInput
    _max?: WorkExperienceMaxOrderByAggregateInput
    _min?: WorkExperienceMinOrderByAggregateInput
  }

  export type WorkExperienceScalarWhereWithAggregatesInput = {
    AND?: WorkExperienceScalarWhereWithAggregatesInput | WorkExperienceScalarWhereWithAggregatesInput[]
    OR?: WorkExperienceScalarWhereWithAggregatesInput[]
    NOT?: WorkExperienceScalarWhereWithAggregatesInput | WorkExperienceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkExperience"> | string
    userId?: StringWithAggregatesFilter<"WorkExperience"> | string
    company?: StringWithAggregatesFilter<"WorkExperience"> | string
    position?: StringWithAggregatesFilter<"WorkExperience"> | string
    period?: StringWithAggregatesFilter<"WorkExperience"> | string
    description?: StringNullableWithAggregatesFilter<"WorkExperience"> | string | null
    location?: StringNullableWithAggregatesFilter<"WorkExperience"> | string | null
    type?: StringNullableWithAggregatesFilter<"WorkExperience"> | string | null
    logo?: StringNullableWithAggregatesFilter<"WorkExperience"> | string | null
    website?: StringNullableWithAggregatesFilter<"WorkExperience"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkExperience"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkExperience"> | Date | string
  }

  export type WorkResponsibilityWhereInput = {
    AND?: WorkResponsibilityWhereInput | WorkResponsibilityWhereInput[]
    OR?: WorkResponsibilityWhereInput[]
    NOT?: WorkResponsibilityWhereInput | WorkResponsibilityWhereInput[]
    id?: StringFilter<"WorkResponsibility"> | string
    experienceId?: StringFilter<"WorkResponsibility"> | string
    responsibility?: StringFilter<"WorkResponsibility"> | string
    workExperience?: XOR<WorkExperienceScalarRelationFilter, WorkExperienceWhereInput>
  }

  export type WorkResponsibilityOrderByWithRelationInput = {
    id?: SortOrder
    experienceId?: SortOrder
    responsibility?: SortOrder
    workExperience?: WorkExperienceOrderByWithRelationInput
  }

  export type WorkResponsibilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkResponsibilityWhereInput | WorkResponsibilityWhereInput[]
    OR?: WorkResponsibilityWhereInput[]
    NOT?: WorkResponsibilityWhereInput | WorkResponsibilityWhereInput[]
    experienceId?: StringFilter<"WorkResponsibility"> | string
    responsibility?: StringFilter<"WorkResponsibility"> | string
    workExperience?: XOR<WorkExperienceScalarRelationFilter, WorkExperienceWhereInput>
  }, "id">

  export type WorkResponsibilityOrderByWithAggregationInput = {
    id?: SortOrder
    experienceId?: SortOrder
    responsibility?: SortOrder
    _count?: WorkResponsibilityCountOrderByAggregateInput
    _max?: WorkResponsibilityMaxOrderByAggregateInput
    _min?: WorkResponsibilityMinOrderByAggregateInput
  }

  export type WorkResponsibilityScalarWhereWithAggregatesInput = {
    AND?: WorkResponsibilityScalarWhereWithAggregatesInput | WorkResponsibilityScalarWhereWithAggregatesInput[]
    OR?: WorkResponsibilityScalarWhereWithAggregatesInput[]
    NOT?: WorkResponsibilityScalarWhereWithAggregatesInput | WorkResponsibilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkResponsibility"> | string
    experienceId?: StringWithAggregatesFilter<"WorkResponsibility"> | string
    responsibility?: StringWithAggregatesFilter<"WorkResponsibility"> | string
  }

  export type WorkTechnologyWhereInput = {
    AND?: WorkTechnologyWhereInput | WorkTechnologyWhereInput[]
    OR?: WorkTechnologyWhereInput[]
    NOT?: WorkTechnologyWhereInput | WorkTechnologyWhereInput[]
    id?: StringFilter<"WorkTechnology"> | string
    experienceId?: StringFilter<"WorkTechnology"> | string
    technology?: StringFilter<"WorkTechnology"> | string
    workExperience?: XOR<WorkExperienceScalarRelationFilter, WorkExperienceWhereInput>
  }

  export type WorkTechnologyOrderByWithRelationInput = {
    id?: SortOrder
    experienceId?: SortOrder
    technology?: SortOrder
    workExperience?: WorkExperienceOrderByWithRelationInput
  }

  export type WorkTechnologyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkTechnologyWhereInput | WorkTechnologyWhereInput[]
    OR?: WorkTechnologyWhereInput[]
    NOT?: WorkTechnologyWhereInput | WorkTechnologyWhereInput[]
    experienceId?: StringFilter<"WorkTechnology"> | string
    technology?: StringFilter<"WorkTechnology"> | string
    workExperience?: XOR<WorkExperienceScalarRelationFilter, WorkExperienceWhereInput>
  }, "id">

  export type WorkTechnologyOrderByWithAggregationInput = {
    id?: SortOrder
    experienceId?: SortOrder
    technology?: SortOrder
    _count?: WorkTechnologyCountOrderByAggregateInput
    _max?: WorkTechnologyMaxOrderByAggregateInput
    _min?: WorkTechnologyMinOrderByAggregateInput
  }

  export type WorkTechnologyScalarWhereWithAggregatesInput = {
    AND?: WorkTechnologyScalarWhereWithAggregatesInput | WorkTechnologyScalarWhereWithAggregatesInput[]
    OR?: WorkTechnologyScalarWhereWithAggregatesInput[]
    NOT?: WorkTechnologyScalarWhereWithAggregatesInput | WorkTechnologyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkTechnology"> | string
    experienceId?: StringWithAggregatesFilter<"WorkTechnology"> | string
    technology?: StringWithAggregatesFilter<"WorkTechnology"> | string
  }

  export type WorkAchievementWhereInput = {
    AND?: WorkAchievementWhereInput | WorkAchievementWhereInput[]
    OR?: WorkAchievementWhereInput[]
    NOT?: WorkAchievementWhereInput | WorkAchievementWhereInput[]
    id?: StringFilter<"WorkAchievement"> | string
    experienceId?: StringFilter<"WorkAchievement"> | string
    achievement?: StringFilter<"WorkAchievement"> | string
    workExperience?: XOR<WorkExperienceScalarRelationFilter, WorkExperienceWhereInput>
  }

  export type WorkAchievementOrderByWithRelationInput = {
    id?: SortOrder
    experienceId?: SortOrder
    achievement?: SortOrder
    workExperience?: WorkExperienceOrderByWithRelationInput
  }

  export type WorkAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkAchievementWhereInput | WorkAchievementWhereInput[]
    OR?: WorkAchievementWhereInput[]
    NOT?: WorkAchievementWhereInput | WorkAchievementWhereInput[]
    experienceId?: StringFilter<"WorkAchievement"> | string
    achievement?: StringFilter<"WorkAchievement"> | string
    workExperience?: XOR<WorkExperienceScalarRelationFilter, WorkExperienceWhereInput>
  }, "id">

  export type WorkAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    experienceId?: SortOrder
    achievement?: SortOrder
    _count?: WorkAchievementCountOrderByAggregateInput
    _max?: WorkAchievementMaxOrderByAggregateInput
    _min?: WorkAchievementMinOrderByAggregateInput
  }

  export type WorkAchievementScalarWhereWithAggregatesInput = {
    AND?: WorkAchievementScalarWhereWithAggregatesInput | WorkAchievementScalarWhereWithAggregatesInput[]
    OR?: WorkAchievementScalarWhereWithAggregatesInput[]
    NOT?: WorkAchievementScalarWhereWithAggregatesInput | WorkAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkAchievement"> | string
    experienceId?: StringWithAggregatesFilter<"WorkAchievement"> | string
    achievement?: StringWithAggregatesFilter<"WorkAchievement"> | string
  }

  export type EducationWhereInput = {
    AND?: EducationWhereInput | EducationWhereInput[]
    OR?: EducationWhereInput[]
    NOT?: EducationWhereInput | EducationWhereInput[]
    id?: StringFilter<"Education"> | string
    userId?: StringFilter<"Education"> | string
    institution?: StringFilter<"Education"> | string
    degree?: StringFilter<"Education"> | string
    field?: StringFilter<"Education"> | string
    period?: StringFilter<"Education"> | string
    description?: StringNullableFilter<"Education"> | string | null
    gpa?: StringNullableFilter<"Education"> | string | null
    location?: StringNullableFilter<"Education"> | string | null
    logo?: StringNullableFilter<"Education"> | string | null
    createdAt?: DateTimeFilter<"Education"> | Date | string
    updatedAt?: DateTimeFilter<"Education"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievements?: EducationAchievementListRelationFilter
  }

  export type EducationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    field?: SortOrder
    period?: SortOrder
    description?: SortOrderInput | SortOrder
    gpa?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    achievements?: EducationAchievementOrderByRelationAggregateInput
  }

  export type EducationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EducationWhereInput | EducationWhereInput[]
    OR?: EducationWhereInput[]
    NOT?: EducationWhereInput | EducationWhereInput[]
    userId?: StringFilter<"Education"> | string
    institution?: StringFilter<"Education"> | string
    degree?: StringFilter<"Education"> | string
    field?: StringFilter<"Education"> | string
    period?: StringFilter<"Education"> | string
    description?: StringNullableFilter<"Education"> | string | null
    gpa?: StringNullableFilter<"Education"> | string | null
    location?: StringNullableFilter<"Education"> | string | null
    logo?: StringNullableFilter<"Education"> | string | null
    createdAt?: DateTimeFilter<"Education"> | Date | string
    updatedAt?: DateTimeFilter<"Education"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievements?: EducationAchievementListRelationFilter
  }, "id">

  export type EducationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    field?: SortOrder
    period?: SortOrder
    description?: SortOrderInput | SortOrder
    gpa?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EducationCountOrderByAggregateInput
    _max?: EducationMaxOrderByAggregateInput
    _min?: EducationMinOrderByAggregateInput
  }

  export type EducationScalarWhereWithAggregatesInput = {
    AND?: EducationScalarWhereWithAggregatesInput | EducationScalarWhereWithAggregatesInput[]
    OR?: EducationScalarWhereWithAggregatesInput[]
    NOT?: EducationScalarWhereWithAggregatesInput | EducationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Education"> | string
    userId?: StringWithAggregatesFilter<"Education"> | string
    institution?: StringWithAggregatesFilter<"Education"> | string
    degree?: StringWithAggregatesFilter<"Education"> | string
    field?: StringWithAggregatesFilter<"Education"> | string
    period?: StringWithAggregatesFilter<"Education"> | string
    description?: StringNullableWithAggregatesFilter<"Education"> | string | null
    gpa?: StringNullableWithAggregatesFilter<"Education"> | string | null
    location?: StringNullableWithAggregatesFilter<"Education"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Education"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Education"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Education"> | Date | string
  }

  export type EducationAchievementWhereInput = {
    AND?: EducationAchievementWhereInput | EducationAchievementWhereInput[]
    OR?: EducationAchievementWhereInput[]
    NOT?: EducationAchievementWhereInput | EducationAchievementWhereInput[]
    id?: StringFilter<"EducationAchievement"> | string
    educationId?: StringFilter<"EducationAchievement"> | string
    achievement?: StringFilter<"EducationAchievement"> | string
    education?: XOR<EducationScalarRelationFilter, EducationWhereInput>
  }

  export type EducationAchievementOrderByWithRelationInput = {
    id?: SortOrder
    educationId?: SortOrder
    achievement?: SortOrder
    education?: EducationOrderByWithRelationInput
  }

  export type EducationAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EducationAchievementWhereInput | EducationAchievementWhereInput[]
    OR?: EducationAchievementWhereInput[]
    NOT?: EducationAchievementWhereInput | EducationAchievementWhereInput[]
    educationId?: StringFilter<"EducationAchievement"> | string
    achievement?: StringFilter<"EducationAchievement"> | string
    education?: XOR<EducationScalarRelationFilter, EducationWhereInput>
  }, "id">

  export type EducationAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    educationId?: SortOrder
    achievement?: SortOrder
    _count?: EducationAchievementCountOrderByAggregateInput
    _max?: EducationAchievementMaxOrderByAggregateInput
    _min?: EducationAchievementMinOrderByAggregateInput
  }

  export type EducationAchievementScalarWhereWithAggregatesInput = {
    AND?: EducationAchievementScalarWhereWithAggregatesInput | EducationAchievementScalarWhereWithAggregatesInput[]
    OR?: EducationAchievementScalarWhereWithAggregatesInput[]
    NOT?: EducationAchievementScalarWhereWithAggregatesInput | EducationAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EducationAchievement"> | string
    educationId?: StringWithAggregatesFilter<"EducationAchievement"> | string
    achievement?: StringWithAggregatesFilter<"EducationAchievement"> | string
  }

  export type CertificationWhereInput = {
    AND?: CertificationWhereInput | CertificationWhereInput[]
    OR?: CertificationWhereInput[]
    NOT?: CertificationWhereInput | CertificationWhereInput[]
    id?: StringFilter<"Certification"> | string
    userId?: StringFilter<"Certification"> | string
    name?: StringFilter<"Certification"> | string
    issuer?: StringFilter<"Certification"> | string
    date?: DateTimeFilter<"Certification"> | Date | string
    icon?: StringNullableFilter<"Certification"> | string | null
    credentialId?: StringNullableFilter<"Certification"> | string | null
    expiry?: DateTimeNullableFilter<"Certification"> | Date | string | null
    description?: StringNullableFilter<"Certification"> | string | null
    verificationUrl?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    skills?: CertificationSkillListRelationFilter
  }

  export type CertificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    issuer?: SortOrder
    date?: SortOrder
    icon?: SortOrderInput | SortOrder
    credentialId?: SortOrderInput | SortOrder
    expiry?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    verificationUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    skills?: CertificationSkillOrderByRelationAggregateInput
  }

  export type CertificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificationWhereInput | CertificationWhereInput[]
    OR?: CertificationWhereInput[]
    NOT?: CertificationWhereInput | CertificationWhereInput[]
    userId?: StringFilter<"Certification"> | string
    name?: StringFilter<"Certification"> | string
    issuer?: StringFilter<"Certification"> | string
    date?: DateTimeFilter<"Certification"> | Date | string
    icon?: StringNullableFilter<"Certification"> | string | null
    credentialId?: StringNullableFilter<"Certification"> | string | null
    expiry?: DateTimeNullableFilter<"Certification"> | Date | string | null
    description?: StringNullableFilter<"Certification"> | string | null
    verificationUrl?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    skills?: CertificationSkillListRelationFilter
  }, "id">

  export type CertificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    issuer?: SortOrder
    date?: SortOrder
    icon?: SortOrderInput | SortOrder
    credentialId?: SortOrderInput | SortOrder
    expiry?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    verificationUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CertificationCountOrderByAggregateInput
    _max?: CertificationMaxOrderByAggregateInput
    _min?: CertificationMinOrderByAggregateInput
  }

  export type CertificationScalarWhereWithAggregatesInput = {
    AND?: CertificationScalarWhereWithAggregatesInput | CertificationScalarWhereWithAggregatesInput[]
    OR?: CertificationScalarWhereWithAggregatesInput[]
    NOT?: CertificationScalarWhereWithAggregatesInput | CertificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certification"> | string
    userId?: StringWithAggregatesFilter<"Certification"> | string
    name?: StringWithAggregatesFilter<"Certification"> | string
    issuer?: StringWithAggregatesFilter<"Certification"> | string
    date?: DateTimeWithAggregatesFilter<"Certification"> | Date | string
    icon?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    credentialId?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    expiry?: DateTimeNullableWithAggregatesFilter<"Certification"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    verificationUrl?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Certification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Certification"> | Date | string
  }

  export type CertificationSkillWhereInput = {
    AND?: CertificationSkillWhereInput | CertificationSkillWhereInput[]
    OR?: CertificationSkillWhereInput[]
    NOT?: CertificationSkillWhereInput | CertificationSkillWhereInput[]
    id?: StringFilter<"CertificationSkill"> | string
    certificationId?: StringFilter<"CertificationSkill"> | string
    skill?: StringFilter<"CertificationSkill"> | string
    certification?: XOR<CertificationScalarRelationFilter, CertificationWhereInput>
  }

  export type CertificationSkillOrderByWithRelationInput = {
    id?: SortOrder
    certificationId?: SortOrder
    skill?: SortOrder
    certification?: CertificationOrderByWithRelationInput
  }

  export type CertificationSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificationSkillWhereInput | CertificationSkillWhereInput[]
    OR?: CertificationSkillWhereInput[]
    NOT?: CertificationSkillWhereInput | CertificationSkillWhereInput[]
    certificationId?: StringFilter<"CertificationSkill"> | string
    skill?: StringFilter<"CertificationSkill"> | string
    certification?: XOR<CertificationScalarRelationFilter, CertificationWhereInput>
  }, "id">

  export type CertificationSkillOrderByWithAggregationInput = {
    id?: SortOrder
    certificationId?: SortOrder
    skill?: SortOrder
    _count?: CertificationSkillCountOrderByAggregateInput
    _max?: CertificationSkillMaxOrderByAggregateInput
    _min?: CertificationSkillMinOrderByAggregateInput
  }

  export type CertificationSkillScalarWhereWithAggregatesInput = {
    AND?: CertificationSkillScalarWhereWithAggregatesInput | CertificationSkillScalarWhereWithAggregatesInput[]
    OR?: CertificationSkillScalarWhereWithAggregatesInput[]
    NOT?: CertificationSkillScalarWhereWithAggregatesInput | CertificationSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CertificationSkill"> | string
    certificationId?: StringWithAggregatesFilter<"CertificationSkill"> | string
    skill?: StringWithAggregatesFilter<"CertificationSkill"> | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    userId?: StringFilter<"Achievement"> | string
    title?: StringFilter<"Achievement"> | string
    date?: DateTimeFilter<"Achievement"> | Date | string
    description?: StringNullableFilter<"Achievement"> | string | null
    icon?: StringNullableFilter<"Achievement"> | string | null
    category?: StringNullableFilter<"Achievement"> | string | null
    issuer?: StringNullableFilter<"Achievement"> | string | null
    link?: StringNullableFilter<"Achievement"> | string | null
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    issuer?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    userId?: StringFilter<"Achievement"> | string
    title?: StringFilter<"Achievement"> | string
    date?: DateTimeFilter<"Achievement"> | Date | string
    description?: StringNullableFilter<"Achievement"> | string | null
    icon?: StringNullableFilter<"Achievement"> | string | null
    category?: StringNullableFilter<"Achievement"> | string | null
    issuer?: StringNullableFilter<"Achievement"> | string | null
    link?: StringNullableFilter<"Achievement"> | string | null
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    issuer?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    userId?: StringWithAggregatesFilter<"Achievement"> | string
    title?: StringWithAggregatesFilter<"Achievement"> | string
    date?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    category?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    issuer?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    link?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    userId?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    excerpt?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    date?: DateTimeFilter<"BlogPost"> | Date | string
    readTime?: IntFilter<"BlogPost"> | number
    image?: StringNullableFilter<"BlogPost"> | string | null
    likes?: IntFilter<"BlogPost"> | number
    comments?: IntFilter<"BlogPost"> | number
    shares?: IntFilter<"BlogPost"> | number
    views?: IntFilter<"BlogPost"> | number
    category?: StringFilter<"BlogPost"> | string
    author?: StringFilter<"BlogPost"> | string
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tags?: BlogTagListRelationFilter
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    date?: SortOrder
    readTime?: SortOrder
    image?: SortOrderInput | SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    views?: SortOrder
    category?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tags?: BlogTagOrderByRelationAggregateInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    userId?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    excerpt?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    date?: DateTimeFilter<"BlogPost"> | Date | string
    readTime?: IntFilter<"BlogPost"> | number
    image?: StringNullableFilter<"BlogPost"> | string | null
    likes?: IntFilter<"BlogPost"> | number
    comments?: IntFilter<"BlogPost"> | number
    shares?: IntFilter<"BlogPost"> | number
    views?: IntFilter<"BlogPost"> | number
    category?: StringFilter<"BlogPost"> | string
    author?: StringFilter<"BlogPost"> | string
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tags?: BlogTagListRelationFilter
  }, "id" | "slug">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    date?: SortOrder
    readTime?: SortOrder
    image?: SortOrderInput | SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    views?: SortOrder
    category?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _avg?: BlogPostAvgOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
    _sum?: BlogPostSumOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPost"> | string
    userId?: StringWithAggregatesFilter<"BlogPost"> | string
    slug?: StringWithAggregatesFilter<"BlogPost"> | string
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    excerpt?: StringWithAggregatesFilter<"BlogPost"> | string
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    date?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    readTime?: IntWithAggregatesFilter<"BlogPost"> | number
    image?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    likes?: IntWithAggregatesFilter<"BlogPost"> | number
    comments?: IntWithAggregatesFilter<"BlogPost"> | number
    shares?: IntWithAggregatesFilter<"BlogPost"> | number
    views?: IntWithAggregatesFilter<"BlogPost"> | number
    category?: StringWithAggregatesFilter<"BlogPost"> | string
    author?: StringWithAggregatesFilter<"BlogPost"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
  }

  export type BlogTagWhereInput = {
    AND?: BlogTagWhereInput | BlogTagWhereInput[]
    OR?: BlogTagWhereInput[]
    NOT?: BlogTagWhereInput | BlogTagWhereInput[]
    id?: StringFilter<"BlogTag"> | string
    blogId?: StringFilter<"BlogTag"> | string
    tag?: StringFilter<"BlogTag"> | string
    blogPost?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
  }

  export type BlogTagOrderByWithRelationInput = {
    id?: SortOrder
    blogId?: SortOrder
    tag?: SortOrder
    blogPost?: BlogPostOrderByWithRelationInput
  }

  export type BlogTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlogTagWhereInput | BlogTagWhereInput[]
    OR?: BlogTagWhereInput[]
    NOT?: BlogTagWhereInput | BlogTagWhereInput[]
    blogId?: StringFilter<"BlogTag"> | string
    tag?: StringFilter<"BlogTag"> | string
    blogPost?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
  }, "id">

  export type BlogTagOrderByWithAggregationInput = {
    id?: SortOrder
    blogId?: SortOrder
    tag?: SortOrder
    _count?: BlogTagCountOrderByAggregateInput
    _max?: BlogTagMaxOrderByAggregateInput
    _min?: BlogTagMinOrderByAggregateInput
  }

  export type BlogTagScalarWhereWithAggregatesInput = {
    AND?: BlogTagScalarWhereWithAggregatesInput | BlogTagScalarWhereWithAggregatesInput[]
    OR?: BlogTagScalarWhereWithAggregatesInput[]
    NOT?: BlogTagScalarWhereWithAggregatesInput | BlogTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogTag"> | string
    blogId?: StringWithAggregatesFilter<"BlogTag"> | string
    tag?: StringWithAggregatesFilter<"BlogTag"> | string
  }

  export type TestimonialWhereInput = {
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    id?: StringFilter<"Testimonial"> | string
    userId?: StringFilter<"Testimonial"> | string
    name?: StringFilter<"Testimonial"> | string
    position?: StringFilter<"Testimonial"> | string
    company?: StringFilter<"Testimonial"> | string
    text?: StringFilter<"Testimonial"> | string
    avatar?: StringNullableFilter<"Testimonial"> | string | null
    rating?: IntFilter<"Testimonial"> | number
    date?: DateTimeFilter<"Testimonial"> | Date | string
    relation?: StringFilter<"Testimonial"> | string
    projectLink?: StringNullableFilter<"Testimonial"> | string | null
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"Testimonial"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    projectTestimonials?: ProjectTestimonialListRelationFilter
  }

  export type TestimonialOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    position?: SortOrder
    company?: SortOrder
    text?: SortOrder
    avatar?: SortOrderInput | SortOrder
    rating?: SortOrder
    date?: SortOrder
    relation?: SortOrder
    projectLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    projectTestimonials?: ProjectTestimonialOrderByRelationAggregateInput
  }

  export type TestimonialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    userId?: StringFilter<"Testimonial"> | string
    name?: StringFilter<"Testimonial"> | string
    position?: StringFilter<"Testimonial"> | string
    company?: StringFilter<"Testimonial"> | string
    text?: StringFilter<"Testimonial"> | string
    avatar?: StringNullableFilter<"Testimonial"> | string | null
    rating?: IntFilter<"Testimonial"> | number
    date?: DateTimeFilter<"Testimonial"> | Date | string
    relation?: StringFilter<"Testimonial"> | string
    projectLink?: StringNullableFilter<"Testimonial"> | string | null
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"Testimonial"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    projectTestimonials?: ProjectTestimonialListRelationFilter
  }, "id">

  export type TestimonialOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    position?: SortOrder
    company?: SortOrder
    text?: SortOrder
    avatar?: SortOrderInput | SortOrder
    rating?: SortOrder
    date?: SortOrder
    relation?: SortOrder
    projectLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestimonialCountOrderByAggregateInput
    _avg?: TestimonialAvgOrderByAggregateInput
    _max?: TestimonialMaxOrderByAggregateInput
    _min?: TestimonialMinOrderByAggregateInput
    _sum?: TestimonialSumOrderByAggregateInput
  }

  export type TestimonialScalarWhereWithAggregatesInput = {
    AND?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    OR?: TestimonialScalarWhereWithAggregatesInput[]
    NOT?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Testimonial"> | string
    userId?: StringWithAggregatesFilter<"Testimonial"> | string
    name?: StringWithAggregatesFilter<"Testimonial"> | string
    position?: StringWithAggregatesFilter<"Testimonial"> | string
    company?: StringWithAggregatesFilter<"Testimonial"> | string
    text?: StringWithAggregatesFilter<"Testimonial"> | string
    avatar?: StringNullableWithAggregatesFilter<"Testimonial"> | string | null
    rating?: IntWithAggregatesFilter<"Testimonial"> | number
    date?: DateTimeWithAggregatesFilter<"Testimonial"> | Date | string
    relation?: StringWithAggregatesFilter<"Testimonial"> | string
    projectLink?: StringNullableWithAggregatesFilter<"Testimonial"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Testimonial"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    userId?: StringFilter<"Contact"> | string
    type?: StringFilter<"Contact"> | string
    value?: StringFilter<"Contact"> | string
    icon?: StringNullableFilter<"Contact"> | string | null
    isPublic?: BoolFilter<"Contact"> | boolean
    link?: StringNullableFilter<"Contact"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    icon?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    link?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    userId?: StringFilter<"Contact"> | string
    type?: StringFilter<"Contact"> | string
    value?: StringFilter<"Contact"> | string
    icon?: StringNullableFilter<"Contact"> | string | null
    isPublic?: BoolFilter<"Contact"> | boolean
    link?: StringNullableFilter<"Contact"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    icon?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    link?: SortOrderInput | SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    userId?: StringWithAggregatesFilter<"Contact"> | string
    type?: StringWithAggregatesFilter<"Contact"> | string
    value?: StringWithAggregatesFilter<"Contact"> | string
    icon?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    isPublic?: BoolWithAggregatesFilter<"Contact"> | boolean
    link?: StringNullableWithAggregatesFilter<"Contact"> | string | null
  }

  export type SocialMediaWhereInput = {
    AND?: SocialMediaWhereInput | SocialMediaWhereInput[]
    OR?: SocialMediaWhereInput[]
    NOT?: SocialMediaWhereInput | SocialMediaWhereInput[]
    id?: StringFilter<"SocialMedia"> | string
    userId?: StringFilter<"SocialMedia"> | string
    platform?: StringFilter<"SocialMedia"> | string
    url?: StringFilter<"SocialMedia"> | string
    icon?: StringNullableFilter<"SocialMedia"> | string | null
    username?: StringFilter<"SocialMedia"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SocialMediaOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    icon?: SortOrderInput | SortOrder
    username?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SocialMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SocialMediaWhereInput | SocialMediaWhereInput[]
    OR?: SocialMediaWhereInput[]
    NOT?: SocialMediaWhereInput | SocialMediaWhereInput[]
    userId?: StringFilter<"SocialMedia"> | string
    platform?: StringFilter<"SocialMedia"> | string
    url?: StringFilter<"SocialMedia"> | string
    icon?: StringNullableFilter<"SocialMedia"> | string | null
    username?: StringFilter<"SocialMedia"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SocialMediaOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    icon?: SortOrderInput | SortOrder
    username?: SortOrder
    _count?: SocialMediaCountOrderByAggregateInput
    _max?: SocialMediaMaxOrderByAggregateInput
    _min?: SocialMediaMinOrderByAggregateInput
  }

  export type SocialMediaScalarWhereWithAggregatesInput = {
    AND?: SocialMediaScalarWhereWithAggregatesInput | SocialMediaScalarWhereWithAggregatesInput[]
    OR?: SocialMediaScalarWhereWithAggregatesInput[]
    NOT?: SocialMediaScalarWhereWithAggregatesInput | SocialMediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialMedia"> | string
    userId?: StringWithAggregatesFilter<"SocialMedia"> | string
    platform?: StringWithAggregatesFilter<"SocialMedia"> | string
    url?: StringWithAggregatesFilter<"SocialMedia"> | string
    icon?: StringNullableWithAggregatesFilter<"SocialMedia"> | string | null
    username?: StringWithAggregatesFilter<"SocialMedia"> | string
  }

  export type DevStatsWhereInput = {
    AND?: DevStatsWhereInput | DevStatsWhereInput[]
    OR?: DevStatsWhereInput[]
    NOT?: DevStatsWhereInput | DevStatsWhereInput[]
    id?: StringFilter<"DevStats"> | string
    userId?: StringFilter<"DevStats"> | string
    repos?: IntFilter<"DevStats"> | number
    stars?: IntFilter<"DevStats"> | number
    contributions?: IntFilter<"DevStats"> | number
    rating?: FloatFilter<"DevStats"> | number
    followers?: IntFilter<"DevStats"> | number
    following?: IntFilter<"DevStats"> | number
    streak?: IntFilter<"DevStats"> | number
    commits?: IntFilter<"DevStats"> | number
    prsOpened?: IntFilter<"DevStats"> | number
    issuesClosed?: IntFilter<"DevStats"> | number
    rank?: StringNullableFilter<"DevStats"> | string | null
    createdAt?: DateTimeFilter<"DevStats"> | Date | string
    updatedAt?: DateTimeFilter<"DevStats"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DevStatsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    repos?: SortOrder
    stars?: SortOrder
    contributions?: SortOrder
    rating?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    streak?: SortOrder
    commits?: SortOrder
    prsOpened?: SortOrder
    issuesClosed?: SortOrder
    rank?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DevStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: DevStatsWhereInput | DevStatsWhereInput[]
    OR?: DevStatsWhereInput[]
    NOT?: DevStatsWhereInput | DevStatsWhereInput[]
    repos?: IntFilter<"DevStats"> | number
    stars?: IntFilter<"DevStats"> | number
    contributions?: IntFilter<"DevStats"> | number
    rating?: FloatFilter<"DevStats"> | number
    followers?: IntFilter<"DevStats"> | number
    following?: IntFilter<"DevStats"> | number
    streak?: IntFilter<"DevStats"> | number
    commits?: IntFilter<"DevStats"> | number
    prsOpened?: IntFilter<"DevStats"> | number
    issuesClosed?: IntFilter<"DevStats"> | number
    rank?: StringNullableFilter<"DevStats"> | string | null
    createdAt?: DateTimeFilter<"DevStats"> | Date | string
    updatedAt?: DateTimeFilter<"DevStats"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type DevStatsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    repos?: SortOrder
    stars?: SortOrder
    contributions?: SortOrder
    rating?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    streak?: SortOrder
    commits?: SortOrder
    prsOpened?: SortOrder
    issuesClosed?: SortOrder
    rank?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DevStatsCountOrderByAggregateInput
    _avg?: DevStatsAvgOrderByAggregateInput
    _max?: DevStatsMaxOrderByAggregateInput
    _min?: DevStatsMinOrderByAggregateInput
    _sum?: DevStatsSumOrderByAggregateInput
  }

  export type DevStatsScalarWhereWithAggregatesInput = {
    AND?: DevStatsScalarWhereWithAggregatesInput | DevStatsScalarWhereWithAggregatesInput[]
    OR?: DevStatsScalarWhereWithAggregatesInput[]
    NOT?: DevStatsScalarWhereWithAggregatesInput | DevStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DevStats"> | string
    userId?: StringWithAggregatesFilter<"DevStats"> | string
    repos?: IntWithAggregatesFilter<"DevStats"> | number
    stars?: IntWithAggregatesFilter<"DevStats"> | number
    contributions?: IntWithAggregatesFilter<"DevStats"> | number
    rating?: FloatWithAggregatesFilter<"DevStats"> | number
    followers?: IntWithAggregatesFilter<"DevStats"> | number
    following?: IntWithAggregatesFilter<"DevStats"> | number
    streak?: IntWithAggregatesFilter<"DevStats"> | number
    commits?: IntWithAggregatesFilter<"DevStats"> | number
    prsOpened?: IntWithAggregatesFilter<"DevStats"> | number
    issuesClosed?: IntWithAggregatesFilter<"DevStats"> | number
    rank?: StringNullableWithAggregatesFilter<"DevStats"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DevStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DevStats"> | Date | string
  }

  export type ContributionDataWhereInput = {
    AND?: ContributionDataWhereInput | ContributionDataWhereInput[]
    OR?: ContributionDataWhereInput[]
    NOT?: ContributionDataWhereInput | ContributionDataWhereInput[]
    id?: StringFilter<"ContributionData"> | string
    userId?: StringFilter<"ContributionData"> | string
    year?: IntFilter<"ContributionData"> | number
    total?: IntFilter<"ContributionData"> | number
    startRange?: DateTimeFilter<"ContributionData"> | Date | string
    endRange?: DateTimeFilter<"ContributionData"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    days?: ContributionDayListRelationFilter
  }

  export type ContributionDataOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    total?: SortOrder
    startRange?: SortOrder
    endRange?: SortOrder
    user?: UserOrderByWithRelationInput
    days?: ContributionDayOrderByRelationAggregateInput
  }

  export type ContributionDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContributionDataWhereInput | ContributionDataWhereInput[]
    OR?: ContributionDataWhereInput[]
    NOT?: ContributionDataWhereInput | ContributionDataWhereInput[]
    userId?: StringFilter<"ContributionData"> | string
    year?: IntFilter<"ContributionData"> | number
    total?: IntFilter<"ContributionData"> | number
    startRange?: DateTimeFilter<"ContributionData"> | Date | string
    endRange?: DateTimeFilter<"ContributionData"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    days?: ContributionDayListRelationFilter
  }, "id">

  export type ContributionDataOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    total?: SortOrder
    startRange?: SortOrder
    endRange?: SortOrder
    _count?: ContributionDataCountOrderByAggregateInput
    _avg?: ContributionDataAvgOrderByAggregateInput
    _max?: ContributionDataMaxOrderByAggregateInput
    _min?: ContributionDataMinOrderByAggregateInput
    _sum?: ContributionDataSumOrderByAggregateInput
  }

  export type ContributionDataScalarWhereWithAggregatesInput = {
    AND?: ContributionDataScalarWhereWithAggregatesInput | ContributionDataScalarWhereWithAggregatesInput[]
    OR?: ContributionDataScalarWhereWithAggregatesInput[]
    NOT?: ContributionDataScalarWhereWithAggregatesInput | ContributionDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContributionData"> | string
    userId?: StringWithAggregatesFilter<"ContributionData"> | string
    year?: IntWithAggregatesFilter<"ContributionData"> | number
    total?: IntWithAggregatesFilter<"ContributionData"> | number
    startRange?: DateTimeWithAggregatesFilter<"ContributionData"> | Date | string
    endRange?: DateTimeWithAggregatesFilter<"ContributionData"> | Date | string
  }

  export type ContributionDayWhereInput = {
    AND?: ContributionDayWhereInput | ContributionDayWhereInput[]
    OR?: ContributionDayWhereInput[]
    NOT?: ContributionDayWhereInput | ContributionDayWhereInput[]
    id?: StringFilter<"ContributionDay"> | string
    contributionDataId?: StringFilter<"ContributionDay"> | string
    date?: DateTimeFilter<"ContributionDay"> | Date | string
    count?: IntFilter<"ContributionDay"> | number
    level?: IntFilter<"ContributionDay"> | number
    contributionData?: XOR<ContributionDataScalarRelationFilter, ContributionDataWhereInput>
  }

  export type ContributionDayOrderByWithRelationInput = {
    id?: SortOrder
    contributionDataId?: SortOrder
    date?: SortOrder
    count?: SortOrder
    level?: SortOrder
    contributionData?: ContributionDataOrderByWithRelationInput
  }

  export type ContributionDayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContributionDayWhereInput | ContributionDayWhereInput[]
    OR?: ContributionDayWhereInput[]
    NOT?: ContributionDayWhereInput | ContributionDayWhereInput[]
    contributionDataId?: StringFilter<"ContributionDay"> | string
    date?: DateTimeFilter<"ContributionDay"> | Date | string
    count?: IntFilter<"ContributionDay"> | number
    level?: IntFilter<"ContributionDay"> | number
    contributionData?: XOR<ContributionDataScalarRelationFilter, ContributionDataWhereInput>
  }, "id">

  export type ContributionDayOrderByWithAggregationInput = {
    id?: SortOrder
    contributionDataId?: SortOrder
    date?: SortOrder
    count?: SortOrder
    level?: SortOrder
    _count?: ContributionDayCountOrderByAggregateInput
    _avg?: ContributionDayAvgOrderByAggregateInput
    _max?: ContributionDayMaxOrderByAggregateInput
    _min?: ContributionDayMinOrderByAggregateInput
    _sum?: ContributionDaySumOrderByAggregateInput
  }

  export type ContributionDayScalarWhereWithAggregatesInput = {
    AND?: ContributionDayScalarWhereWithAggregatesInput | ContributionDayScalarWhereWithAggregatesInput[]
    OR?: ContributionDayScalarWhereWithAggregatesInput[]
    NOT?: ContributionDayScalarWhereWithAggregatesInput | ContributionDayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContributionDay"> | string
    contributionDataId?: StringWithAggregatesFilter<"ContributionDay"> | string
    date?: DateTimeWithAggregatesFilter<"ContributionDay"> | Date | string
    count?: IntWithAggregatesFilter<"ContributionDay"> | number
    level?: IntWithAggregatesFilter<"ContributionDay"> | number
  }

  export type TimelineEventWhereInput = {
    AND?: TimelineEventWhereInput | TimelineEventWhereInput[]
    OR?: TimelineEventWhereInput[]
    NOT?: TimelineEventWhereInput | TimelineEventWhereInput[]
    id?: StringFilter<"TimelineEvent"> | string
    userId?: StringFilter<"TimelineEvent"> | string
    date?: DateTimeFilter<"TimelineEvent"> | Date | string
    type?: StringFilter<"TimelineEvent"> | string
    title?: StringFilter<"TimelineEvent"> | string
    subtitle?: StringNullableFilter<"TimelineEvent"> | string | null
    description?: StringNullableFilter<"TimelineEvent"> | string | null
    icon?: StringNullableFilter<"TimelineEvent"> | string | null
    color?: StringNullableFilter<"TimelineEvent"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TimelineEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TimelineEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimelineEventWhereInput | TimelineEventWhereInput[]
    OR?: TimelineEventWhereInput[]
    NOT?: TimelineEventWhereInput | TimelineEventWhereInput[]
    userId?: StringFilter<"TimelineEvent"> | string
    date?: DateTimeFilter<"TimelineEvent"> | Date | string
    type?: StringFilter<"TimelineEvent"> | string
    title?: StringFilter<"TimelineEvent"> | string
    subtitle?: StringNullableFilter<"TimelineEvent"> | string | null
    description?: StringNullableFilter<"TimelineEvent"> | string | null
    icon?: StringNullableFilter<"TimelineEvent"> | string | null
    color?: StringNullableFilter<"TimelineEvent"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TimelineEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    _count?: TimelineEventCountOrderByAggregateInput
    _max?: TimelineEventMaxOrderByAggregateInput
    _min?: TimelineEventMinOrderByAggregateInput
  }

  export type TimelineEventScalarWhereWithAggregatesInput = {
    AND?: TimelineEventScalarWhereWithAggregatesInput | TimelineEventScalarWhereWithAggregatesInput[]
    OR?: TimelineEventScalarWhereWithAggregatesInput[]
    NOT?: TimelineEventScalarWhereWithAggregatesInput | TimelineEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimelineEvent"> | string
    userId?: StringWithAggregatesFilter<"TimelineEvent"> | string
    date?: DateTimeWithAggregatesFilter<"TimelineEvent"> | Date | string
    type?: StringWithAggregatesFilter<"TimelineEvent"> | string
    title?: StringWithAggregatesFilter<"TimelineEvent"> | string
    subtitle?: StringNullableWithAggregatesFilter<"TimelineEvent"> | string | null
    description?: StringNullableWithAggregatesFilter<"TimelineEvent"> | string | null
    icon?: StringNullableWithAggregatesFilter<"TimelineEvent"> | string | null
    color?: StringNullableWithAggregatesFilter<"TimelineEvent"> | string | null
  }

  export type ProjectTestimonialWhereInput = {
    AND?: ProjectTestimonialWhereInput | ProjectTestimonialWhereInput[]
    OR?: ProjectTestimonialWhereInput[]
    NOT?: ProjectTestimonialWhereInput | ProjectTestimonialWhereInput[]
    id?: StringFilter<"ProjectTestimonial"> | string
    projectId?: StringFilter<"ProjectTestimonial"> | string
    testimonialId?: StringFilter<"ProjectTestimonial"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    testimonial?: XOR<TestimonialScalarRelationFilter, TestimonialWhereInput>
  }

  export type ProjectTestimonialOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    testimonialId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    testimonial?: TestimonialOrderByWithRelationInput
  }

  export type ProjectTestimonialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_testimonialId?: ProjectTestimonialProjectIdTestimonialIdCompoundUniqueInput
    AND?: ProjectTestimonialWhereInput | ProjectTestimonialWhereInput[]
    OR?: ProjectTestimonialWhereInput[]
    NOT?: ProjectTestimonialWhereInput | ProjectTestimonialWhereInput[]
    projectId?: StringFilter<"ProjectTestimonial"> | string
    testimonialId?: StringFilter<"ProjectTestimonial"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    testimonial?: XOR<TestimonialScalarRelationFilter, TestimonialWhereInput>
  }, "id" | "projectId_testimonialId">

  export type ProjectTestimonialOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    testimonialId?: SortOrder
    _count?: ProjectTestimonialCountOrderByAggregateInput
    _max?: ProjectTestimonialMaxOrderByAggregateInput
    _min?: ProjectTestimonialMinOrderByAggregateInput
  }

  export type ProjectTestimonialScalarWhereWithAggregatesInput = {
    AND?: ProjectTestimonialScalarWhereWithAggregatesInput | ProjectTestimonialScalarWhereWithAggregatesInput[]
    OR?: ProjectTestimonialScalarWhereWithAggregatesInput[]
    NOT?: ProjectTestimonialScalarWhereWithAggregatesInput | ProjectTestimonialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectTestimonial"> | string
    projectId?: StringWithAggregatesFilter<"ProjectTestimonial"> | string
    testimonialId?: StringWithAggregatesFilter<"ProjectTestimonial"> | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceCreateNestedManyWithoutUserInput
    educations?: EducationCreateNestedManyWithoutUserInput
    certifications?: CertificationCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaCreateNestedManyWithoutUserInput
    devStats?: DevStatsCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceUncheckedCreateNestedManyWithoutUserInput
    educations?: EducationUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaUncheckedCreateNestedManyWithoutUserInput
    devStats?: DevStatsUncheckedCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataUncheckedCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUpdateManyWithoutUserNestedInput
    educations?: EducationUpdateManyWithoutUserNestedInput
    certifications?: CertificationUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUncheckedUpdateManyWithoutUserNestedInput
    educations?: EducationUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUncheckedUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUncheckedUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUncheckedUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillCreateInput = {
    id?: string
    name: string
    percentage: number
    color?: string | null
    icon?: string | null
    category?: string | null
    description?: string | null
    years?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSkillsInput
    projects?: ProjectCreateNestedManyWithoutSkillsInput
  }

  export type SkillUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    percentage: number
    color?: string | null
    icon?: string | null
    category?: string | null
    description?: string | null
    years?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutSkillsInput
  }

  export type SkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    years?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSkillsNestedInput
    projects?: ProjectUpdateManyWithoutSkillsNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    years?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutSkillsNestedInput
  }

  export type SkillCreateManyInput = {
    id?: string
    userId: string
    name: string
    percentage: number
    color?: string | null
    icon?: string | null
    category?: string | null
    description?: string | null
    years?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    years?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    years?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    features?: ProjectFeatureCreateNestedManyWithoutProjectInput
    techStack?: ProjectTechStackCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    learnings?: ProjectLearningCreateNestedManyWithoutProjectInput
    testimonials?: ProjectTestimonialCreateNestedManyWithoutProjectInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: ProjectFeatureUncheckedCreateNestedManyWithoutProjectInput
    techStack?: ProjectTechStackUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    learnings?: ProjectLearningUncheckedCreateNestedManyWithoutProjectInput
    testimonials?: ProjectTestimonialUncheckedCreateNestedManyWithoutProjectInput
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    features?: ProjectFeatureUpdateManyWithoutProjectNestedInput
    techStack?: ProjectTechStackUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    learnings?: ProjectLearningUpdateManyWithoutProjectNestedInput
    testimonials?: ProjectTestimonialUpdateManyWithoutProjectNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: ProjectFeatureUncheckedUpdateManyWithoutProjectNestedInput
    techStack?: ProjectTechStackUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    learnings?: ProjectLearningUncheckedUpdateManyWithoutProjectNestedInput
    testimonials?: ProjectTestimonialUncheckedUpdateManyWithoutProjectNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    userId: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFeatureCreateInput = {
    id?: string
    feature: string
    project: ProjectCreateNestedOneWithoutFeaturesInput
  }

  export type ProjectFeatureUncheckedCreateInput = {
    id?: string
    projectId: string
    feature: string
  }

  export type ProjectFeatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type ProjectFeatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectFeatureCreateManyInput = {
    id?: string
    projectId: string
    feature: string
  }

  export type ProjectFeatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectFeatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTechStackCreateInput = {
    id?: string
    tech: string
    project: ProjectCreateNestedOneWithoutTechStackInput
  }

  export type ProjectTechStackUncheckedCreateInput = {
    id?: string
    projectId: string
    tech: string
  }

  export type ProjectTechStackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tech?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutTechStackNestedInput
  }

  export type ProjectTechStackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    tech?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTechStackCreateManyInput = {
    id?: string
    projectId: string
    tech: string
  }

  export type ProjectTechStackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tech?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTechStackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    tech?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCollaboratorCreateInput = {
    id?: string
    name: string
    username: string
    project: ProjectCreateNestedOneWithoutCollaboratorsInput
  }

  export type ProjectCollaboratorUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    username: string
  }

  export type ProjectCollaboratorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutCollaboratorsNestedInput
  }

  export type ProjectCollaboratorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCollaboratorCreateManyInput = {
    id?: string
    projectId: string
    name: string
    username: string
  }

  export type ProjectCollaboratorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCollaboratorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectLearningCreateInput = {
    id?: string
    learning: string
    project: ProjectCreateNestedOneWithoutLearningsInput
  }

  export type ProjectLearningUncheckedCreateInput = {
    id?: string
    projectId: string
    learning: string
  }

  export type ProjectLearningUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    learning?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutLearningsNestedInput
  }

  export type ProjectLearningUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    learning?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectLearningCreateManyInput = {
    id?: string
    projectId: string
    learning: string
  }

  export type ProjectLearningUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    learning?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectLearningUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    learning?: StringFieldUpdateOperationsInput | string
  }

  export type WorkExperienceCreateInput = {
    id?: string
    company: string
    position: string
    period: string
    description?: string | null
    location?: string | null
    type?: string | null
    logo?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWorkExperiencesInput
    responsibilities?: WorkResponsibilityCreateNestedManyWithoutWorkExperienceInput
    technologies?: WorkTechnologyCreateNestedManyWithoutWorkExperienceInput
    achievements?: WorkAchievementCreateNestedManyWithoutWorkExperienceInput
  }

  export type WorkExperienceUncheckedCreateInput = {
    id?: string
    userId: string
    company: string
    position: string
    period: string
    description?: string | null
    location?: string | null
    type?: string | null
    logo?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibilities?: WorkResponsibilityUncheckedCreateNestedManyWithoutWorkExperienceInput
    technologies?: WorkTechnologyUncheckedCreateNestedManyWithoutWorkExperienceInput
    achievements?: WorkAchievementUncheckedCreateNestedManyWithoutWorkExperienceInput
  }

  export type WorkExperienceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkExperiencesNestedInput
    responsibilities?: WorkResponsibilityUpdateManyWithoutWorkExperienceNestedInput
    technologies?: WorkTechnologyUpdateManyWithoutWorkExperienceNestedInput
    achievements?: WorkAchievementUpdateManyWithoutWorkExperienceNestedInput
  }

  export type WorkExperienceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibilities?: WorkResponsibilityUncheckedUpdateManyWithoutWorkExperienceNestedInput
    technologies?: WorkTechnologyUncheckedUpdateManyWithoutWorkExperienceNestedInput
    achievements?: WorkAchievementUncheckedUpdateManyWithoutWorkExperienceNestedInput
  }

  export type WorkExperienceCreateManyInput = {
    id?: string
    userId: string
    company: string
    position: string
    period: string
    description?: string | null
    location?: string | null
    type?: string | null
    logo?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkExperienceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkExperienceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkResponsibilityCreateInput = {
    id?: string
    responsibility: string
    workExperience: WorkExperienceCreateNestedOneWithoutResponsibilitiesInput
  }

  export type WorkResponsibilityUncheckedCreateInput = {
    id?: string
    experienceId: string
    responsibility: string
  }

  export type WorkResponsibilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    workExperience?: WorkExperienceUpdateOneRequiredWithoutResponsibilitiesNestedInput
  }

  export type WorkResponsibilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceId?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
  }

  export type WorkResponsibilityCreateManyInput = {
    id?: string
    experienceId: string
    responsibility: string
  }

  export type WorkResponsibilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
  }

  export type WorkResponsibilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceId?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
  }

  export type WorkTechnologyCreateInput = {
    id?: string
    technology: string
    workExperience: WorkExperienceCreateNestedOneWithoutTechnologiesInput
  }

  export type WorkTechnologyUncheckedCreateInput = {
    id?: string
    experienceId: string
    technology: string
  }

  export type WorkTechnologyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    technology?: StringFieldUpdateOperationsInput | string
    workExperience?: WorkExperienceUpdateOneRequiredWithoutTechnologiesNestedInput
  }

  export type WorkTechnologyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceId?: StringFieldUpdateOperationsInput | string
    technology?: StringFieldUpdateOperationsInput | string
  }

  export type WorkTechnologyCreateManyInput = {
    id?: string
    experienceId: string
    technology: string
  }

  export type WorkTechnologyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    technology?: StringFieldUpdateOperationsInput | string
  }

  export type WorkTechnologyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceId?: StringFieldUpdateOperationsInput | string
    technology?: StringFieldUpdateOperationsInput | string
  }

  export type WorkAchievementCreateInput = {
    id?: string
    achievement: string
    workExperience: WorkExperienceCreateNestedOneWithoutAchievementsInput
  }

  export type WorkAchievementUncheckedCreateInput = {
    id?: string
    experienceId: string
    achievement: string
  }

  export type WorkAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
    workExperience?: WorkExperienceUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type WorkAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceId?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
  }

  export type WorkAchievementCreateManyInput = {
    id?: string
    experienceId: string
    achievement: string
  }

  export type WorkAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
  }

  export type WorkAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceId?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
  }

  export type EducationCreateInput = {
    id?: string
    institution: string
    degree: string
    field: string
    period: string
    description?: string | null
    gpa?: string | null
    location?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEducationsInput
    achievements?: EducationAchievementCreateNestedManyWithoutEducationInput
  }

  export type EducationUncheckedCreateInput = {
    id?: string
    userId: string
    institution: string
    degree: string
    field: string
    period: string
    description?: string | null
    gpa?: string | null
    location?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: EducationAchievementUncheckedCreateNestedManyWithoutEducationInput
  }

  export type EducationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEducationsNestedInput
    achievements?: EducationAchievementUpdateManyWithoutEducationNestedInput
  }

  export type EducationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: EducationAchievementUncheckedUpdateManyWithoutEducationNestedInput
  }

  export type EducationCreateManyInput = {
    id?: string
    userId: string
    institution: string
    degree: string
    field: string
    period: string
    description?: string | null
    gpa?: string | null
    location?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EducationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationAchievementCreateInput = {
    id?: string
    achievement: string
    education: EducationCreateNestedOneWithoutAchievementsInput
  }

  export type EducationAchievementUncheckedCreateInput = {
    id?: string
    educationId: string
    achievement: string
  }

  export type EducationAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
    education?: EducationUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type EducationAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    educationId?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
  }

  export type EducationAchievementCreateManyInput = {
    id?: string
    educationId: string
    achievement: string
  }

  export type EducationAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
  }

  export type EducationAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    educationId?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
  }

  export type CertificationCreateInput = {
    id?: string
    name: string
    issuer: string
    date: Date | string
    icon?: string | null
    credentialId?: string | null
    expiry?: Date | string | null
    description?: string | null
    verificationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCertificationsInput
    skills?: CertificationSkillCreateNestedManyWithoutCertificationInput
  }

  export type CertificationUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    issuer: string
    date: Date | string
    icon?: string | null
    credentialId?: string | null
    expiry?: Date | string | null
    description?: string | null
    verificationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: CertificationSkillUncheckedCreateNestedManyWithoutCertificationInput
  }

  export type CertificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCertificationsNestedInput
    skills?: CertificationSkillUpdateManyWithoutCertificationNestedInput
  }

  export type CertificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: CertificationSkillUncheckedUpdateManyWithoutCertificationNestedInput
  }

  export type CertificationCreateManyInput = {
    id?: string
    userId: string
    name: string
    issuer: string
    date: Date | string
    icon?: string | null
    credentialId?: string | null
    expiry?: Date | string | null
    description?: string | null
    verificationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationSkillCreateInput = {
    id?: string
    skill: string
    certification: CertificationCreateNestedOneWithoutSkillsInput
  }

  export type CertificationSkillUncheckedCreateInput = {
    id?: string
    certificationId: string
    skill: string
  }

  export type CertificationSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    certification?: CertificationUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type CertificationSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificationId?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type CertificationSkillCreateManyInput = {
    id?: string
    certificationId: string
    skill: string
  }

  export type CertificationSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type CertificationSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificationId?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type AchievementCreateInput = {
    id?: string
    title: string
    date: Date | string
    description?: string | null
    icon?: string | null
    category?: string | null
    issuer?: string | null
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    date: Date | string
    description?: string | null
    icon?: string | null
    category?: string | null
    issuer?: string | null
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateManyInput = {
    id?: string
    userId: string
    title: string
    date: Date | string
    description?: string | null
    icon?: string | null
    category?: string | null
    issuer?: string | null
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateInput = {
    id?: string
    slug: string
    title: string
    excerpt: string
    content: string
    date: Date | string
    readTime: number
    image?: string | null
    likes?: number
    comments?: number
    shares?: number
    views?: number
    category: string
    author: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBlogPostsInput
    tags?: BlogTagCreateNestedManyWithoutBlogPostInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: string
    userId: string
    slug: string
    title: string
    excerpt: string
    content: string
    date: Date | string
    readTime: number
    image?: string | null
    likes?: number
    comments?: number
    shares?: number
    views?: number
    category: string
    author: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: BlogTagUncheckedCreateNestedManyWithoutBlogPostInput
  }

  export type BlogPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    tags?: BlogTagUpdateManyWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: BlogTagUncheckedUpdateManyWithoutBlogPostNestedInput
  }

  export type BlogPostCreateManyInput = {
    id?: string
    userId: string
    slug: string
    title: string
    excerpt: string
    content: string
    date: Date | string
    readTime: number
    image?: string | null
    likes?: number
    comments?: number
    shares?: number
    views?: number
    category: string
    author: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTagCreateInput = {
    id?: string
    tag: string
    blogPost: BlogPostCreateNestedOneWithoutTagsInput
  }

  export type BlogTagUncheckedCreateInput = {
    id?: string
    blogId: string
    tag: string
  }

  export type BlogTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    blogPost?: BlogPostUpdateOneRequiredWithoutTagsNestedInput
  }

  export type BlogTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type BlogTagCreateManyInput = {
    id?: string
    blogId: string
    tag: string
  }

  export type BlogTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type BlogTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type TestimonialCreateInput = {
    id?: string
    name: string
    position: string
    company: string
    text: string
    avatar?: string | null
    rating: number
    date: Date | string
    relation: string
    projectLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTestimonialsInput
    projectTestimonials?: ProjectTestimonialCreateNestedManyWithoutTestimonialInput
  }

  export type TestimonialUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    position: string
    company: string
    text: string
    avatar?: string | null
    rating: number
    date: Date | string
    relation: string
    projectLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTestimonials?: ProjectTestimonialUncheckedCreateNestedManyWithoutTestimonialInput
  }

  export type TestimonialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relation?: StringFieldUpdateOperationsInput | string
    projectLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTestimonialsNestedInput
    projectTestimonials?: ProjectTestimonialUpdateManyWithoutTestimonialNestedInput
  }

  export type TestimonialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relation?: StringFieldUpdateOperationsInput | string
    projectLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTestimonials?: ProjectTestimonialUncheckedUpdateManyWithoutTestimonialNestedInput
  }

  export type TestimonialCreateManyInput = {
    id?: string
    userId: string
    name: string
    position: string
    company: string
    text: string
    avatar?: string | null
    rating: number
    date: Date | string
    relation: string
    projectLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relation?: StringFieldUpdateOperationsInput | string
    projectLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relation?: StringFieldUpdateOperationsInput | string
    projectLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    type: string
    value: string
    icon?: string | null
    isPublic?: boolean
    link?: string | null
    user: UserCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    value: string
    icon?: string | null
    isPublic?: boolean
    link?: string | null
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactCreateManyInput = {
    id?: string
    userId: string
    type: string
    value: string
    icon?: string | null
    isPublic?: boolean
    link?: string | null
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialMediaCreateInput = {
    id?: string
    platform: string
    url: string
    icon?: string | null
    username: string
    user: UserCreateNestedOneWithoutSocialMediaInput
  }

  export type SocialMediaUncheckedCreateInput = {
    id?: string
    userId: string
    platform: string
    url: string
    icon?: string | null
    username: string
  }

  export type SocialMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutSocialMediaNestedInput
  }

  export type SocialMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
  }

  export type SocialMediaCreateManyInput = {
    id?: string
    userId: string
    platform: string
    url: string
    icon?: string | null
    username: string
  }

  export type SocialMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
  }

  export type SocialMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
  }

  export type DevStatsCreateInput = {
    id?: string
    repos?: number
    stars?: number
    contributions?: number
    rating?: number
    followers?: number
    following?: number
    streak?: number
    commits?: number
    prsOpened?: number
    issuesClosed?: number
    rank?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevStatsInput
  }

  export type DevStatsUncheckedCreateInput = {
    id?: string
    userId: string
    repos?: number
    stars?: number
    contributions?: number
    rating?: number
    followers?: number
    following?: number
    streak?: number
    commits?: number
    prsOpened?: number
    issuesClosed?: number
    rank?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DevStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    repos?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    contributions?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    commits?: IntFieldUpdateOperationsInput | number
    prsOpened?: IntFieldUpdateOperationsInput | number
    issuesClosed?: IntFieldUpdateOperationsInput | number
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevStatsNestedInput
  }

  export type DevStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    repos?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    contributions?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    commits?: IntFieldUpdateOperationsInput | number
    prsOpened?: IntFieldUpdateOperationsInput | number
    issuesClosed?: IntFieldUpdateOperationsInput | number
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevStatsCreateManyInput = {
    id?: string
    userId: string
    repos?: number
    stars?: number
    contributions?: number
    rating?: number
    followers?: number
    following?: number
    streak?: number
    commits?: number
    prsOpened?: number
    issuesClosed?: number
    rank?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DevStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    repos?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    contributions?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    commits?: IntFieldUpdateOperationsInput | number
    prsOpened?: IntFieldUpdateOperationsInput | number
    issuesClosed?: IntFieldUpdateOperationsInput | number
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    repos?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    contributions?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    commits?: IntFieldUpdateOperationsInput | number
    prsOpened?: IntFieldUpdateOperationsInput | number
    issuesClosed?: IntFieldUpdateOperationsInput | number
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContributionDataCreateInput = {
    id?: string
    year: number
    total: number
    startRange: Date | string
    endRange: Date | string
    user: UserCreateNestedOneWithoutContributionDataInput
    days?: ContributionDayCreateNestedManyWithoutContributionDataInput
  }

  export type ContributionDataUncheckedCreateInput = {
    id?: string
    userId: string
    year: number
    total: number
    startRange: Date | string
    endRange: Date | string
    days?: ContributionDayUncheckedCreateNestedManyWithoutContributionDataInput
  }

  export type ContributionDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    startRange?: DateTimeFieldUpdateOperationsInput | Date | string
    endRange?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContributionDataNestedInput
    days?: ContributionDayUpdateManyWithoutContributionDataNestedInput
  }

  export type ContributionDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    startRange?: DateTimeFieldUpdateOperationsInput | Date | string
    endRange?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ContributionDayUncheckedUpdateManyWithoutContributionDataNestedInput
  }

  export type ContributionDataCreateManyInput = {
    id?: string
    userId: string
    year: number
    total: number
    startRange: Date | string
    endRange: Date | string
  }

  export type ContributionDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    startRange?: DateTimeFieldUpdateOperationsInput | Date | string
    endRange?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContributionDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    startRange?: DateTimeFieldUpdateOperationsInput | Date | string
    endRange?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContributionDayCreateInput = {
    id?: string
    date: Date | string
    count: number
    level: number
    contributionData: ContributionDataCreateNestedOneWithoutDaysInput
  }

  export type ContributionDayUncheckedCreateInput = {
    id?: string
    contributionDataId: string
    date: Date | string
    count: number
    level: number
  }

  export type ContributionDayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    contributionData?: ContributionDataUpdateOneRequiredWithoutDaysNestedInput
  }

  export type ContributionDayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contributionDataId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type ContributionDayCreateManyInput = {
    id?: string
    contributionDataId: string
    date: Date | string
    count: number
    level: number
  }

  export type ContributionDayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type ContributionDayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contributionDataId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type TimelineEventCreateInput = {
    id?: string
    date: Date | string
    type: string
    title: string
    subtitle?: string | null
    description?: string | null
    icon?: string | null
    color?: string | null
    user: UserCreateNestedOneWithoutTimelineEventsInput
  }

  export type TimelineEventUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    type: string
    title: string
    subtitle?: string | null
    description?: string | null
    icon?: string | null
    color?: string | null
  }

  export type TimelineEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTimelineEventsNestedInput
  }

  export type TimelineEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimelineEventCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    type: string
    title: string
    subtitle?: string | null
    description?: string | null
    icon?: string | null
    color?: string | null
  }

  export type TimelineEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimelineEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectTestimonialCreateInput = {
    id?: string
    project: ProjectCreateNestedOneWithoutTestimonialsInput
    testimonial: TestimonialCreateNestedOneWithoutProjectTestimonialsInput
  }

  export type ProjectTestimonialUncheckedCreateInput = {
    id?: string
    projectId: string
    testimonialId: string
  }

  export type ProjectTestimonialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutTestimonialsNestedInput
    testimonial?: TestimonialUpdateOneRequiredWithoutProjectTestimonialsNestedInput
  }

  export type ProjectTestimonialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    testimonialId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTestimonialCreateManyInput = {
    id?: string
    projectId: string
    testimonialId: string
  }

  export type ProjectTestimonialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTestimonialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    testimonialId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SkillListRelationFilter = {
    every?: SkillWhereInput
    some?: SkillWhereInput
    none?: SkillWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type WorkExperienceListRelationFilter = {
    every?: WorkExperienceWhereInput
    some?: WorkExperienceWhereInput
    none?: WorkExperienceWhereInput
  }

  export type EducationListRelationFilter = {
    every?: EducationWhereInput
    some?: EducationWhereInput
    none?: EducationWhereInput
  }

  export type CertificationListRelationFilter = {
    every?: CertificationWhereInput
    some?: CertificationWhereInput
    none?: CertificationWhereInput
  }

  export type AchievementListRelationFilter = {
    every?: AchievementWhereInput
    some?: AchievementWhereInput
    none?: AchievementWhereInput
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type TestimonialListRelationFilter = {
    every?: TestimonialWhereInput
    some?: TestimonialWhereInput
    none?: TestimonialWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type SocialMediaListRelationFilter = {
    every?: SocialMediaWhereInput
    some?: SocialMediaWhereInput
    none?: SocialMediaWhereInput
  }

  export type DevStatsNullableScalarRelationFilter = {
    is?: DevStatsWhereInput | null
    isNot?: DevStatsWhereInput | null
  }

  export type ContributionDataListRelationFilter = {
    every?: ContributionDataWhereInput
    some?: ContributionDataWhereInput
    none?: ContributionDataWhereInput
  }

  export type TimelineEventListRelationFilter = {
    every?: TimelineEventWhereInput
    some?: TimelineEventWhereInput
    none?: TimelineEventWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkExperienceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EducationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestimonialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContributionDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimelineEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    bio?: SortOrder
    website?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    bio?: SortOrder
    website?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    bio?: SortOrder
    website?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    description?: SortOrder
    years?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillAvgOrderByAggregateInput = {
    percentage?: SortOrder
    years?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    description?: SortOrder
    years?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    description?: SortOrder
    years?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillSumOrderByAggregateInput = {
    percentage?: SortOrder
    years?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProjectFeatureListRelationFilter = {
    every?: ProjectFeatureWhereInput
    some?: ProjectFeatureWhereInput
    none?: ProjectFeatureWhereInput
  }

  export type ProjectTechStackListRelationFilter = {
    every?: ProjectTechStackWhereInput
    some?: ProjectTechStackWhereInput
    none?: ProjectTechStackWhereInput
  }

  export type ProjectCollaboratorListRelationFilter = {
    every?: ProjectCollaboratorWhereInput
    some?: ProjectCollaboratorWhereInput
    none?: ProjectCollaboratorWhereInput
  }

  export type ProjectLearningListRelationFilter = {
    every?: ProjectLearningWhereInput
    some?: ProjectLearningWhereInput
    none?: ProjectLearningWhereInput
  }

  export type ProjectTestimonialListRelationFilter = {
    every?: ProjectTestimonialWhereInput
    some?: ProjectTestimonialWhereInput
    none?: ProjectTestimonialWhereInput
  }

  export type ProjectFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectTechStackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCollaboratorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectLearningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectTestimonialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    longDescription?: SortOrder
    category?: SortOrder
    image?: SortOrder
    demoUrl?: SortOrder
    githubUrl?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    branches?: SortOrder
    stars?: SortOrder
    views?: SortOrder
    forks?: SortOrder
    issues?: SortOrder
    commits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    branches?: SortOrder
    stars?: SortOrder
    views?: SortOrder
    forks?: SortOrder
    issues?: SortOrder
    commits?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    longDescription?: SortOrder
    category?: SortOrder
    image?: SortOrder
    demoUrl?: SortOrder
    githubUrl?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    branches?: SortOrder
    stars?: SortOrder
    views?: SortOrder
    forks?: SortOrder
    issues?: SortOrder
    commits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    longDescription?: SortOrder
    category?: SortOrder
    image?: SortOrder
    demoUrl?: SortOrder
    githubUrl?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    branches?: SortOrder
    stars?: SortOrder
    views?: SortOrder
    forks?: SortOrder
    issues?: SortOrder
    commits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    branches?: SortOrder
    stars?: SortOrder
    views?: SortOrder
    forks?: SortOrder
    issues?: SortOrder
    commits?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    feature?: SortOrder
  }

  export type ProjectFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    feature?: SortOrder
  }

  export type ProjectFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    feature?: SortOrder
  }

  export type ProjectTechStackCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    tech?: SortOrder
  }

  export type ProjectTechStackMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    tech?: SortOrder
  }

  export type ProjectTechStackMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    tech?: SortOrder
  }

  export type ProjectCollaboratorCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    username?: SortOrder
  }

  export type ProjectCollaboratorMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    username?: SortOrder
  }

  export type ProjectCollaboratorMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    username?: SortOrder
  }

  export type ProjectLearningCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    learning?: SortOrder
  }

  export type ProjectLearningMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    learning?: SortOrder
  }

  export type ProjectLearningMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    learning?: SortOrder
  }

  export type WorkResponsibilityListRelationFilter = {
    every?: WorkResponsibilityWhereInput
    some?: WorkResponsibilityWhereInput
    none?: WorkResponsibilityWhereInput
  }

  export type WorkTechnologyListRelationFilter = {
    every?: WorkTechnologyWhereInput
    some?: WorkTechnologyWhereInput
    none?: WorkTechnologyWhereInput
  }

  export type WorkAchievementListRelationFilter = {
    every?: WorkAchievementWhereInput
    some?: WorkAchievementWhereInput
    none?: WorkAchievementWhereInput
  }

  export type WorkResponsibilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkTechnologyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkExperienceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    position?: SortOrder
    period?: SortOrder
    description?: SortOrder
    location?: SortOrder
    type?: SortOrder
    logo?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkExperienceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    position?: SortOrder
    period?: SortOrder
    description?: SortOrder
    location?: SortOrder
    type?: SortOrder
    logo?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkExperienceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    position?: SortOrder
    period?: SortOrder
    description?: SortOrder
    location?: SortOrder
    type?: SortOrder
    logo?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkExperienceScalarRelationFilter = {
    is?: WorkExperienceWhereInput
    isNot?: WorkExperienceWhereInput
  }

  export type WorkResponsibilityCountOrderByAggregateInput = {
    id?: SortOrder
    experienceId?: SortOrder
    responsibility?: SortOrder
  }

  export type WorkResponsibilityMaxOrderByAggregateInput = {
    id?: SortOrder
    experienceId?: SortOrder
    responsibility?: SortOrder
  }

  export type WorkResponsibilityMinOrderByAggregateInput = {
    id?: SortOrder
    experienceId?: SortOrder
    responsibility?: SortOrder
  }

  export type WorkTechnologyCountOrderByAggregateInput = {
    id?: SortOrder
    experienceId?: SortOrder
    technology?: SortOrder
  }

  export type WorkTechnologyMaxOrderByAggregateInput = {
    id?: SortOrder
    experienceId?: SortOrder
    technology?: SortOrder
  }

  export type WorkTechnologyMinOrderByAggregateInput = {
    id?: SortOrder
    experienceId?: SortOrder
    technology?: SortOrder
  }

  export type WorkAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    experienceId?: SortOrder
    achievement?: SortOrder
  }

  export type WorkAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    experienceId?: SortOrder
    achievement?: SortOrder
  }

  export type WorkAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    experienceId?: SortOrder
    achievement?: SortOrder
  }

  export type EducationAchievementListRelationFilter = {
    every?: EducationAchievementWhereInput
    some?: EducationAchievementWhereInput
    none?: EducationAchievementWhereInput
  }

  export type EducationAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EducationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    field?: SortOrder
    period?: SortOrder
    description?: SortOrder
    gpa?: SortOrder
    location?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    field?: SortOrder
    period?: SortOrder
    description?: SortOrder
    gpa?: SortOrder
    location?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    field?: SortOrder
    period?: SortOrder
    description?: SortOrder
    gpa?: SortOrder
    location?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationScalarRelationFilter = {
    is?: EducationWhereInput
    isNot?: EducationWhereInput
  }

  export type EducationAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    educationId?: SortOrder
    achievement?: SortOrder
  }

  export type EducationAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    educationId?: SortOrder
    achievement?: SortOrder
  }

  export type EducationAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    educationId?: SortOrder
    achievement?: SortOrder
  }

  export type CertificationSkillListRelationFilter = {
    every?: CertificationSkillWhereInput
    some?: CertificationSkillWhereInput
    none?: CertificationSkillWhereInput
  }

  export type CertificationSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    issuer?: SortOrder
    date?: SortOrder
    icon?: SortOrder
    credentialId?: SortOrder
    expiry?: SortOrder
    description?: SortOrder
    verificationUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    issuer?: SortOrder
    date?: SortOrder
    icon?: SortOrder
    credentialId?: SortOrder
    expiry?: SortOrder
    description?: SortOrder
    verificationUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    issuer?: SortOrder
    date?: SortOrder
    icon?: SortOrder
    credentialId?: SortOrder
    expiry?: SortOrder
    description?: SortOrder
    verificationUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationScalarRelationFilter = {
    is?: CertificationWhereInput
    isNot?: CertificationWhereInput
  }

  export type CertificationSkillCountOrderByAggregateInput = {
    id?: SortOrder
    certificationId?: SortOrder
    skill?: SortOrder
  }

  export type CertificationSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    certificationId?: SortOrder
    skill?: SortOrder
  }

  export type CertificationSkillMinOrderByAggregateInput = {
    id?: SortOrder
    certificationId?: SortOrder
    skill?: SortOrder
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    date?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    issuer?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    date?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    issuer?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    date?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    issuer?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogTagListRelationFilter = {
    every?: BlogTagWhereInput
    some?: BlogTagWhereInput
    none?: BlogTagWhereInput
  }

  export type BlogTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    date?: SortOrder
    readTime?: SortOrder
    image?: SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    views?: SortOrder
    category?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostAvgOrderByAggregateInput = {
    readTime?: SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    views?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    date?: SortOrder
    readTime?: SortOrder
    image?: SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    views?: SortOrder
    category?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    date?: SortOrder
    readTime?: SortOrder
    image?: SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    views?: SortOrder
    category?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostSumOrderByAggregateInput = {
    readTime?: SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    views?: SortOrder
  }

  export type BlogPostScalarRelationFilter = {
    is?: BlogPostWhereInput
    isNot?: BlogPostWhereInput
  }

  export type BlogTagCountOrderByAggregateInput = {
    id?: SortOrder
    blogId?: SortOrder
    tag?: SortOrder
  }

  export type BlogTagMaxOrderByAggregateInput = {
    id?: SortOrder
    blogId?: SortOrder
    tag?: SortOrder
  }

  export type BlogTagMinOrderByAggregateInput = {
    id?: SortOrder
    blogId?: SortOrder
    tag?: SortOrder
  }

  export type TestimonialCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    position?: SortOrder
    company?: SortOrder
    text?: SortOrder
    avatar?: SortOrder
    rating?: SortOrder
    date?: SortOrder
    relation?: SortOrder
    projectLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type TestimonialMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    position?: SortOrder
    company?: SortOrder
    text?: SortOrder
    avatar?: SortOrder
    rating?: SortOrder
    date?: SortOrder
    relation?: SortOrder
    projectLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    position?: SortOrder
    company?: SortOrder
    text?: SortOrder
    avatar?: SortOrder
    rating?: SortOrder
    date?: SortOrder
    relation?: SortOrder
    projectLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    icon?: SortOrder
    isPublic?: SortOrder
    link?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    icon?: SortOrder
    isPublic?: SortOrder
    link?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    icon?: SortOrder
    isPublic?: SortOrder
    link?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type SocialMediaCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    icon?: SortOrder
    username?: SortOrder
  }

  export type SocialMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    icon?: SortOrder
    username?: SortOrder
  }

  export type SocialMediaMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    icon?: SortOrder
    username?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DevStatsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    repos?: SortOrder
    stars?: SortOrder
    contributions?: SortOrder
    rating?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    streak?: SortOrder
    commits?: SortOrder
    prsOpened?: SortOrder
    issuesClosed?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DevStatsAvgOrderByAggregateInput = {
    repos?: SortOrder
    stars?: SortOrder
    contributions?: SortOrder
    rating?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    streak?: SortOrder
    commits?: SortOrder
    prsOpened?: SortOrder
    issuesClosed?: SortOrder
  }

  export type DevStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    repos?: SortOrder
    stars?: SortOrder
    contributions?: SortOrder
    rating?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    streak?: SortOrder
    commits?: SortOrder
    prsOpened?: SortOrder
    issuesClosed?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DevStatsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    repos?: SortOrder
    stars?: SortOrder
    contributions?: SortOrder
    rating?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    streak?: SortOrder
    commits?: SortOrder
    prsOpened?: SortOrder
    issuesClosed?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DevStatsSumOrderByAggregateInput = {
    repos?: SortOrder
    stars?: SortOrder
    contributions?: SortOrder
    rating?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    streak?: SortOrder
    commits?: SortOrder
    prsOpened?: SortOrder
    issuesClosed?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ContributionDayListRelationFilter = {
    every?: ContributionDayWhereInput
    some?: ContributionDayWhereInput
    none?: ContributionDayWhereInput
  }

  export type ContributionDayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContributionDataCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    total?: SortOrder
    startRange?: SortOrder
    endRange?: SortOrder
  }

  export type ContributionDataAvgOrderByAggregateInput = {
    year?: SortOrder
    total?: SortOrder
  }

  export type ContributionDataMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    total?: SortOrder
    startRange?: SortOrder
    endRange?: SortOrder
  }

  export type ContributionDataMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    total?: SortOrder
    startRange?: SortOrder
    endRange?: SortOrder
  }

  export type ContributionDataSumOrderByAggregateInput = {
    year?: SortOrder
    total?: SortOrder
  }

  export type ContributionDataScalarRelationFilter = {
    is?: ContributionDataWhereInput
    isNot?: ContributionDataWhereInput
  }

  export type ContributionDayCountOrderByAggregateInput = {
    id?: SortOrder
    contributionDataId?: SortOrder
    date?: SortOrder
    count?: SortOrder
    level?: SortOrder
  }

  export type ContributionDayAvgOrderByAggregateInput = {
    count?: SortOrder
    level?: SortOrder
  }

  export type ContributionDayMaxOrderByAggregateInput = {
    id?: SortOrder
    contributionDataId?: SortOrder
    date?: SortOrder
    count?: SortOrder
    level?: SortOrder
  }

  export type ContributionDayMinOrderByAggregateInput = {
    id?: SortOrder
    contributionDataId?: SortOrder
    date?: SortOrder
    count?: SortOrder
    level?: SortOrder
  }

  export type ContributionDaySumOrderByAggregateInput = {
    count?: SortOrder
    level?: SortOrder
  }

  export type TimelineEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
  }

  export type TimelineEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
  }

  export type TimelineEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
  }

  export type TestimonialScalarRelationFilter = {
    is?: TestimonialWhereInput
    isNot?: TestimonialWhereInput
  }

  export type ProjectTestimonialProjectIdTestimonialIdCompoundUniqueInput = {
    projectId: string
    testimonialId: string
  }

  export type ProjectTestimonialCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    testimonialId?: SortOrder
  }

  export type ProjectTestimonialMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    testimonialId?: SortOrder
  }

  export type ProjectTestimonialMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    testimonialId?: SortOrder
  }

  export type SkillCreateNestedManyWithoutUserInput = {
    create?: XOR<SkillCreateWithoutUserInput, SkillUncheckedCreateWithoutUserInput> | SkillCreateWithoutUserInput[] | SkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutUserInput | SkillCreateOrConnectWithoutUserInput[]
    createMany?: SkillCreateManyUserInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type WorkExperienceCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkExperienceCreateWithoutUserInput, WorkExperienceUncheckedCreateWithoutUserInput> | WorkExperienceCreateWithoutUserInput[] | WorkExperienceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkExperienceCreateOrConnectWithoutUserInput | WorkExperienceCreateOrConnectWithoutUserInput[]
    createMany?: WorkExperienceCreateManyUserInputEnvelope
    connect?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
  }

  export type EducationCreateNestedManyWithoutUserInput = {
    create?: XOR<EducationCreateWithoutUserInput, EducationUncheckedCreateWithoutUserInput> | EducationCreateWithoutUserInput[] | EducationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutUserInput | EducationCreateOrConnectWithoutUserInput[]
    createMany?: EducationCreateManyUserInputEnvelope
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
  }

  export type CertificationCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificationCreateWithoutUserInput, CertificationUncheckedCreateWithoutUserInput> | CertificationCreateWithoutUserInput[] | CertificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutUserInput | CertificationCreateOrConnectWithoutUserInput[]
    createMany?: CertificationCreateManyUserInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type AchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type BlogPostCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type TestimonialCreateNestedManyWithoutUserInput = {
    create?: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput> | TestimonialCreateWithoutUserInput[] | TestimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutUserInput | TestimonialCreateOrConnectWithoutUserInput[]
    createMany?: TestimonialCreateManyUserInputEnvelope
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type SocialMediaCreateNestedManyWithoutUserInput = {
    create?: XOR<SocialMediaCreateWithoutUserInput, SocialMediaUncheckedCreateWithoutUserInput> | SocialMediaCreateWithoutUserInput[] | SocialMediaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialMediaCreateOrConnectWithoutUserInput | SocialMediaCreateOrConnectWithoutUserInput[]
    createMany?: SocialMediaCreateManyUserInputEnvelope
    connect?: SocialMediaWhereUniqueInput | SocialMediaWhereUniqueInput[]
  }

  export type DevStatsCreateNestedOneWithoutUserInput = {
    create?: XOR<DevStatsCreateWithoutUserInput, DevStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: DevStatsCreateOrConnectWithoutUserInput
    connect?: DevStatsWhereUniqueInput
  }

  export type ContributionDataCreateNestedManyWithoutUserInput = {
    create?: XOR<ContributionDataCreateWithoutUserInput, ContributionDataUncheckedCreateWithoutUserInput> | ContributionDataCreateWithoutUserInput[] | ContributionDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContributionDataCreateOrConnectWithoutUserInput | ContributionDataCreateOrConnectWithoutUserInput[]
    createMany?: ContributionDataCreateManyUserInputEnvelope
    connect?: ContributionDataWhereUniqueInput | ContributionDataWhereUniqueInput[]
  }

  export type TimelineEventCreateNestedManyWithoutUserInput = {
    create?: XOR<TimelineEventCreateWithoutUserInput, TimelineEventUncheckedCreateWithoutUserInput> | TimelineEventCreateWithoutUserInput[] | TimelineEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimelineEventCreateOrConnectWithoutUserInput | TimelineEventCreateOrConnectWithoutUserInput[]
    createMany?: TimelineEventCreateManyUserInputEnvelope
    connect?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
  }

  export type SkillUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SkillCreateWithoutUserInput, SkillUncheckedCreateWithoutUserInput> | SkillCreateWithoutUserInput[] | SkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutUserInput | SkillCreateOrConnectWithoutUserInput[]
    createMany?: SkillCreateManyUserInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type WorkExperienceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkExperienceCreateWithoutUserInput, WorkExperienceUncheckedCreateWithoutUserInput> | WorkExperienceCreateWithoutUserInput[] | WorkExperienceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkExperienceCreateOrConnectWithoutUserInput | WorkExperienceCreateOrConnectWithoutUserInput[]
    createMany?: WorkExperienceCreateManyUserInputEnvelope
    connect?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
  }

  export type EducationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EducationCreateWithoutUserInput, EducationUncheckedCreateWithoutUserInput> | EducationCreateWithoutUserInput[] | EducationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutUserInput | EducationCreateOrConnectWithoutUserInput[]
    createMany?: EducationCreateManyUserInputEnvelope
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
  }

  export type CertificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificationCreateWithoutUserInput, CertificationUncheckedCreateWithoutUserInput> | CertificationCreateWithoutUserInput[] | CertificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutUserInput | CertificationCreateOrConnectWithoutUserInput[]
    createMany?: CertificationCreateManyUserInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type AchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type TestimonialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput> | TestimonialCreateWithoutUserInput[] | TestimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutUserInput | TestimonialCreateOrConnectWithoutUserInput[]
    createMany?: TestimonialCreateManyUserInputEnvelope
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type SocialMediaUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SocialMediaCreateWithoutUserInput, SocialMediaUncheckedCreateWithoutUserInput> | SocialMediaCreateWithoutUserInput[] | SocialMediaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialMediaCreateOrConnectWithoutUserInput | SocialMediaCreateOrConnectWithoutUserInput[]
    createMany?: SocialMediaCreateManyUserInputEnvelope
    connect?: SocialMediaWhereUniqueInput | SocialMediaWhereUniqueInput[]
  }

  export type DevStatsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DevStatsCreateWithoutUserInput, DevStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: DevStatsCreateOrConnectWithoutUserInput
    connect?: DevStatsWhereUniqueInput
  }

  export type ContributionDataUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContributionDataCreateWithoutUserInput, ContributionDataUncheckedCreateWithoutUserInput> | ContributionDataCreateWithoutUserInput[] | ContributionDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContributionDataCreateOrConnectWithoutUserInput | ContributionDataCreateOrConnectWithoutUserInput[]
    createMany?: ContributionDataCreateManyUserInputEnvelope
    connect?: ContributionDataWhereUniqueInput | ContributionDataWhereUniqueInput[]
  }

  export type TimelineEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TimelineEventCreateWithoutUserInput, TimelineEventUncheckedCreateWithoutUserInput> | TimelineEventCreateWithoutUserInput[] | TimelineEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimelineEventCreateOrConnectWithoutUserInput | TimelineEventCreateOrConnectWithoutUserInput[]
    createMany?: TimelineEventCreateManyUserInputEnvelope
    connect?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SkillUpdateManyWithoutUserNestedInput = {
    create?: XOR<SkillCreateWithoutUserInput, SkillUncheckedCreateWithoutUserInput> | SkillCreateWithoutUserInput[] | SkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutUserInput | SkillCreateOrConnectWithoutUserInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutUserInput | SkillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SkillCreateManyUserInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutUserInput | SkillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutUserInput | SkillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type WorkExperienceUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkExperienceCreateWithoutUserInput, WorkExperienceUncheckedCreateWithoutUserInput> | WorkExperienceCreateWithoutUserInput[] | WorkExperienceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkExperienceCreateOrConnectWithoutUserInput | WorkExperienceCreateOrConnectWithoutUserInput[]
    upsert?: WorkExperienceUpsertWithWhereUniqueWithoutUserInput | WorkExperienceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkExperienceCreateManyUserInputEnvelope
    set?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    disconnect?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    delete?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    connect?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    update?: WorkExperienceUpdateWithWhereUniqueWithoutUserInput | WorkExperienceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkExperienceUpdateManyWithWhereWithoutUserInput | WorkExperienceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkExperienceScalarWhereInput | WorkExperienceScalarWhereInput[]
  }

  export type EducationUpdateManyWithoutUserNestedInput = {
    create?: XOR<EducationCreateWithoutUserInput, EducationUncheckedCreateWithoutUserInput> | EducationCreateWithoutUserInput[] | EducationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutUserInput | EducationCreateOrConnectWithoutUserInput[]
    upsert?: EducationUpsertWithWhereUniqueWithoutUserInput | EducationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EducationCreateManyUserInputEnvelope
    set?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    disconnect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    delete?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    update?: EducationUpdateWithWhereUniqueWithoutUserInput | EducationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EducationUpdateManyWithWhereWithoutUserInput | EducationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EducationScalarWhereInput | EducationScalarWhereInput[]
  }

  export type CertificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificationCreateWithoutUserInput, CertificationUncheckedCreateWithoutUserInput> | CertificationCreateWithoutUserInput[] | CertificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutUserInput | CertificationCreateOrConnectWithoutUserInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutUserInput | CertificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificationCreateManyUserInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutUserInput | CertificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutUserInput | CertificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type AchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutUserInput | AchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutUserInput | AchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutUserInput | AchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type BlogPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutUserInput | BlogPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutUserInput | BlogPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutUserInput | BlogPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type TestimonialUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput> | TestimonialCreateWithoutUserInput[] | TestimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutUserInput | TestimonialCreateOrConnectWithoutUserInput[]
    upsert?: TestimonialUpsertWithWhereUniqueWithoutUserInput | TestimonialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestimonialCreateManyUserInputEnvelope
    set?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    disconnect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    delete?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    update?: TestimonialUpdateWithWhereUniqueWithoutUserInput | TestimonialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestimonialUpdateManyWithWhereWithoutUserInput | TestimonialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUserInput | ContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUserInput | ContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUserInput | ContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type SocialMediaUpdateManyWithoutUserNestedInput = {
    create?: XOR<SocialMediaCreateWithoutUserInput, SocialMediaUncheckedCreateWithoutUserInput> | SocialMediaCreateWithoutUserInput[] | SocialMediaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialMediaCreateOrConnectWithoutUserInput | SocialMediaCreateOrConnectWithoutUserInput[]
    upsert?: SocialMediaUpsertWithWhereUniqueWithoutUserInput | SocialMediaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SocialMediaCreateManyUserInputEnvelope
    set?: SocialMediaWhereUniqueInput | SocialMediaWhereUniqueInput[]
    disconnect?: SocialMediaWhereUniqueInput | SocialMediaWhereUniqueInput[]
    delete?: SocialMediaWhereUniqueInput | SocialMediaWhereUniqueInput[]
    connect?: SocialMediaWhereUniqueInput | SocialMediaWhereUniqueInput[]
    update?: SocialMediaUpdateWithWhereUniqueWithoutUserInput | SocialMediaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SocialMediaUpdateManyWithWhereWithoutUserInput | SocialMediaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SocialMediaScalarWhereInput | SocialMediaScalarWhereInput[]
  }

  export type DevStatsUpdateOneWithoutUserNestedInput = {
    create?: XOR<DevStatsCreateWithoutUserInput, DevStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: DevStatsCreateOrConnectWithoutUserInput
    upsert?: DevStatsUpsertWithoutUserInput
    disconnect?: DevStatsWhereInput | boolean
    delete?: DevStatsWhereInput | boolean
    connect?: DevStatsWhereUniqueInput
    update?: XOR<XOR<DevStatsUpdateToOneWithWhereWithoutUserInput, DevStatsUpdateWithoutUserInput>, DevStatsUncheckedUpdateWithoutUserInput>
  }

  export type ContributionDataUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContributionDataCreateWithoutUserInput, ContributionDataUncheckedCreateWithoutUserInput> | ContributionDataCreateWithoutUserInput[] | ContributionDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContributionDataCreateOrConnectWithoutUserInput | ContributionDataCreateOrConnectWithoutUserInput[]
    upsert?: ContributionDataUpsertWithWhereUniqueWithoutUserInput | ContributionDataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContributionDataCreateManyUserInputEnvelope
    set?: ContributionDataWhereUniqueInput | ContributionDataWhereUniqueInput[]
    disconnect?: ContributionDataWhereUniqueInput | ContributionDataWhereUniqueInput[]
    delete?: ContributionDataWhereUniqueInput | ContributionDataWhereUniqueInput[]
    connect?: ContributionDataWhereUniqueInput | ContributionDataWhereUniqueInput[]
    update?: ContributionDataUpdateWithWhereUniqueWithoutUserInput | ContributionDataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContributionDataUpdateManyWithWhereWithoutUserInput | ContributionDataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContributionDataScalarWhereInput | ContributionDataScalarWhereInput[]
  }

  export type TimelineEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimelineEventCreateWithoutUserInput, TimelineEventUncheckedCreateWithoutUserInput> | TimelineEventCreateWithoutUserInput[] | TimelineEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimelineEventCreateOrConnectWithoutUserInput | TimelineEventCreateOrConnectWithoutUserInput[]
    upsert?: TimelineEventUpsertWithWhereUniqueWithoutUserInput | TimelineEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimelineEventCreateManyUserInputEnvelope
    set?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    disconnect?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    delete?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    connect?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    update?: TimelineEventUpdateWithWhereUniqueWithoutUserInput | TimelineEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimelineEventUpdateManyWithWhereWithoutUserInput | TimelineEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimelineEventScalarWhereInput | TimelineEventScalarWhereInput[]
  }

  export type SkillUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SkillCreateWithoutUserInput, SkillUncheckedCreateWithoutUserInput> | SkillCreateWithoutUserInput[] | SkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutUserInput | SkillCreateOrConnectWithoutUserInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutUserInput | SkillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SkillCreateManyUserInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutUserInput | SkillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutUserInput | SkillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type WorkExperienceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkExperienceCreateWithoutUserInput, WorkExperienceUncheckedCreateWithoutUserInput> | WorkExperienceCreateWithoutUserInput[] | WorkExperienceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkExperienceCreateOrConnectWithoutUserInput | WorkExperienceCreateOrConnectWithoutUserInput[]
    upsert?: WorkExperienceUpsertWithWhereUniqueWithoutUserInput | WorkExperienceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkExperienceCreateManyUserInputEnvelope
    set?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    disconnect?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    delete?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    connect?: WorkExperienceWhereUniqueInput | WorkExperienceWhereUniqueInput[]
    update?: WorkExperienceUpdateWithWhereUniqueWithoutUserInput | WorkExperienceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkExperienceUpdateManyWithWhereWithoutUserInput | WorkExperienceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkExperienceScalarWhereInput | WorkExperienceScalarWhereInput[]
  }

  export type EducationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EducationCreateWithoutUserInput, EducationUncheckedCreateWithoutUserInput> | EducationCreateWithoutUserInput[] | EducationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutUserInput | EducationCreateOrConnectWithoutUserInput[]
    upsert?: EducationUpsertWithWhereUniqueWithoutUserInput | EducationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EducationCreateManyUserInputEnvelope
    set?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    disconnect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    delete?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    update?: EducationUpdateWithWhereUniqueWithoutUserInput | EducationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EducationUpdateManyWithWhereWithoutUserInput | EducationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EducationScalarWhereInput | EducationScalarWhereInput[]
  }

  export type CertificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificationCreateWithoutUserInput, CertificationUncheckedCreateWithoutUserInput> | CertificationCreateWithoutUserInput[] | CertificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutUserInput | CertificationCreateOrConnectWithoutUserInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutUserInput | CertificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificationCreateManyUserInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutUserInput | CertificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutUserInput | CertificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type AchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutUserInput | AchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutUserInput | AchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutUserInput | AchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput> | BlogPostCreateWithoutUserInput[] | BlogPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutUserInput | BlogPostCreateOrConnectWithoutUserInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutUserInput | BlogPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogPostCreateManyUserInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutUserInput | BlogPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutUserInput | BlogPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type TestimonialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput> | TestimonialCreateWithoutUserInput[] | TestimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutUserInput | TestimonialCreateOrConnectWithoutUserInput[]
    upsert?: TestimonialUpsertWithWhereUniqueWithoutUserInput | TestimonialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestimonialCreateManyUserInputEnvelope
    set?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    disconnect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    delete?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    update?: TestimonialUpdateWithWhereUniqueWithoutUserInput | TestimonialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestimonialUpdateManyWithWhereWithoutUserInput | TestimonialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUserInput | ContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUserInput | ContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUserInput | ContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type SocialMediaUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SocialMediaCreateWithoutUserInput, SocialMediaUncheckedCreateWithoutUserInput> | SocialMediaCreateWithoutUserInput[] | SocialMediaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialMediaCreateOrConnectWithoutUserInput | SocialMediaCreateOrConnectWithoutUserInput[]
    upsert?: SocialMediaUpsertWithWhereUniqueWithoutUserInput | SocialMediaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SocialMediaCreateManyUserInputEnvelope
    set?: SocialMediaWhereUniqueInput | SocialMediaWhereUniqueInput[]
    disconnect?: SocialMediaWhereUniqueInput | SocialMediaWhereUniqueInput[]
    delete?: SocialMediaWhereUniqueInput | SocialMediaWhereUniqueInput[]
    connect?: SocialMediaWhereUniqueInput | SocialMediaWhereUniqueInput[]
    update?: SocialMediaUpdateWithWhereUniqueWithoutUserInput | SocialMediaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SocialMediaUpdateManyWithWhereWithoutUserInput | SocialMediaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SocialMediaScalarWhereInput | SocialMediaScalarWhereInput[]
  }

  export type DevStatsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DevStatsCreateWithoutUserInput, DevStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: DevStatsCreateOrConnectWithoutUserInput
    upsert?: DevStatsUpsertWithoutUserInput
    disconnect?: DevStatsWhereInput | boolean
    delete?: DevStatsWhereInput | boolean
    connect?: DevStatsWhereUniqueInput
    update?: XOR<XOR<DevStatsUpdateToOneWithWhereWithoutUserInput, DevStatsUpdateWithoutUserInput>, DevStatsUncheckedUpdateWithoutUserInput>
  }

  export type ContributionDataUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContributionDataCreateWithoutUserInput, ContributionDataUncheckedCreateWithoutUserInput> | ContributionDataCreateWithoutUserInput[] | ContributionDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContributionDataCreateOrConnectWithoutUserInput | ContributionDataCreateOrConnectWithoutUserInput[]
    upsert?: ContributionDataUpsertWithWhereUniqueWithoutUserInput | ContributionDataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContributionDataCreateManyUserInputEnvelope
    set?: ContributionDataWhereUniqueInput | ContributionDataWhereUniqueInput[]
    disconnect?: ContributionDataWhereUniqueInput | ContributionDataWhereUniqueInput[]
    delete?: ContributionDataWhereUniqueInput | ContributionDataWhereUniqueInput[]
    connect?: ContributionDataWhereUniqueInput | ContributionDataWhereUniqueInput[]
    update?: ContributionDataUpdateWithWhereUniqueWithoutUserInput | ContributionDataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContributionDataUpdateManyWithWhereWithoutUserInput | ContributionDataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContributionDataScalarWhereInput | ContributionDataScalarWhereInput[]
  }

  export type TimelineEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimelineEventCreateWithoutUserInput, TimelineEventUncheckedCreateWithoutUserInput> | TimelineEventCreateWithoutUserInput[] | TimelineEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimelineEventCreateOrConnectWithoutUserInput | TimelineEventCreateOrConnectWithoutUserInput[]
    upsert?: TimelineEventUpsertWithWhereUniqueWithoutUserInput | TimelineEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimelineEventCreateManyUserInputEnvelope
    set?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    disconnect?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    delete?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    connect?: TimelineEventWhereUniqueInput | TimelineEventWhereUniqueInput[]
    update?: TimelineEventUpdateWithWhereUniqueWithoutUserInput | TimelineEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimelineEventUpdateManyWithWhereWithoutUserInput | TimelineEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimelineEventScalarWhereInput | TimelineEventScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSkillsInput = {
    create?: XOR<UserCreateWithoutSkillsInput, UserUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSkillsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedManyWithoutSkillsInput = {
    create?: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput> | ProjectCreateWithoutSkillsInput[] | ProjectUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutSkillsInput | ProjectCreateOrConnectWithoutSkillsInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutSkillsInput = {
    create?: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput> | ProjectCreateWithoutSkillsInput[] | ProjectUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutSkillsInput | ProjectCreateOrConnectWithoutSkillsInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<UserCreateWithoutSkillsInput, UserUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSkillsInput
    upsert?: UserUpsertWithoutSkillsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSkillsInput, UserUpdateWithoutSkillsInput>, UserUncheckedUpdateWithoutSkillsInput>
  }

  export type ProjectUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput> | ProjectCreateWithoutSkillsInput[] | ProjectUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutSkillsInput | ProjectCreateOrConnectWithoutSkillsInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutSkillsInput | ProjectUpsertWithWhereUniqueWithoutSkillsInput[]
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutSkillsInput | ProjectUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutSkillsInput | ProjectUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput> | ProjectCreateWithoutSkillsInput[] | ProjectUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutSkillsInput | ProjectCreateOrConnectWithoutSkillsInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutSkillsInput | ProjectUpsertWithWhereUniqueWithoutSkillsInput[]
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutSkillsInput | ProjectUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutSkillsInput | ProjectUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectFeatureCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectFeatureCreateWithoutProjectInput, ProjectFeatureUncheckedCreateWithoutProjectInput> | ProjectFeatureCreateWithoutProjectInput[] | ProjectFeatureUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectFeatureCreateOrConnectWithoutProjectInput | ProjectFeatureCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectFeatureCreateManyProjectInputEnvelope
    connect?: ProjectFeatureWhereUniqueInput | ProjectFeatureWhereUniqueInput[]
  }

  export type ProjectTechStackCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectTechStackCreateWithoutProjectInput, ProjectTechStackUncheckedCreateWithoutProjectInput> | ProjectTechStackCreateWithoutProjectInput[] | ProjectTechStackUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTechStackCreateOrConnectWithoutProjectInput | ProjectTechStackCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectTechStackCreateManyProjectInputEnvelope
    connect?: ProjectTechStackWhereUniqueInput | ProjectTechStackWhereUniqueInput[]
  }

  export type ProjectCollaboratorCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput> | ProjectCollaboratorCreateWithoutProjectInput[] | ProjectCollaboratorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutProjectInput | ProjectCollaboratorCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectCollaboratorCreateManyProjectInputEnvelope
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
  }

  export type ProjectLearningCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectLearningCreateWithoutProjectInput, ProjectLearningUncheckedCreateWithoutProjectInput> | ProjectLearningCreateWithoutProjectInput[] | ProjectLearningUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectLearningCreateOrConnectWithoutProjectInput | ProjectLearningCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectLearningCreateManyProjectInputEnvelope
    connect?: ProjectLearningWhereUniqueInput | ProjectLearningWhereUniqueInput[]
  }

  export type ProjectTestimonialCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectTestimonialCreateWithoutProjectInput, ProjectTestimonialUncheckedCreateWithoutProjectInput> | ProjectTestimonialCreateWithoutProjectInput[] | ProjectTestimonialUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTestimonialCreateOrConnectWithoutProjectInput | ProjectTestimonialCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectTestimonialCreateManyProjectInputEnvelope
    connect?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
  }

  export type SkillCreateNestedManyWithoutProjectsInput = {
    create?: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput> | SkillCreateWithoutProjectsInput[] | SkillUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutProjectsInput | SkillCreateOrConnectWithoutProjectsInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type ProjectFeatureUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectFeatureCreateWithoutProjectInput, ProjectFeatureUncheckedCreateWithoutProjectInput> | ProjectFeatureCreateWithoutProjectInput[] | ProjectFeatureUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectFeatureCreateOrConnectWithoutProjectInput | ProjectFeatureCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectFeatureCreateManyProjectInputEnvelope
    connect?: ProjectFeatureWhereUniqueInput | ProjectFeatureWhereUniqueInput[]
  }

  export type ProjectTechStackUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectTechStackCreateWithoutProjectInput, ProjectTechStackUncheckedCreateWithoutProjectInput> | ProjectTechStackCreateWithoutProjectInput[] | ProjectTechStackUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTechStackCreateOrConnectWithoutProjectInput | ProjectTechStackCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectTechStackCreateManyProjectInputEnvelope
    connect?: ProjectTechStackWhereUniqueInput | ProjectTechStackWhereUniqueInput[]
  }

  export type ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput> | ProjectCollaboratorCreateWithoutProjectInput[] | ProjectCollaboratorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutProjectInput | ProjectCollaboratorCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectCollaboratorCreateManyProjectInputEnvelope
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
  }

  export type ProjectLearningUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectLearningCreateWithoutProjectInput, ProjectLearningUncheckedCreateWithoutProjectInput> | ProjectLearningCreateWithoutProjectInput[] | ProjectLearningUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectLearningCreateOrConnectWithoutProjectInput | ProjectLearningCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectLearningCreateManyProjectInputEnvelope
    connect?: ProjectLearningWhereUniqueInput | ProjectLearningWhereUniqueInput[]
  }

  export type ProjectTestimonialUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectTestimonialCreateWithoutProjectInput, ProjectTestimonialUncheckedCreateWithoutProjectInput> | ProjectTestimonialCreateWithoutProjectInput[] | ProjectTestimonialUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTestimonialCreateOrConnectWithoutProjectInput | ProjectTestimonialCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectTestimonialCreateManyProjectInputEnvelope
    connect?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
  }

  export type SkillUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput> | SkillCreateWithoutProjectsInput[] | SkillUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutProjectsInput | SkillCreateOrConnectWithoutProjectsInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectFeatureUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectFeatureCreateWithoutProjectInput, ProjectFeatureUncheckedCreateWithoutProjectInput> | ProjectFeatureCreateWithoutProjectInput[] | ProjectFeatureUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectFeatureCreateOrConnectWithoutProjectInput | ProjectFeatureCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectFeatureUpsertWithWhereUniqueWithoutProjectInput | ProjectFeatureUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectFeatureCreateManyProjectInputEnvelope
    set?: ProjectFeatureWhereUniqueInput | ProjectFeatureWhereUniqueInput[]
    disconnect?: ProjectFeatureWhereUniqueInput | ProjectFeatureWhereUniqueInput[]
    delete?: ProjectFeatureWhereUniqueInput | ProjectFeatureWhereUniqueInput[]
    connect?: ProjectFeatureWhereUniqueInput | ProjectFeatureWhereUniqueInput[]
    update?: ProjectFeatureUpdateWithWhereUniqueWithoutProjectInput | ProjectFeatureUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectFeatureUpdateManyWithWhereWithoutProjectInput | ProjectFeatureUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectFeatureScalarWhereInput | ProjectFeatureScalarWhereInput[]
  }

  export type ProjectTechStackUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectTechStackCreateWithoutProjectInput, ProjectTechStackUncheckedCreateWithoutProjectInput> | ProjectTechStackCreateWithoutProjectInput[] | ProjectTechStackUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTechStackCreateOrConnectWithoutProjectInput | ProjectTechStackCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectTechStackUpsertWithWhereUniqueWithoutProjectInput | ProjectTechStackUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectTechStackCreateManyProjectInputEnvelope
    set?: ProjectTechStackWhereUniqueInput | ProjectTechStackWhereUniqueInput[]
    disconnect?: ProjectTechStackWhereUniqueInput | ProjectTechStackWhereUniqueInput[]
    delete?: ProjectTechStackWhereUniqueInput | ProjectTechStackWhereUniqueInput[]
    connect?: ProjectTechStackWhereUniqueInput | ProjectTechStackWhereUniqueInput[]
    update?: ProjectTechStackUpdateWithWhereUniqueWithoutProjectInput | ProjectTechStackUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectTechStackUpdateManyWithWhereWithoutProjectInput | ProjectTechStackUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectTechStackScalarWhereInput | ProjectTechStackScalarWhereInput[]
  }

  export type ProjectCollaboratorUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput> | ProjectCollaboratorCreateWithoutProjectInput[] | ProjectCollaboratorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutProjectInput | ProjectCollaboratorCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput | ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectCollaboratorCreateManyProjectInputEnvelope
    set?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    disconnect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    delete?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    update?: ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput | ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput | ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
  }

  export type ProjectLearningUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectLearningCreateWithoutProjectInput, ProjectLearningUncheckedCreateWithoutProjectInput> | ProjectLearningCreateWithoutProjectInput[] | ProjectLearningUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectLearningCreateOrConnectWithoutProjectInput | ProjectLearningCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectLearningUpsertWithWhereUniqueWithoutProjectInput | ProjectLearningUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectLearningCreateManyProjectInputEnvelope
    set?: ProjectLearningWhereUniqueInput | ProjectLearningWhereUniqueInput[]
    disconnect?: ProjectLearningWhereUniqueInput | ProjectLearningWhereUniqueInput[]
    delete?: ProjectLearningWhereUniqueInput | ProjectLearningWhereUniqueInput[]
    connect?: ProjectLearningWhereUniqueInput | ProjectLearningWhereUniqueInput[]
    update?: ProjectLearningUpdateWithWhereUniqueWithoutProjectInput | ProjectLearningUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectLearningUpdateManyWithWhereWithoutProjectInput | ProjectLearningUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectLearningScalarWhereInput | ProjectLearningScalarWhereInput[]
  }

  export type ProjectTestimonialUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectTestimonialCreateWithoutProjectInput, ProjectTestimonialUncheckedCreateWithoutProjectInput> | ProjectTestimonialCreateWithoutProjectInput[] | ProjectTestimonialUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTestimonialCreateOrConnectWithoutProjectInput | ProjectTestimonialCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectTestimonialUpsertWithWhereUniqueWithoutProjectInput | ProjectTestimonialUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectTestimonialCreateManyProjectInputEnvelope
    set?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    disconnect?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    delete?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    connect?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    update?: ProjectTestimonialUpdateWithWhereUniqueWithoutProjectInput | ProjectTestimonialUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectTestimonialUpdateManyWithWhereWithoutProjectInput | ProjectTestimonialUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectTestimonialScalarWhereInput | ProjectTestimonialScalarWhereInput[]
  }

  export type SkillUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput> | SkillCreateWithoutProjectsInput[] | SkillUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutProjectsInput | SkillCreateOrConnectWithoutProjectsInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutProjectsInput | SkillUpsertWithWhereUniqueWithoutProjectsInput[]
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutProjectsInput | SkillUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutProjectsInput | SkillUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type ProjectFeatureUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectFeatureCreateWithoutProjectInput, ProjectFeatureUncheckedCreateWithoutProjectInput> | ProjectFeatureCreateWithoutProjectInput[] | ProjectFeatureUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectFeatureCreateOrConnectWithoutProjectInput | ProjectFeatureCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectFeatureUpsertWithWhereUniqueWithoutProjectInput | ProjectFeatureUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectFeatureCreateManyProjectInputEnvelope
    set?: ProjectFeatureWhereUniqueInput | ProjectFeatureWhereUniqueInput[]
    disconnect?: ProjectFeatureWhereUniqueInput | ProjectFeatureWhereUniqueInput[]
    delete?: ProjectFeatureWhereUniqueInput | ProjectFeatureWhereUniqueInput[]
    connect?: ProjectFeatureWhereUniqueInput | ProjectFeatureWhereUniqueInput[]
    update?: ProjectFeatureUpdateWithWhereUniqueWithoutProjectInput | ProjectFeatureUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectFeatureUpdateManyWithWhereWithoutProjectInput | ProjectFeatureUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectFeatureScalarWhereInput | ProjectFeatureScalarWhereInput[]
  }

  export type ProjectTechStackUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectTechStackCreateWithoutProjectInput, ProjectTechStackUncheckedCreateWithoutProjectInput> | ProjectTechStackCreateWithoutProjectInput[] | ProjectTechStackUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTechStackCreateOrConnectWithoutProjectInput | ProjectTechStackCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectTechStackUpsertWithWhereUniqueWithoutProjectInput | ProjectTechStackUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectTechStackCreateManyProjectInputEnvelope
    set?: ProjectTechStackWhereUniqueInput | ProjectTechStackWhereUniqueInput[]
    disconnect?: ProjectTechStackWhereUniqueInput | ProjectTechStackWhereUniqueInput[]
    delete?: ProjectTechStackWhereUniqueInput | ProjectTechStackWhereUniqueInput[]
    connect?: ProjectTechStackWhereUniqueInput | ProjectTechStackWhereUniqueInput[]
    update?: ProjectTechStackUpdateWithWhereUniqueWithoutProjectInput | ProjectTechStackUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectTechStackUpdateManyWithWhereWithoutProjectInput | ProjectTechStackUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectTechStackScalarWhereInput | ProjectTechStackScalarWhereInput[]
  }

  export type ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput> | ProjectCollaboratorCreateWithoutProjectInput[] | ProjectCollaboratorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutProjectInput | ProjectCollaboratorCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput | ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectCollaboratorCreateManyProjectInputEnvelope
    set?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    disconnect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    delete?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    update?: ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput | ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput | ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
  }

  export type ProjectLearningUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectLearningCreateWithoutProjectInput, ProjectLearningUncheckedCreateWithoutProjectInput> | ProjectLearningCreateWithoutProjectInput[] | ProjectLearningUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectLearningCreateOrConnectWithoutProjectInput | ProjectLearningCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectLearningUpsertWithWhereUniqueWithoutProjectInput | ProjectLearningUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectLearningCreateManyProjectInputEnvelope
    set?: ProjectLearningWhereUniqueInput | ProjectLearningWhereUniqueInput[]
    disconnect?: ProjectLearningWhereUniqueInput | ProjectLearningWhereUniqueInput[]
    delete?: ProjectLearningWhereUniqueInput | ProjectLearningWhereUniqueInput[]
    connect?: ProjectLearningWhereUniqueInput | ProjectLearningWhereUniqueInput[]
    update?: ProjectLearningUpdateWithWhereUniqueWithoutProjectInput | ProjectLearningUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectLearningUpdateManyWithWhereWithoutProjectInput | ProjectLearningUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectLearningScalarWhereInput | ProjectLearningScalarWhereInput[]
  }

  export type ProjectTestimonialUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectTestimonialCreateWithoutProjectInput, ProjectTestimonialUncheckedCreateWithoutProjectInput> | ProjectTestimonialCreateWithoutProjectInput[] | ProjectTestimonialUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTestimonialCreateOrConnectWithoutProjectInput | ProjectTestimonialCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectTestimonialUpsertWithWhereUniqueWithoutProjectInput | ProjectTestimonialUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectTestimonialCreateManyProjectInputEnvelope
    set?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    disconnect?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    delete?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    connect?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    update?: ProjectTestimonialUpdateWithWhereUniqueWithoutProjectInput | ProjectTestimonialUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectTestimonialUpdateManyWithWhereWithoutProjectInput | ProjectTestimonialUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectTestimonialScalarWhereInput | ProjectTestimonialScalarWhereInput[]
  }

  export type SkillUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput> | SkillCreateWithoutProjectsInput[] | SkillUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutProjectsInput | SkillCreateOrConnectWithoutProjectsInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutProjectsInput | SkillUpsertWithWhereUniqueWithoutProjectsInput[]
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutProjectsInput | SkillUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutProjectsInput | SkillUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<ProjectCreateWithoutFeaturesInput, ProjectUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFeaturesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<ProjectCreateWithoutFeaturesInput, ProjectUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFeaturesInput
    upsert?: ProjectUpsertWithoutFeaturesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutFeaturesInput, ProjectUpdateWithoutFeaturesInput>, ProjectUncheckedUpdateWithoutFeaturesInput>
  }

  export type ProjectCreateNestedOneWithoutTechStackInput = {
    create?: XOR<ProjectCreateWithoutTechStackInput, ProjectUncheckedCreateWithoutTechStackInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTechStackInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutTechStackNestedInput = {
    create?: XOR<ProjectCreateWithoutTechStackInput, ProjectUncheckedCreateWithoutTechStackInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTechStackInput
    upsert?: ProjectUpsertWithoutTechStackInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTechStackInput, ProjectUpdateWithoutTechStackInput>, ProjectUncheckedUpdateWithoutTechStackInput>
  }

  export type ProjectCreateNestedOneWithoutCollaboratorsInput = {
    create?: XOR<ProjectCreateWithoutCollaboratorsInput, ProjectUncheckedCreateWithoutCollaboratorsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCollaboratorsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutCollaboratorsNestedInput = {
    create?: XOR<ProjectCreateWithoutCollaboratorsInput, ProjectUncheckedCreateWithoutCollaboratorsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCollaboratorsInput
    upsert?: ProjectUpsertWithoutCollaboratorsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCollaboratorsInput, ProjectUpdateWithoutCollaboratorsInput>, ProjectUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type ProjectCreateNestedOneWithoutLearningsInput = {
    create?: XOR<ProjectCreateWithoutLearningsInput, ProjectUncheckedCreateWithoutLearningsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLearningsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutLearningsNestedInput = {
    create?: XOR<ProjectCreateWithoutLearningsInput, ProjectUncheckedCreateWithoutLearningsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLearningsInput
    upsert?: ProjectUpsertWithoutLearningsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutLearningsInput, ProjectUpdateWithoutLearningsInput>, ProjectUncheckedUpdateWithoutLearningsInput>
  }

  export type UserCreateNestedOneWithoutWorkExperiencesInput = {
    create?: XOR<UserCreateWithoutWorkExperiencesInput, UserUncheckedCreateWithoutWorkExperiencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkExperiencesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkResponsibilityCreateNestedManyWithoutWorkExperienceInput = {
    create?: XOR<WorkResponsibilityCreateWithoutWorkExperienceInput, WorkResponsibilityUncheckedCreateWithoutWorkExperienceInput> | WorkResponsibilityCreateWithoutWorkExperienceInput[] | WorkResponsibilityUncheckedCreateWithoutWorkExperienceInput[]
    connectOrCreate?: WorkResponsibilityCreateOrConnectWithoutWorkExperienceInput | WorkResponsibilityCreateOrConnectWithoutWorkExperienceInput[]
    createMany?: WorkResponsibilityCreateManyWorkExperienceInputEnvelope
    connect?: WorkResponsibilityWhereUniqueInput | WorkResponsibilityWhereUniqueInput[]
  }

  export type WorkTechnologyCreateNestedManyWithoutWorkExperienceInput = {
    create?: XOR<WorkTechnologyCreateWithoutWorkExperienceInput, WorkTechnologyUncheckedCreateWithoutWorkExperienceInput> | WorkTechnologyCreateWithoutWorkExperienceInput[] | WorkTechnologyUncheckedCreateWithoutWorkExperienceInput[]
    connectOrCreate?: WorkTechnologyCreateOrConnectWithoutWorkExperienceInput | WorkTechnologyCreateOrConnectWithoutWorkExperienceInput[]
    createMany?: WorkTechnologyCreateManyWorkExperienceInputEnvelope
    connect?: WorkTechnologyWhereUniqueInput | WorkTechnologyWhereUniqueInput[]
  }

  export type WorkAchievementCreateNestedManyWithoutWorkExperienceInput = {
    create?: XOR<WorkAchievementCreateWithoutWorkExperienceInput, WorkAchievementUncheckedCreateWithoutWorkExperienceInput> | WorkAchievementCreateWithoutWorkExperienceInput[] | WorkAchievementUncheckedCreateWithoutWorkExperienceInput[]
    connectOrCreate?: WorkAchievementCreateOrConnectWithoutWorkExperienceInput | WorkAchievementCreateOrConnectWithoutWorkExperienceInput[]
    createMany?: WorkAchievementCreateManyWorkExperienceInputEnvelope
    connect?: WorkAchievementWhereUniqueInput | WorkAchievementWhereUniqueInput[]
  }

  export type WorkResponsibilityUncheckedCreateNestedManyWithoutWorkExperienceInput = {
    create?: XOR<WorkResponsibilityCreateWithoutWorkExperienceInput, WorkResponsibilityUncheckedCreateWithoutWorkExperienceInput> | WorkResponsibilityCreateWithoutWorkExperienceInput[] | WorkResponsibilityUncheckedCreateWithoutWorkExperienceInput[]
    connectOrCreate?: WorkResponsibilityCreateOrConnectWithoutWorkExperienceInput | WorkResponsibilityCreateOrConnectWithoutWorkExperienceInput[]
    createMany?: WorkResponsibilityCreateManyWorkExperienceInputEnvelope
    connect?: WorkResponsibilityWhereUniqueInput | WorkResponsibilityWhereUniqueInput[]
  }

  export type WorkTechnologyUncheckedCreateNestedManyWithoutWorkExperienceInput = {
    create?: XOR<WorkTechnologyCreateWithoutWorkExperienceInput, WorkTechnologyUncheckedCreateWithoutWorkExperienceInput> | WorkTechnologyCreateWithoutWorkExperienceInput[] | WorkTechnologyUncheckedCreateWithoutWorkExperienceInput[]
    connectOrCreate?: WorkTechnologyCreateOrConnectWithoutWorkExperienceInput | WorkTechnologyCreateOrConnectWithoutWorkExperienceInput[]
    createMany?: WorkTechnologyCreateManyWorkExperienceInputEnvelope
    connect?: WorkTechnologyWhereUniqueInput | WorkTechnologyWhereUniqueInput[]
  }

  export type WorkAchievementUncheckedCreateNestedManyWithoutWorkExperienceInput = {
    create?: XOR<WorkAchievementCreateWithoutWorkExperienceInput, WorkAchievementUncheckedCreateWithoutWorkExperienceInput> | WorkAchievementCreateWithoutWorkExperienceInput[] | WorkAchievementUncheckedCreateWithoutWorkExperienceInput[]
    connectOrCreate?: WorkAchievementCreateOrConnectWithoutWorkExperienceInput | WorkAchievementCreateOrConnectWithoutWorkExperienceInput[]
    createMany?: WorkAchievementCreateManyWorkExperienceInputEnvelope
    connect?: WorkAchievementWhereUniqueInput | WorkAchievementWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWorkExperiencesNestedInput = {
    create?: XOR<UserCreateWithoutWorkExperiencesInput, UserUncheckedCreateWithoutWorkExperiencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkExperiencesInput
    upsert?: UserUpsertWithoutWorkExperiencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkExperiencesInput, UserUpdateWithoutWorkExperiencesInput>, UserUncheckedUpdateWithoutWorkExperiencesInput>
  }

  export type WorkResponsibilityUpdateManyWithoutWorkExperienceNestedInput = {
    create?: XOR<WorkResponsibilityCreateWithoutWorkExperienceInput, WorkResponsibilityUncheckedCreateWithoutWorkExperienceInput> | WorkResponsibilityCreateWithoutWorkExperienceInput[] | WorkResponsibilityUncheckedCreateWithoutWorkExperienceInput[]
    connectOrCreate?: WorkResponsibilityCreateOrConnectWithoutWorkExperienceInput | WorkResponsibilityCreateOrConnectWithoutWorkExperienceInput[]
    upsert?: WorkResponsibilityUpsertWithWhereUniqueWithoutWorkExperienceInput | WorkResponsibilityUpsertWithWhereUniqueWithoutWorkExperienceInput[]
    createMany?: WorkResponsibilityCreateManyWorkExperienceInputEnvelope
    set?: WorkResponsibilityWhereUniqueInput | WorkResponsibilityWhereUniqueInput[]
    disconnect?: WorkResponsibilityWhereUniqueInput | WorkResponsibilityWhereUniqueInput[]
    delete?: WorkResponsibilityWhereUniqueInput | WorkResponsibilityWhereUniqueInput[]
    connect?: WorkResponsibilityWhereUniqueInput | WorkResponsibilityWhereUniqueInput[]
    update?: WorkResponsibilityUpdateWithWhereUniqueWithoutWorkExperienceInput | WorkResponsibilityUpdateWithWhereUniqueWithoutWorkExperienceInput[]
    updateMany?: WorkResponsibilityUpdateManyWithWhereWithoutWorkExperienceInput | WorkResponsibilityUpdateManyWithWhereWithoutWorkExperienceInput[]
    deleteMany?: WorkResponsibilityScalarWhereInput | WorkResponsibilityScalarWhereInput[]
  }

  export type WorkTechnologyUpdateManyWithoutWorkExperienceNestedInput = {
    create?: XOR<WorkTechnologyCreateWithoutWorkExperienceInput, WorkTechnologyUncheckedCreateWithoutWorkExperienceInput> | WorkTechnologyCreateWithoutWorkExperienceInput[] | WorkTechnologyUncheckedCreateWithoutWorkExperienceInput[]
    connectOrCreate?: WorkTechnologyCreateOrConnectWithoutWorkExperienceInput | WorkTechnologyCreateOrConnectWithoutWorkExperienceInput[]
    upsert?: WorkTechnologyUpsertWithWhereUniqueWithoutWorkExperienceInput | WorkTechnologyUpsertWithWhereUniqueWithoutWorkExperienceInput[]
    createMany?: WorkTechnologyCreateManyWorkExperienceInputEnvelope
    set?: WorkTechnologyWhereUniqueInput | WorkTechnologyWhereUniqueInput[]
    disconnect?: WorkTechnologyWhereUniqueInput | WorkTechnologyWhereUniqueInput[]
    delete?: WorkTechnologyWhereUniqueInput | WorkTechnologyWhereUniqueInput[]
    connect?: WorkTechnologyWhereUniqueInput | WorkTechnologyWhereUniqueInput[]
    update?: WorkTechnologyUpdateWithWhereUniqueWithoutWorkExperienceInput | WorkTechnologyUpdateWithWhereUniqueWithoutWorkExperienceInput[]
    updateMany?: WorkTechnologyUpdateManyWithWhereWithoutWorkExperienceInput | WorkTechnologyUpdateManyWithWhereWithoutWorkExperienceInput[]
    deleteMany?: WorkTechnologyScalarWhereInput | WorkTechnologyScalarWhereInput[]
  }

  export type WorkAchievementUpdateManyWithoutWorkExperienceNestedInput = {
    create?: XOR<WorkAchievementCreateWithoutWorkExperienceInput, WorkAchievementUncheckedCreateWithoutWorkExperienceInput> | WorkAchievementCreateWithoutWorkExperienceInput[] | WorkAchievementUncheckedCreateWithoutWorkExperienceInput[]
    connectOrCreate?: WorkAchievementCreateOrConnectWithoutWorkExperienceInput | WorkAchievementCreateOrConnectWithoutWorkExperienceInput[]
    upsert?: WorkAchievementUpsertWithWhereUniqueWithoutWorkExperienceInput | WorkAchievementUpsertWithWhereUniqueWithoutWorkExperienceInput[]
    createMany?: WorkAchievementCreateManyWorkExperienceInputEnvelope
    set?: WorkAchievementWhereUniqueInput | WorkAchievementWhereUniqueInput[]
    disconnect?: WorkAchievementWhereUniqueInput | WorkAchievementWhereUniqueInput[]
    delete?: WorkAchievementWhereUniqueInput | WorkAchievementWhereUniqueInput[]
    connect?: WorkAchievementWhereUniqueInput | WorkAchievementWhereUniqueInput[]
    update?: WorkAchievementUpdateWithWhereUniqueWithoutWorkExperienceInput | WorkAchievementUpdateWithWhereUniqueWithoutWorkExperienceInput[]
    updateMany?: WorkAchievementUpdateManyWithWhereWithoutWorkExperienceInput | WorkAchievementUpdateManyWithWhereWithoutWorkExperienceInput[]
    deleteMany?: WorkAchievementScalarWhereInput | WorkAchievementScalarWhereInput[]
  }

  export type WorkResponsibilityUncheckedUpdateManyWithoutWorkExperienceNestedInput = {
    create?: XOR<WorkResponsibilityCreateWithoutWorkExperienceInput, WorkResponsibilityUncheckedCreateWithoutWorkExperienceInput> | WorkResponsibilityCreateWithoutWorkExperienceInput[] | WorkResponsibilityUncheckedCreateWithoutWorkExperienceInput[]
    connectOrCreate?: WorkResponsibilityCreateOrConnectWithoutWorkExperienceInput | WorkResponsibilityCreateOrConnectWithoutWorkExperienceInput[]
    upsert?: WorkResponsibilityUpsertWithWhereUniqueWithoutWorkExperienceInput | WorkResponsibilityUpsertWithWhereUniqueWithoutWorkExperienceInput[]
    createMany?: WorkResponsibilityCreateManyWorkExperienceInputEnvelope
    set?: WorkResponsibilityWhereUniqueInput | WorkResponsibilityWhereUniqueInput[]
    disconnect?: WorkResponsibilityWhereUniqueInput | WorkResponsibilityWhereUniqueInput[]
    delete?: WorkResponsibilityWhereUniqueInput | WorkResponsibilityWhereUniqueInput[]
    connect?: WorkResponsibilityWhereUniqueInput | WorkResponsibilityWhereUniqueInput[]
    update?: WorkResponsibilityUpdateWithWhereUniqueWithoutWorkExperienceInput | WorkResponsibilityUpdateWithWhereUniqueWithoutWorkExperienceInput[]
    updateMany?: WorkResponsibilityUpdateManyWithWhereWithoutWorkExperienceInput | WorkResponsibilityUpdateManyWithWhereWithoutWorkExperienceInput[]
    deleteMany?: WorkResponsibilityScalarWhereInput | WorkResponsibilityScalarWhereInput[]
  }

  export type WorkTechnologyUncheckedUpdateManyWithoutWorkExperienceNestedInput = {
    create?: XOR<WorkTechnologyCreateWithoutWorkExperienceInput, WorkTechnologyUncheckedCreateWithoutWorkExperienceInput> | WorkTechnologyCreateWithoutWorkExperienceInput[] | WorkTechnologyUncheckedCreateWithoutWorkExperienceInput[]
    connectOrCreate?: WorkTechnologyCreateOrConnectWithoutWorkExperienceInput | WorkTechnologyCreateOrConnectWithoutWorkExperienceInput[]
    upsert?: WorkTechnologyUpsertWithWhereUniqueWithoutWorkExperienceInput | WorkTechnologyUpsertWithWhereUniqueWithoutWorkExperienceInput[]
    createMany?: WorkTechnologyCreateManyWorkExperienceInputEnvelope
    set?: WorkTechnologyWhereUniqueInput | WorkTechnologyWhereUniqueInput[]
    disconnect?: WorkTechnologyWhereUniqueInput | WorkTechnologyWhereUniqueInput[]
    delete?: WorkTechnologyWhereUniqueInput | WorkTechnologyWhereUniqueInput[]
    connect?: WorkTechnologyWhereUniqueInput | WorkTechnologyWhereUniqueInput[]
    update?: WorkTechnologyUpdateWithWhereUniqueWithoutWorkExperienceInput | WorkTechnologyUpdateWithWhereUniqueWithoutWorkExperienceInput[]
    updateMany?: WorkTechnologyUpdateManyWithWhereWithoutWorkExperienceInput | WorkTechnologyUpdateManyWithWhereWithoutWorkExperienceInput[]
    deleteMany?: WorkTechnologyScalarWhereInput | WorkTechnologyScalarWhereInput[]
  }

  export type WorkAchievementUncheckedUpdateManyWithoutWorkExperienceNestedInput = {
    create?: XOR<WorkAchievementCreateWithoutWorkExperienceInput, WorkAchievementUncheckedCreateWithoutWorkExperienceInput> | WorkAchievementCreateWithoutWorkExperienceInput[] | WorkAchievementUncheckedCreateWithoutWorkExperienceInput[]
    connectOrCreate?: WorkAchievementCreateOrConnectWithoutWorkExperienceInput | WorkAchievementCreateOrConnectWithoutWorkExperienceInput[]
    upsert?: WorkAchievementUpsertWithWhereUniqueWithoutWorkExperienceInput | WorkAchievementUpsertWithWhereUniqueWithoutWorkExperienceInput[]
    createMany?: WorkAchievementCreateManyWorkExperienceInputEnvelope
    set?: WorkAchievementWhereUniqueInput | WorkAchievementWhereUniqueInput[]
    disconnect?: WorkAchievementWhereUniqueInput | WorkAchievementWhereUniqueInput[]
    delete?: WorkAchievementWhereUniqueInput | WorkAchievementWhereUniqueInput[]
    connect?: WorkAchievementWhereUniqueInput | WorkAchievementWhereUniqueInput[]
    update?: WorkAchievementUpdateWithWhereUniqueWithoutWorkExperienceInput | WorkAchievementUpdateWithWhereUniqueWithoutWorkExperienceInput[]
    updateMany?: WorkAchievementUpdateManyWithWhereWithoutWorkExperienceInput | WorkAchievementUpdateManyWithWhereWithoutWorkExperienceInput[]
    deleteMany?: WorkAchievementScalarWhereInput | WorkAchievementScalarWhereInput[]
  }

  export type WorkExperienceCreateNestedOneWithoutResponsibilitiesInput = {
    create?: XOR<WorkExperienceCreateWithoutResponsibilitiesInput, WorkExperienceUncheckedCreateWithoutResponsibilitiesInput>
    connectOrCreate?: WorkExperienceCreateOrConnectWithoutResponsibilitiesInput
    connect?: WorkExperienceWhereUniqueInput
  }

  export type WorkExperienceUpdateOneRequiredWithoutResponsibilitiesNestedInput = {
    create?: XOR<WorkExperienceCreateWithoutResponsibilitiesInput, WorkExperienceUncheckedCreateWithoutResponsibilitiesInput>
    connectOrCreate?: WorkExperienceCreateOrConnectWithoutResponsibilitiesInput
    upsert?: WorkExperienceUpsertWithoutResponsibilitiesInput
    connect?: WorkExperienceWhereUniqueInput
    update?: XOR<XOR<WorkExperienceUpdateToOneWithWhereWithoutResponsibilitiesInput, WorkExperienceUpdateWithoutResponsibilitiesInput>, WorkExperienceUncheckedUpdateWithoutResponsibilitiesInput>
  }

  export type WorkExperienceCreateNestedOneWithoutTechnologiesInput = {
    create?: XOR<WorkExperienceCreateWithoutTechnologiesInput, WorkExperienceUncheckedCreateWithoutTechnologiesInput>
    connectOrCreate?: WorkExperienceCreateOrConnectWithoutTechnologiesInput
    connect?: WorkExperienceWhereUniqueInput
  }

  export type WorkExperienceUpdateOneRequiredWithoutTechnologiesNestedInput = {
    create?: XOR<WorkExperienceCreateWithoutTechnologiesInput, WorkExperienceUncheckedCreateWithoutTechnologiesInput>
    connectOrCreate?: WorkExperienceCreateOrConnectWithoutTechnologiesInput
    upsert?: WorkExperienceUpsertWithoutTechnologiesInput
    connect?: WorkExperienceWhereUniqueInput
    update?: XOR<XOR<WorkExperienceUpdateToOneWithWhereWithoutTechnologiesInput, WorkExperienceUpdateWithoutTechnologiesInput>, WorkExperienceUncheckedUpdateWithoutTechnologiesInput>
  }

  export type WorkExperienceCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<WorkExperienceCreateWithoutAchievementsInput, WorkExperienceUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: WorkExperienceCreateOrConnectWithoutAchievementsInput
    connect?: WorkExperienceWhereUniqueInput
  }

  export type WorkExperienceUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<WorkExperienceCreateWithoutAchievementsInput, WorkExperienceUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: WorkExperienceCreateOrConnectWithoutAchievementsInput
    upsert?: WorkExperienceUpsertWithoutAchievementsInput
    connect?: WorkExperienceWhereUniqueInput
    update?: XOR<XOR<WorkExperienceUpdateToOneWithWhereWithoutAchievementsInput, WorkExperienceUpdateWithoutAchievementsInput>, WorkExperienceUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserCreateNestedOneWithoutEducationsInput = {
    create?: XOR<UserCreateWithoutEducationsInput, UserUncheckedCreateWithoutEducationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEducationsInput
    connect?: UserWhereUniqueInput
  }

  export type EducationAchievementCreateNestedManyWithoutEducationInput = {
    create?: XOR<EducationAchievementCreateWithoutEducationInput, EducationAchievementUncheckedCreateWithoutEducationInput> | EducationAchievementCreateWithoutEducationInput[] | EducationAchievementUncheckedCreateWithoutEducationInput[]
    connectOrCreate?: EducationAchievementCreateOrConnectWithoutEducationInput | EducationAchievementCreateOrConnectWithoutEducationInput[]
    createMany?: EducationAchievementCreateManyEducationInputEnvelope
    connect?: EducationAchievementWhereUniqueInput | EducationAchievementWhereUniqueInput[]
  }

  export type EducationAchievementUncheckedCreateNestedManyWithoutEducationInput = {
    create?: XOR<EducationAchievementCreateWithoutEducationInput, EducationAchievementUncheckedCreateWithoutEducationInput> | EducationAchievementCreateWithoutEducationInput[] | EducationAchievementUncheckedCreateWithoutEducationInput[]
    connectOrCreate?: EducationAchievementCreateOrConnectWithoutEducationInput | EducationAchievementCreateOrConnectWithoutEducationInput[]
    createMany?: EducationAchievementCreateManyEducationInputEnvelope
    connect?: EducationAchievementWhereUniqueInput | EducationAchievementWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutEducationsNestedInput = {
    create?: XOR<UserCreateWithoutEducationsInput, UserUncheckedCreateWithoutEducationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEducationsInput
    upsert?: UserUpsertWithoutEducationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEducationsInput, UserUpdateWithoutEducationsInput>, UserUncheckedUpdateWithoutEducationsInput>
  }

  export type EducationAchievementUpdateManyWithoutEducationNestedInput = {
    create?: XOR<EducationAchievementCreateWithoutEducationInput, EducationAchievementUncheckedCreateWithoutEducationInput> | EducationAchievementCreateWithoutEducationInput[] | EducationAchievementUncheckedCreateWithoutEducationInput[]
    connectOrCreate?: EducationAchievementCreateOrConnectWithoutEducationInput | EducationAchievementCreateOrConnectWithoutEducationInput[]
    upsert?: EducationAchievementUpsertWithWhereUniqueWithoutEducationInput | EducationAchievementUpsertWithWhereUniqueWithoutEducationInput[]
    createMany?: EducationAchievementCreateManyEducationInputEnvelope
    set?: EducationAchievementWhereUniqueInput | EducationAchievementWhereUniqueInput[]
    disconnect?: EducationAchievementWhereUniqueInput | EducationAchievementWhereUniqueInput[]
    delete?: EducationAchievementWhereUniqueInput | EducationAchievementWhereUniqueInput[]
    connect?: EducationAchievementWhereUniqueInput | EducationAchievementWhereUniqueInput[]
    update?: EducationAchievementUpdateWithWhereUniqueWithoutEducationInput | EducationAchievementUpdateWithWhereUniqueWithoutEducationInput[]
    updateMany?: EducationAchievementUpdateManyWithWhereWithoutEducationInput | EducationAchievementUpdateManyWithWhereWithoutEducationInput[]
    deleteMany?: EducationAchievementScalarWhereInput | EducationAchievementScalarWhereInput[]
  }

  export type EducationAchievementUncheckedUpdateManyWithoutEducationNestedInput = {
    create?: XOR<EducationAchievementCreateWithoutEducationInput, EducationAchievementUncheckedCreateWithoutEducationInput> | EducationAchievementCreateWithoutEducationInput[] | EducationAchievementUncheckedCreateWithoutEducationInput[]
    connectOrCreate?: EducationAchievementCreateOrConnectWithoutEducationInput | EducationAchievementCreateOrConnectWithoutEducationInput[]
    upsert?: EducationAchievementUpsertWithWhereUniqueWithoutEducationInput | EducationAchievementUpsertWithWhereUniqueWithoutEducationInput[]
    createMany?: EducationAchievementCreateManyEducationInputEnvelope
    set?: EducationAchievementWhereUniqueInput | EducationAchievementWhereUniqueInput[]
    disconnect?: EducationAchievementWhereUniqueInput | EducationAchievementWhereUniqueInput[]
    delete?: EducationAchievementWhereUniqueInput | EducationAchievementWhereUniqueInput[]
    connect?: EducationAchievementWhereUniqueInput | EducationAchievementWhereUniqueInput[]
    update?: EducationAchievementUpdateWithWhereUniqueWithoutEducationInput | EducationAchievementUpdateWithWhereUniqueWithoutEducationInput[]
    updateMany?: EducationAchievementUpdateManyWithWhereWithoutEducationInput | EducationAchievementUpdateManyWithWhereWithoutEducationInput[]
    deleteMany?: EducationAchievementScalarWhereInput | EducationAchievementScalarWhereInput[]
  }

  export type EducationCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<EducationCreateWithoutAchievementsInput, EducationUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: EducationCreateOrConnectWithoutAchievementsInput
    connect?: EducationWhereUniqueInput
  }

  export type EducationUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<EducationCreateWithoutAchievementsInput, EducationUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: EducationCreateOrConnectWithoutAchievementsInput
    upsert?: EducationUpsertWithoutAchievementsInput
    connect?: EducationWhereUniqueInput
    update?: XOR<XOR<EducationUpdateToOneWithWhereWithoutAchievementsInput, EducationUpdateWithoutAchievementsInput>, EducationUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserCreateNestedOneWithoutCertificationsInput = {
    create?: XOR<UserCreateWithoutCertificationsInput, UserUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificationsInput
    connect?: UserWhereUniqueInput
  }

  export type CertificationSkillCreateNestedManyWithoutCertificationInput = {
    create?: XOR<CertificationSkillCreateWithoutCertificationInput, CertificationSkillUncheckedCreateWithoutCertificationInput> | CertificationSkillCreateWithoutCertificationInput[] | CertificationSkillUncheckedCreateWithoutCertificationInput[]
    connectOrCreate?: CertificationSkillCreateOrConnectWithoutCertificationInput | CertificationSkillCreateOrConnectWithoutCertificationInput[]
    createMany?: CertificationSkillCreateManyCertificationInputEnvelope
    connect?: CertificationSkillWhereUniqueInput | CertificationSkillWhereUniqueInput[]
  }

  export type CertificationSkillUncheckedCreateNestedManyWithoutCertificationInput = {
    create?: XOR<CertificationSkillCreateWithoutCertificationInput, CertificationSkillUncheckedCreateWithoutCertificationInput> | CertificationSkillCreateWithoutCertificationInput[] | CertificationSkillUncheckedCreateWithoutCertificationInput[]
    connectOrCreate?: CertificationSkillCreateOrConnectWithoutCertificationInput | CertificationSkillCreateOrConnectWithoutCertificationInput[]
    createMany?: CertificationSkillCreateManyCertificationInputEnvelope
    connect?: CertificationSkillWhereUniqueInput | CertificationSkillWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCertificationsNestedInput = {
    create?: XOR<UserCreateWithoutCertificationsInput, UserUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificationsInput
    upsert?: UserUpsertWithoutCertificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCertificationsInput, UserUpdateWithoutCertificationsInput>, UserUncheckedUpdateWithoutCertificationsInput>
  }

  export type CertificationSkillUpdateManyWithoutCertificationNestedInput = {
    create?: XOR<CertificationSkillCreateWithoutCertificationInput, CertificationSkillUncheckedCreateWithoutCertificationInput> | CertificationSkillCreateWithoutCertificationInput[] | CertificationSkillUncheckedCreateWithoutCertificationInput[]
    connectOrCreate?: CertificationSkillCreateOrConnectWithoutCertificationInput | CertificationSkillCreateOrConnectWithoutCertificationInput[]
    upsert?: CertificationSkillUpsertWithWhereUniqueWithoutCertificationInput | CertificationSkillUpsertWithWhereUniqueWithoutCertificationInput[]
    createMany?: CertificationSkillCreateManyCertificationInputEnvelope
    set?: CertificationSkillWhereUniqueInput | CertificationSkillWhereUniqueInput[]
    disconnect?: CertificationSkillWhereUniqueInput | CertificationSkillWhereUniqueInput[]
    delete?: CertificationSkillWhereUniqueInput | CertificationSkillWhereUniqueInput[]
    connect?: CertificationSkillWhereUniqueInput | CertificationSkillWhereUniqueInput[]
    update?: CertificationSkillUpdateWithWhereUniqueWithoutCertificationInput | CertificationSkillUpdateWithWhereUniqueWithoutCertificationInput[]
    updateMany?: CertificationSkillUpdateManyWithWhereWithoutCertificationInput | CertificationSkillUpdateManyWithWhereWithoutCertificationInput[]
    deleteMany?: CertificationSkillScalarWhereInput | CertificationSkillScalarWhereInput[]
  }

  export type CertificationSkillUncheckedUpdateManyWithoutCertificationNestedInput = {
    create?: XOR<CertificationSkillCreateWithoutCertificationInput, CertificationSkillUncheckedCreateWithoutCertificationInput> | CertificationSkillCreateWithoutCertificationInput[] | CertificationSkillUncheckedCreateWithoutCertificationInput[]
    connectOrCreate?: CertificationSkillCreateOrConnectWithoutCertificationInput | CertificationSkillCreateOrConnectWithoutCertificationInput[]
    upsert?: CertificationSkillUpsertWithWhereUniqueWithoutCertificationInput | CertificationSkillUpsertWithWhereUniqueWithoutCertificationInput[]
    createMany?: CertificationSkillCreateManyCertificationInputEnvelope
    set?: CertificationSkillWhereUniqueInput | CertificationSkillWhereUniqueInput[]
    disconnect?: CertificationSkillWhereUniqueInput | CertificationSkillWhereUniqueInput[]
    delete?: CertificationSkillWhereUniqueInput | CertificationSkillWhereUniqueInput[]
    connect?: CertificationSkillWhereUniqueInput | CertificationSkillWhereUniqueInput[]
    update?: CertificationSkillUpdateWithWhereUniqueWithoutCertificationInput | CertificationSkillUpdateWithWhereUniqueWithoutCertificationInput[]
    updateMany?: CertificationSkillUpdateManyWithWhereWithoutCertificationInput | CertificationSkillUpdateManyWithWhereWithoutCertificationInput[]
    deleteMany?: CertificationSkillScalarWhereInput | CertificationSkillScalarWhereInput[]
  }

  export type CertificationCreateNestedOneWithoutSkillsInput = {
    create?: XOR<CertificationCreateWithoutSkillsInput, CertificationUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CertificationCreateOrConnectWithoutSkillsInput
    connect?: CertificationWhereUniqueInput
  }

  export type CertificationUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<CertificationCreateWithoutSkillsInput, CertificationUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CertificationCreateOrConnectWithoutSkillsInput
    upsert?: CertificationUpsertWithoutSkillsInput
    connect?: CertificationWhereUniqueInput
    update?: XOR<XOR<CertificationUpdateToOneWithWhereWithoutSkillsInput, CertificationUpdateWithoutSkillsInput>, CertificationUncheckedUpdateWithoutSkillsInput>
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserCreateNestedOneWithoutBlogPostsInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
  }

  export type BlogTagCreateNestedManyWithoutBlogPostInput = {
    create?: XOR<BlogTagCreateWithoutBlogPostInput, BlogTagUncheckedCreateWithoutBlogPostInput> | BlogTagCreateWithoutBlogPostInput[] | BlogTagUncheckedCreateWithoutBlogPostInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutBlogPostInput | BlogTagCreateOrConnectWithoutBlogPostInput[]
    createMany?: BlogTagCreateManyBlogPostInputEnvelope
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
  }

  export type BlogTagUncheckedCreateNestedManyWithoutBlogPostInput = {
    create?: XOR<BlogTagCreateWithoutBlogPostInput, BlogTagUncheckedCreateWithoutBlogPostInput> | BlogTagCreateWithoutBlogPostInput[] | BlogTagUncheckedCreateWithoutBlogPostInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutBlogPostInput | BlogTagCreateOrConnectWithoutBlogPostInput[]
    createMany?: BlogTagCreateManyBlogPostInputEnvelope
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutBlogPostsNestedInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    upsert?: UserUpsertWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogPostsInput, UserUpdateWithoutBlogPostsInput>, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type BlogTagUpdateManyWithoutBlogPostNestedInput = {
    create?: XOR<BlogTagCreateWithoutBlogPostInput, BlogTagUncheckedCreateWithoutBlogPostInput> | BlogTagCreateWithoutBlogPostInput[] | BlogTagUncheckedCreateWithoutBlogPostInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutBlogPostInput | BlogTagCreateOrConnectWithoutBlogPostInput[]
    upsert?: BlogTagUpsertWithWhereUniqueWithoutBlogPostInput | BlogTagUpsertWithWhereUniqueWithoutBlogPostInput[]
    createMany?: BlogTagCreateManyBlogPostInputEnvelope
    set?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    disconnect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    delete?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    update?: BlogTagUpdateWithWhereUniqueWithoutBlogPostInput | BlogTagUpdateWithWhereUniqueWithoutBlogPostInput[]
    updateMany?: BlogTagUpdateManyWithWhereWithoutBlogPostInput | BlogTagUpdateManyWithWhereWithoutBlogPostInput[]
    deleteMany?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
  }

  export type BlogTagUncheckedUpdateManyWithoutBlogPostNestedInput = {
    create?: XOR<BlogTagCreateWithoutBlogPostInput, BlogTagUncheckedCreateWithoutBlogPostInput> | BlogTagCreateWithoutBlogPostInput[] | BlogTagUncheckedCreateWithoutBlogPostInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutBlogPostInput | BlogTagCreateOrConnectWithoutBlogPostInput[]
    upsert?: BlogTagUpsertWithWhereUniqueWithoutBlogPostInput | BlogTagUpsertWithWhereUniqueWithoutBlogPostInput[]
    createMany?: BlogTagCreateManyBlogPostInputEnvelope
    set?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    disconnect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    delete?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    update?: BlogTagUpdateWithWhereUniqueWithoutBlogPostInput | BlogTagUpdateWithWhereUniqueWithoutBlogPostInput[]
    updateMany?: BlogTagUpdateManyWithWhereWithoutBlogPostInput | BlogTagUpdateManyWithWhereWithoutBlogPostInput[]
    deleteMany?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
  }

  export type BlogPostCreateNestedOneWithoutTagsInput = {
    create?: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutTagsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type BlogPostUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutTagsInput
    upsert?: BlogPostUpsertWithoutTagsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutTagsInput, BlogPostUpdateWithoutTagsInput>, BlogPostUncheckedUpdateWithoutTagsInput>
  }

  export type UserCreateNestedOneWithoutTestimonialsInput = {
    create?: XOR<UserCreateWithoutTestimonialsInput, UserUncheckedCreateWithoutTestimonialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestimonialsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectTestimonialCreateNestedManyWithoutTestimonialInput = {
    create?: XOR<ProjectTestimonialCreateWithoutTestimonialInput, ProjectTestimonialUncheckedCreateWithoutTestimonialInput> | ProjectTestimonialCreateWithoutTestimonialInput[] | ProjectTestimonialUncheckedCreateWithoutTestimonialInput[]
    connectOrCreate?: ProjectTestimonialCreateOrConnectWithoutTestimonialInput | ProjectTestimonialCreateOrConnectWithoutTestimonialInput[]
    createMany?: ProjectTestimonialCreateManyTestimonialInputEnvelope
    connect?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
  }

  export type ProjectTestimonialUncheckedCreateNestedManyWithoutTestimonialInput = {
    create?: XOR<ProjectTestimonialCreateWithoutTestimonialInput, ProjectTestimonialUncheckedCreateWithoutTestimonialInput> | ProjectTestimonialCreateWithoutTestimonialInput[] | ProjectTestimonialUncheckedCreateWithoutTestimonialInput[]
    connectOrCreate?: ProjectTestimonialCreateOrConnectWithoutTestimonialInput | ProjectTestimonialCreateOrConnectWithoutTestimonialInput[]
    createMany?: ProjectTestimonialCreateManyTestimonialInputEnvelope
    connect?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTestimonialsNestedInput = {
    create?: XOR<UserCreateWithoutTestimonialsInput, UserUncheckedCreateWithoutTestimonialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestimonialsInput
    upsert?: UserUpsertWithoutTestimonialsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestimonialsInput, UserUpdateWithoutTestimonialsInput>, UserUncheckedUpdateWithoutTestimonialsInput>
  }

  export type ProjectTestimonialUpdateManyWithoutTestimonialNestedInput = {
    create?: XOR<ProjectTestimonialCreateWithoutTestimonialInput, ProjectTestimonialUncheckedCreateWithoutTestimonialInput> | ProjectTestimonialCreateWithoutTestimonialInput[] | ProjectTestimonialUncheckedCreateWithoutTestimonialInput[]
    connectOrCreate?: ProjectTestimonialCreateOrConnectWithoutTestimonialInput | ProjectTestimonialCreateOrConnectWithoutTestimonialInput[]
    upsert?: ProjectTestimonialUpsertWithWhereUniqueWithoutTestimonialInput | ProjectTestimonialUpsertWithWhereUniqueWithoutTestimonialInput[]
    createMany?: ProjectTestimonialCreateManyTestimonialInputEnvelope
    set?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    disconnect?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    delete?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    connect?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    update?: ProjectTestimonialUpdateWithWhereUniqueWithoutTestimonialInput | ProjectTestimonialUpdateWithWhereUniqueWithoutTestimonialInput[]
    updateMany?: ProjectTestimonialUpdateManyWithWhereWithoutTestimonialInput | ProjectTestimonialUpdateManyWithWhereWithoutTestimonialInput[]
    deleteMany?: ProjectTestimonialScalarWhereInput | ProjectTestimonialScalarWhereInput[]
  }

  export type ProjectTestimonialUncheckedUpdateManyWithoutTestimonialNestedInput = {
    create?: XOR<ProjectTestimonialCreateWithoutTestimonialInput, ProjectTestimonialUncheckedCreateWithoutTestimonialInput> | ProjectTestimonialCreateWithoutTestimonialInput[] | ProjectTestimonialUncheckedCreateWithoutTestimonialInput[]
    connectOrCreate?: ProjectTestimonialCreateOrConnectWithoutTestimonialInput | ProjectTestimonialCreateOrConnectWithoutTestimonialInput[]
    upsert?: ProjectTestimonialUpsertWithWhereUniqueWithoutTestimonialInput | ProjectTestimonialUpsertWithWhereUniqueWithoutTestimonialInput[]
    createMany?: ProjectTestimonialCreateManyTestimonialInputEnvelope
    set?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    disconnect?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    delete?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    connect?: ProjectTestimonialWhereUniqueInput | ProjectTestimonialWhereUniqueInput[]
    update?: ProjectTestimonialUpdateWithWhereUniqueWithoutTestimonialInput | ProjectTestimonialUpdateWithWhereUniqueWithoutTestimonialInput[]
    updateMany?: ProjectTestimonialUpdateManyWithWhereWithoutTestimonialInput | ProjectTestimonialUpdateManyWithWhereWithoutTestimonialInput[]
    deleteMany?: ProjectTestimonialScalarWhereInput | ProjectTestimonialScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutContactsInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    upsert?: UserUpsertWithoutContactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactsInput, UserUpdateWithoutContactsInput>, UserUncheckedUpdateWithoutContactsInput>
  }

  export type UserCreateNestedOneWithoutSocialMediaInput = {
    create?: XOR<UserCreateWithoutSocialMediaInput, UserUncheckedCreateWithoutSocialMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialMediaInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSocialMediaNestedInput = {
    create?: XOR<UserCreateWithoutSocialMediaInput, UserUncheckedCreateWithoutSocialMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialMediaInput
    upsert?: UserUpsertWithoutSocialMediaInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSocialMediaInput, UserUpdateWithoutSocialMediaInput>, UserUncheckedUpdateWithoutSocialMediaInput>
  }

  export type UserCreateNestedOneWithoutDevStatsInput = {
    create?: XOR<UserCreateWithoutDevStatsInput, UserUncheckedCreateWithoutDevStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevStatsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutDevStatsNestedInput = {
    create?: XOR<UserCreateWithoutDevStatsInput, UserUncheckedCreateWithoutDevStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevStatsInput
    upsert?: UserUpsertWithoutDevStatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDevStatsInput, UserUpdateWithoutDevStatsInput>, UserUncheckedUpdateWithoutDevStatsInput>
  }

  export type UserCreateNestedOneWithoutContributionDataInput = {
    create?: XOR<UserCreateWithoutContributionDataInput, UserUncheckedCreateWithoutContributionDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutContributionDataInput
    connect?: UserWhereUniqueInput
  }

  export type ContributionDayCreateNestedManyWithoutContributionDataInput = {
    create?: XOR<ContributionDayCreateWithoutContributionDataInput, ContributionDayUncheckedCreateWithoutContributionDataInput> | ContributionDayCreateWithoutContributionDataInput[] | ContributionDayUncheckedCreateWithoutContributionDataInput[]
    connectOrCreate?: ContributionDayCreateOrConnectWithoutContributionDataInput | ContributionDayCreateOrConnectWithoutContributionDataInput[]
    createMany?: ContributionDayCreateManyContributionDataInputEnvelope
    connect?: ContributionDayWhereUniqueInput | ContributionDayWhereUniqueInput[]
  }

  export type ContributionDayUncheckedCreateNestedManyWithoutContributionDataInput = {
    create?: XOR<ContributionDayCreateWithoutContributionDataInput, ContributionDayUncheckedCreateWithoutContributionDataInput> | ContributionDayCreateWithoutContributionDataInput[] | ContributionDayUncheckedCreateWithoutContributionDataInput[]
    connectOrCreate?: ContributionDayCreateOrConnectWithoutContributionDataInput | ContributionDayCreateOrConnectWithoutContributionDataInput[]
    createMany?: ContributionDayCreateManyContributionDataInputEnvelope
    connect?: ContributionDayWhereUniqueInput | ContributionDayWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutContributionDataNestedInput = {
    create?: XOR<UserCreateWithoutContributionDataInput, UserUncheckedCreateWithoutContributionDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutContributionDataInput
    upsert?: UserUpsertWithoutContributionDataInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContributionDataInput, UserUpdateWithoutContributionDataInput>, UserUncheckedUpdateWithoutContributionDataInput>
  }

  export type ContributionDayUpdateManyWithoutContributionDataNestedInput = {
    create?: XOR<ContributionDayCreateWithoutContributionDataInput, ContributionDayUncheckedCreateWithoutContributionDataInput> | ContributionDayCreateWithoutContributionDataInput[] | ContributionDayUncheckedCreateWithoutContributionDataInput[]
    connectOrCreate?: ContributionDayCreateOrConnectWithoutContributionDataInput | ContributionDayCreateOrConnectWithoutContributionDataInput[]
    upsert?: ContributionDayUpsertWithWhereUniqueWithoutContributionDataInput | ContributionDayUpsertWithWhereUniqueWithoutContributionDataInput[]
    createMany?: ContributionDayCreateManyContributionDataInputEnvelope
    set?: ContributionDayWhereUniqueInput | ContributionDayWhereUniqueInput[]
    disconnect?: ContributionDayWhereUniqueInput | ContributionDayWhereUniqueInput[]
    delete?: ContributionDayWhereUniqueInput | ContributionDayWhereUniqueInput[]
    connect?: ContributionDayWhereUniqueInput | ContributionDayWhereUniqueInput[]
    update?: ContributionDayUpdateWithWhereUniqueWithoutContributionDataInput | ContributionDayUpdateWithWhereUniqueWithoutContributionDataInput[]
    updateMany?: ContributionDayUpdateManyWithWhereWithoutContributionDataInput | ContributionDayUpdateManyWithWhereWithoutContributionDataInput[]
    deleteMany?: ContributionDayScalarWhereInput | ContributionDayScalarWhereInput[]
  }

  export type ContributionDayUncheckedUpdateManyWithoutContributionDataNestedInput = {
    create?: XOR<ContributionDayCreateWithoutContributionDataInput, ContributionDayUncheckedCreateWithoutContributionDataInput> | ContributionDayCreateWithoutContributionDataInput[] | ContributionDayUncheckedCreateWithoutContributionDataInput[]
    connectOrCreate?: ContributionDayCreateOrConnectWithoutContributionDataInput | ContributionDayCreateOrConnectWithoutContributionDataInput[]
    upsert?: ContributionDayUpsertWithWhereUniqueWithoutContributionDataInput | ContributionDayUpsertWithWhereUniqueWithoutContributionDataInput[]
    createMany?: ContributionDayCreateManyContributionDataInputEnvelope
    set?: ContributionDayWhereUniqueInput | ContributionDayWhereUniqueInput[]
    disconnect?: ContributionDayWhereUniqueInput | ContributionDayWhereUniqueInput[]
    delete?: ContributionDayWhereUniqueInput | ContributionDayWhereUniqueInput[]
    connect?: ContributionDayWhereUniqueInput | ContributionDayWhereUniqueInput[]
    update?: ContributionDayUpdateWithWhereUniqueWithoutContributionDataInput | ContributionDayUpdateWithWhereUniqueWithoutContributionDataInput[]
    updateMany?: ContributionDayUpdateManyWithWhereWithoutContributionDataInput | ContributionDayUpdateManyWithWhereWithoutContributionDataInput[]
    deleteMany?: ContributionDayScalarWhereInput | ContributionDayScalarWhereInput[]
  }

  export type ContributionDataCreateNestedOneWithoutDaysInput = {
    create?: XOR<ContributionDataCreateWithoutDaysInput, ContributionDataUncheckedCreateWithoutDaysInput>
    connectOrCreate?: ContributionDataCreateOrConnectWithoutDaysInput
    connect?: ContributionDataWhereUniqueInput
  }

  export type ContributionDataUpdateOneRequiredWithoutDaysNestedInput = {
    create?: XOR<ContributionDataCreateWithoutDaysInput, ContributionDataUncheckedCreateWithoutDaysInput>
    connectOrCreate?: ContributionDataCreateOrConnectWithoutDaysInput
    upsert?: ContributionDataUpsertWithoutDaysInput
    connect?: ContributionDataWhereUniqueInput
    update?: XOR<XOR<ContributionDataUpdateToOneWithWhereWithoutDaysInput, ContributionDataUpdateWithoutDaysInput>, ContributionDataUncheckedUpdateWithoutDaysInput>
  }

  export type UserCreateNestedOneWithoutTimelineEventsInput = {
    create?: XOR<UserCreateWithoutTimelineEventsInput, UserUncheckedCreateWithoutTimelineEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimelineEventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTimelineEventsNestedInput = {
    create?: XOR<UserCreateWithoutTimelineEventsInput, UserUncheckedCreateWithoutTimelineEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimelineEventsInput
    upsert?: UserUpsertWithoutTimelineEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTimelineEventsInput, UserUpdateWithoutTimelineEventsInput>, UserUncheckedUpdateWithoutTimelineEventsInput>
  }

  export type ProjectCreateNestedOneWithoutTestimonialsInput = {
    create?: XOR<ProjectCreateWithoutTestimonialsInput, ProjectUncheckedCreateWithoutTestimonialsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTestimonialsInput
    connect?: ProjectWhereUniqueInput
  }

  export type TestimonialCreateNestedOneWithoutProjectTestimonialsInput = {
    create?: XOR<TestimonialCreateWithoutProjectTestimonialsInput, TestimonialUncheckedCreateWithoutProjectTestimonialsInput>
    connectOrCreate?: TestimonialCreateOrConnectWithoutProjectTestimonialsInput
    connect?: TestimonialWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutTestimonialsNestedInput = {
    create?: XOR<ProjectCreateWithoutTestimonialsInput, ProjectUncheckedCreateWithoutTestimonialsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTestimonialsInput
    upsert?: ProjectUpsertWithoutTestimonialsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTestimonialsInput, ProjectUpdateWithoutTestimonialsInput>, ProjectUncheckedUpdateWithoutTestimonialsInput>
  }

  export type TestimonialUpdateOneRequiredWithoutProjectTestimonialsNestedInput = {
    create?: XOR<TestimonialCreateWithoutProjectTestimonialsInput, TestimonialUncheckedCreateWithoutProjectTestimonialsInput>
    connectOrCreate?: TestimonialCreateOrConnectWithoutProjectTestimonialsInput
    upsert?: TestimonialUpsertWithoutProjectTestimonialsInput
    connect?: TestimonialWhereUniqueInput
    update?: XOR<XOR<TestimonialUpdateToOneWithWhereWithoutProjectTestimonialsInput, TestimonialUpdateWithoutProjectTestimonialsInput>, TestimonialUncheckedUpdateWithoutProjectTestimonialsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SkillCreateWithoutUserInput = {
    id?: string
    name: string
    percentage: number
    color?: string | null
    icon?: string | null
    category?: string | null
    description?: string | null
    years?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutSkillsInput
  }

  export type SkillUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    percentage: number
    color?: string | null
    icon?: string | null
    category?: string | null
    description?: string | null
    years?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutSkillsInput
  }

  export type SkillCreateOrConnectWithoutUserInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutUserInput, SkillUncheckedCreateWithoutUserInput>
  }

  export type SkillCreateManyUserInputEnvelope = {
    data: SkillCreateManyUserInput | SkillCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutUserInput = {
    id?: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: ProjectFeatureCreateNestedManyWithoutProjectInput
    techStack?: ProjectTechStackCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    learnings?: ProjectLearningCreateNestedManyWithoutProjectInput
    testimonials?: ProjectTestimonialCreateNestedManyWithoutProjectInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: ProjectFeatureUncheckedCreateNestedManyWithoutProjectInput
    techStack?: ProjectTechStackUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    learnings?: ProjectLearningUncheckedCreateNestedManyWithoutProjectInput
    testimonials?: ProjectTestimonialUncheckedCreateNestedManyWithoutProjectInput
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutUserInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectCreateManyUserInputEnvelope = {
    data: ProjectCreateManyUserInput | ProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkExperienceCreateWithoutUserInput = {
    id?: string
    company: string
    position: string
    period: string
    description?: string | null
    location?: string | null
    type?: string | null
    logo?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibilities?: WorkResponsibilityCreateNestedManyWithoutWorkExperienceInput
    technologies?: WorkTechnologyCreateNestedManyWithoutWorkExperienceInput
    achievements?: WorkAchievementCreateNestedManyWithoutWorkExperienceInput
  }

  export type WorkExperienceUncheckedCreateWithoutUserInput = {
    id?: string
    company: string
    position: string
    period: string
    description?: string | null
    location?: string | null
    type?: string | null
    logo?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibilities?: WorkResponsibilityUncheckedCreateNestedManyWithoutWorkExperienceInput
    technologies?: WorkTechnologyUncheckedCreateNestedManyWithoutWorkExperienceInput
    achievements?: WorkAchievementUncheckedCreateNestedManyWithoutWorkExperienceInput
  }

  export type WorkExperienceCreateOrConnectWithoutUserInput = {
    where: WorkExperienceWhereUniqueInput
    create: XOR<WorkExperienceCreateWithoutUserInput, WorkExperienceUncheckedCreateWithoutUserInput>
  }

  export type WorkExperienceCreateManyUserInputEnvelope = {
    data: WorkExperienceCreateManyUserInput | WorkExperienceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EducationCreateWithoutUserInput = {
    id?: string
    institution: string
    degree: string
    field: string
    period: string
    description?: string | null
    gpa?: string | null
    location?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: EducationAchievementCreateNestedManyWithoutEducationInput
  }

  export type EducationUncheckedCreateWithoutUserInput = {
    id?: string
    institution: string
    degree: string
    field: string
    period: string
    description?: string | null
    gpa?: string | null
    location?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: EducationAchievementUncheckedCreateNestedManyWithoutEducationInput
  }

  export type EducationCreateOrConnectWithoutUserInput = {
    where: EducationWhereUniqueInput
    create: XOR<EducationCreateWithoutUserInput, EducationUncheckedCreateWithoutUserInput>
  }

  export type EducationCreateManyUserInputEnvelope = {
    data: EducationCreateManyUserInput | EducationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CertificationCreateWithoutUserInput = {
    id?: string
    name: string
    issuer: string
    date: Date | string
    icon?: string | null
    credentialId?: string | null
    expiry?: Date | string | null
    description?: string | null
    verificationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: CertificationSkillCreateNestedManyWithoutCertificationInput
  }

  export type CertificationUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    issuer: string
    date: Date | string
    icon?: string | null
    credentialId?: string | null
    expiry?: Date | string | null
    description?: string | null
    verificationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: CertificationSkillUncheckedCreateNestedManyWithoutCertificationInput
  }

  export type CertificationCreateOrConnectWithoutUserInput = {
    where: CertificationWhereUniqueInput
    create: XOR<CertificationCreateWithoutUserInput, CertificationUncheckedCreateWithoutUserInput>
  }

  export type CertificationCreateManyUserInputEnvelope = {
    data: CertificationCreateManyUserInput | CertificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AchievementCreateWithoutUserInput = {
    id?: string
    title: string
    date: Date | string
    description?: string | null
    icon?: string | null
    category?: string | null
    issuer?: string | null
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    date: Date | string
    description?: string | null
    icon?: string | null
    category?: string | null
    issuer?: string | null
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutUserInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput>
  }

  export type AchievementCreateManyUserInputEnvelope = {
    data: AchievementCreateManyUserInput | AchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostCreateWithoutUserInput = {
    id?: string
    slug: string
    title: string
    excerpt: string
    content: string
    date: Date | string
    readTime: number
    image?: string | null
    likes?: number
    comments?: number
    shares?: number
    views?: number
    category: string
    author: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: BlogTagCreateNestedManyWithoutBlogPostInput
  }

  export type BlogPostUncheckedCreateWithoutUserInput = {
    id?: string
    slug: string
    title: string
    excerpt: string
    content: string
    date: Date | string
    readTime: number
    image?: string | null
    likes?: number
    comments?: number
    shares?: number
    views?: number
    category: string
    author: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: BlogTagUncheckedCreateNestedManyWithoutBlogPostInput
  }

  export type BlogPostCreateOrConnectWithoutUserInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput>
  }

  export type BlogPostCreateManyUserInputEnvelope = {
    data: BlogPostCreateManyUserInput | BlogPostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TestimonialCreateWithoutUserInput = {
    id?: string
    name: string
    position: string
    company: string
    text: string
    avatar?: string | null
    rating: number
    date: Date | string
    relation: string
    projectLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTestimonials?: ProjectTestimonialCreateNestedManyWithoutTestimonialInput
  }

  export type TestimonialUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    position: string
    company: string
    text: string
    avatar?: string | null
    rating: number
    date: Date | string
    relation: string
    projectLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTestimonials?: ProjectTestimonialUncheckedCreateNestedManyWithoutTestimonialInput
  }

  export type TestimonialCreateOrConnectWithoutUserInput = {
    where: TestimonialWhereUniqueInput
    create: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput>
  }

  export type TestimonialCreateManyUserInputEnvelope = {
    data: TestimonialCreateManyUserInput | TestimonialCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutUserInput = {
    id?: string
    type: string
    value: string
    icon?: string | null
    isPublic?: boolean
    link?: string | null
  }

  export type ContactUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    value: string
    icon?: string | null
    isPublic?: boolean
    link?: string | null
  }

  export type ContactCreateOrConnectWithoutUserInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput>
  }

  export type ContactCreateManyUserInputEnvelope = {
    data: ContactCreateManyUserInput | ContactCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SocialMediaCreateWithoutUserInput = {
    id?: string
    platform: string
    url: string
    icon?: string | null
    username: string
  }

  export type SocialMediaUncheckedCreateWithoutUserInput = {
    id?: string
    platform: string
    url: string
    icon?: string | null
    username: string
  }

  export type SocialMediaCreateOrConnectWithoutUserInput = {
    where: SocialMediaWhereUniqueInput
    create: XOR<SocialMediaCreateWithoutUserInput, SocialMediaUncheckedCreateWithoutUserInput>
  }

  export type SocialMediaCreateManyUserInputEnvelope = {
    data: SocialMediaCreateManyUserInput | SocialMediaCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DevStatsCreateWithoutUserInput = {
    id?: string
    repos?: number
    stars?: number
    contributions?: number
    rating?: number
    followers?: number
    following?: number
    streak?: number
    commits?: number
    prsOpened?: number
    issuesClosed?: number
    rank?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DevStatsUncheckedCreateWithoutUserInput = {
    id?: string
    repos?: number
    stars?: number
    contributions?: number
    rating?: number
    followers?: number
    following?: number
    streak?: number
    commits?: number
    prsOpened?: number
    issuesClosed?: number
    rank?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DevStatsCreateOrConnectWithoutUserInput = {
    where: DevStatsWhereUniqueInput
    create: XOR<DevStatsCreateWithoutUserInput, DevStatsUncheckedCreateWithoutUserInput>
  }

  export type ContributionDataCreateWithoutUserInput = {
    id?: string
    year: number
    total: number
    startRange: Date | string
    endRange: Date | string
    days?: ContributionDayCreateNestedManyWithoutContributionDataInput
  }

  export type ContributionDataUncheckedCreateWithoutUserInput = {
    id?: string
    year: number
    total: number
    startRange: Date | string
    endRange: Date | string
    days?: ContributionDayUncheckedCreateNestedManyWithoutContributionDataInput
  }

  export type ContributionDataCreateOrConnectWithoutUserInput = {
    where: ContributionDataWhereUniqueInput
    create: XOR<ContributionDataCreateWithoutUserInput, ContributionDataUncheckedCreateWithoutUserInput>
  }

  export type ContributionDataCreateManyUserInputEnvelope = {
    data: ContributionDataCreateManyUserInput | ContributionDataCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TimelineEventCreateWithoutUserInput = {
    id?: string
    date: Date | string
    type: string
    title: string
    subtitle?: string | null
    description?: string | null
    icon?: string | null
    color?: string | null
  }

  export type TimelineEventUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    type: string
    title: string
    subtitle?: string | null
    description?: string | null
    icon?: string | null
    color?: string | null
  }

  export type TimelineEventCreateOrConnectWithoutUserInput = {
    where: TimelineEventWhereUniqueInput
    create: XOR<TimelineEventCreateWithoutUserInput, TimelineEventUncheckedCreateWithoutUserInput>
  }

  export type TimelineEventCreateManyUserInputEnvelope = {
    data: TimelineEventCreateManyUserInput | TimelineEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SkillUpsertWithWhereUniqueWithoutUserInput = {
    where: SkillWhereUniqueInput
    update: XOR<SkillUpdateWithoutUserInput, SkillUncheckedUpdateWithoutUserInput>
    create: XOR<SkillCreateWithoutUserInput, SkillUncheckedCreateWithoutUserInput>
  }

  export type SkillUpdateWithWhereUniqueWithoutUserInput = {
    where: SkillWhereUniqueInput
    data: XOR<SkillUpdateWithoutUserInput, SkillUncheckedUpdateWithoutUserInput>
  }

  export type SkillUpdateManyWithWhereWithoutUserInput = {
    where: SkillScalarWhereInput
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyWithoutUserInput>
  }

  export type SkillScalarWhereInput = {
    AND?: SkillScalarWhereInput | SkillScalarWhereInput[]
    OR?: SkillScalarWhereInput[]
    NOT?: SkillScalarWhereInput | SkillScalarWhereInput[]
    id?: StringFilter<"Skill"> | string
    userId?: StringFilter<"Skill"> | string
    name?: StringFilter<"Skill"> | string
    percentage?: IntFilter<"Skill"> | number
    color?: StringNullableFilter<"Skill"> | string | null
    icon?: StringNullableFilter<"Skill"> | string | null
    category?: StringNullableFilter<"Skill"> | string | null
    description?: StringNullableFilter<"Skill"> | string | null
    years?: FloatNullableFilter<"Skill"> | number | null
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateManyWithWhereWithoutUserInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    userId?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    slug?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    longDescription?: StringFilter<"Project"> | string
    category?: StringFilter<"Project"> | string
    image?: StringNullableFilter<"Project"> | string | null
    demoUrl?: StringNullableFilter<"Project"> | string | null
    githubUrl?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    branches?: IntNullableFilter<"Project"> | number | null
    stars?: IntNullableFilter<"Project"> | number | null
    views?: IntNullableFilter<"Project"> | number | null
    forks?: IntNullableFilter<"Project"> | number | null
    issues?: IntNullableFilter<"Project"> | number | null
    commits?: IntNullableFilter<"Project"> | number | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type WorkExperienceUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkExperienceWhereUniqueInput
    update: XOR<WorkExperienceUpdateWithoutUserInput, WorkExperienceUncheckedUpdateWithoutUserInput>
    create: XOR<WorkExperienceCreateWithoutUserInput, WorkExperienceUncheckedCreateWithoutUserInput>
  }

  export type WorkExperienceUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkExperienceWhereUniqueInput
    data: XOR<WorkExperienceUpdateWithoutUserInput, WorkExperienceUncheckedUpdateWithoutUserInput>
  }

  export type WorkExperienceUpdateManyWithWhereWithoutUserInput = {
    where: WorkExperienceScalarWhereInput
    data: XOR<WorkExperienceUpdateManyMutationInput, WorkExperienceUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkExperienceScalarWhereInput = {
    AND?: WorkExperienceScalarWhereInput | WorkExperienceScalarWhereInput[]
    OR?: WorkExperienceScalarWhereInput[]
    NOT?: WorkExperienceScalarWhereInput | WorkExperienceScalarWhereInput[]
    id?: StringFilter<"WorkExperience"> | string
    userId?: StringFilter<"WorkExperience"> | string
    company?: StringFilter<"WorkExperience"> | string
    position?: StringFilter<"WorkExperience"> | string
    period?: StringFilter<"WorkExperience"> | string
    description?: StringNullableFilter<"WorkExperience"> | string | null
    location?: StringNullableFilter<"WorkExperience"> | string | null
    type?: StringNullableFilter<"WorkExperience"> | string | null
    logo?: StringNullableFilter<"WorkExperience"> | string | null
    website?: StringNullableFilter<"WorkExperience"> | string | null
    createdAt?: DateTimeFilter<"WorkExperience"> | Date | string
    updatedAt?: DateTimeFilter<"WorkExperience"> | Date | string
  }

  export type EducationUpsertWithWhereUniqueWithoutUserInput = {
    where: EducationWhereUniqueInput
    update: XOR<EducationUpdateWithoutUserInput, EducationUncheckedUpdateWithoutUserInput>
    create: XOR<EducationCreateWithoutUserInput, EducationUncheckedCreateWithoutUserInput>
  }

  export type EducationUpdateWithWhereUniqueWithoutUserInput = {
    where: EducationWhereUniqueInput
    data: XOR<EducationUpdateWithoutUserInput, EducationUncheckedUpdateWithoutUserInput>
  }

  export type EducationUpdateManyWithWhereWithoutUserInput = {
    where: EducationScalarWhereInput
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyWithoutUserInput>
  }

  export type EducationScalarWhereInput = {
    AND?: EducationScalarWhereInput | EducationScalarWhereInput[]
    OR?: EducationScalarWhereInput[]
    NOT?: EducationScalarWhereInput | EducationScalarWhereInput[]
    id?: StringFilter<"Education"> | string
    userId?: StringFilter<"Education"> | string
    institution?: StringFilter<"Education"> | string
    degree?: StringFilter<"Education"> | string
    field?: StringFilter<"Education"> | string
    period?: StringFilter<"Education"> | string
    description?: StringNullableFilter<"Education"> | string | null
    gpa?: StringNullableFilter<"Education"> | string | null
    location?: StringNullableFilter<"Education"> | string | null
    logo?: StringNullableFilter<"Education"> | string | null
    createdAt?: DateTimeFilter<"Education"> | Date | string
    updatedAt?: DateTimeFilter<"Education"> | Date | string
  }

  export type CertificationUpsertWithWhereUniqueWithoutUserInput = {
    where: CertificationWhereUniqueInput
    update: XOR<CertificationUpdateWithoutUserInput, CertificationUncheckedUpdateWithoutUserInput>
    create: XOR<CertificationCreateWithoutUserInput, CertificationUncheckedCreateWithoutUserInput>
  }

  export type CertificationUpdateWithWhereUniqueWithoutUserInput = {
    where: CertificationWhereUniqueInput
    data: XOR<CertificationUpdateWithoutUserInput, CertificationUncheckedUpdateWithoutUserInput>
  }

  export type CertificationUpdateManyWithWhereWithoutUserInput = {
    where: CertificationScalarWhereInput
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyWithoutUserInput>
  }

  export type CertificationScalarWhereInput = {
    AND?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
    OR?: CertificationScalarWhereInput[]
    NOT?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
    id?: StringFilter<"Certification"> | string
    userId?: StringFilter<"Certification"> | string
    name?: StringFilter<"Certification"> | string
    issuer?: StringFilter<"Certification"> | string
    date?: DateTimeFilter<"Certification"> | Date | string
    icon?: StringNullableFilter<"Certification"> | string | null
    credentialId?: StringNullableFilter<"Certification"> | string | null
    expiry?: DateTimeNullableFilter<"Certification"> | Date | string | null
    description?: StringNullableFilter<"Certification"> | string | null
    verificationUrl?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
  }

  export type AchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: AchievementWhereUniqueInput
    update: XOR<AchievementUpdateWithoutUserInput, AchievementUncheckedUpdateWithoutUserInput>
    create: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput>
  }

  export type AchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: AchievementWhereUniqueInput
    data: XOR<AchievementUpdateWithoutUserInput, AchievementUncheckedUpdateWithoutUserInput>
  }

  export type AchievementUpdateManyWithWhereWithoutUserInput = {
    where: AchievementScalarWhereInput
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type AchievementScalarWhereInput = {
    AND?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    OR?: AchievementScalarWhereInput[]
    NOT?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    id?: StringFilter<"Achievement"> | string
    userId?: StringFilter<"Achievement"> | string
    title?: StringFilter<"Achievement"> | string
    date?: DateTimeFilter<"Achievement"> | Date | string
    description?: StringNullableFilter<"Achievement"> | string | null
    icon?: StringNullableFilter<"Achievement"> | string | null
    category?: StringNullableFilter<"Achievement"> | string | null
    issuer?: StringNullableFilter<"Achievement"> | string | null
    link?: StringNullableFilter<"Achievement"> | string | null
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
  }

  export type BlogPostUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutUserInput, BlogPostUncheckedUpdateWithoutUserInput>
    create: XOR<BlogPostCreateWithoutUserInput, BlogPostUncheckedCreateWithoutUserInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutUserInput, BlogPostUncheckedUpdateWithoutUserInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutUserInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutUserInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    userId?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    excerpt?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    date?: DateTimeFilter<"BlogPost"> | Date | string
    readTime?: IntFilter<"BlogPost"> | number
    image?: StringNullableFilter<"BlogPost"> | string | null
    likes?: IntFilter<"BlogPost"> | number
    comments?: IntFilter<"BlogPost"> | number
    shares?: IntFilter<"BlogPost"> | number
    views?: IntFilter<"BlogPost"> | number
    category?: StringFilter<"BlogPost"> | string
    author?: StringFilter<"BlogPost"> | string
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
  }

  export type TestimonialUpsertWithWhereUniqueWithoutUserInput = {
    where: TestimonialWhereUniqueInput
    update: XOR<TestimonialUpdateWithoutUserInput, TestimonialUncheckedUpdateWithoutUserInput>
    create: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput>
  }

  export type TestimonialUpdateWithWhereUniqueWithoutUserInput = {
    where: TestimonialWhereUniqueInput
    data: XOR<TestimonialUpdateWithoutUserInput, TestimonialUncheckedUpdateWithoutUserInput>
  }

  export type TestimonialUpdateManyWithWhereWithoutUserInput = {
    where: TestimonialScalarWhereInput
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyWithoutUserInput>
  }

  export type TestimonialScalarWhereInput = {
    AND?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
    OR?: TestimonialScalarWhereInput[]
    NOT?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
    id?: StringFilter<"Testimonial"> | string
    userId?: StringFilter<"Testimonial"> | string
    name?: StringFilter<"Testimonial"> | string
    position?: StringFilter<"Testimonial"> | string
    company?: StringFilter<"Testimonial"> | string
    text?: StringFilter<"Testimonial"> | string
    avatar?: StringNullableFilter<"Testimonial"> | string | null
    rating?: IntFilter<"Testimonial"> | number
    date?: DateTimeFilter<"Testimonial"> | Date | string
    relation?: StringFilter<"Testimonial"> | string
    projectLink?: StringNullableFilter<"Testimonial"> | string | null
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"Testimonial"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutUserInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutUserInput, ContactUncheckedUpdateWithoutUserInput>
    create: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutUserInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutUserInput, ContactUncheckedUpdateWithoutUserInput>
  }

  export type ContactUpdateManyWithWhereWithoutUserInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutUserInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    userId?: StringFilter<"Contact"> | string
    type?: StringFilter<"Contact"> | string
    value?: StringFilter<"Contact"> | string
    icon?: StringNullableFilter<"Contact"> | string | null
    isPublic?: BoolFilter<"Contact"> | boolean
    link?: StringNullableFilter<"Contact"> | string | null
  }

  export type SocialMediaUpsertWithWhereUniqueWithoutUserInput = {
    where: SocialMediaWhereUniqueInput
    update: XOR<SocialMediaUpdateWithoutUserInput, SocialMediaUncheckedUpdateWithoutUserInput>
    create: XOR<SocialMediaCreateWithoutUserInput, SocialMediaUncheckedCreateWithoutUserInput>
  }

  export type SocialMediaUpdateWithWhereUniqueWithoutUserInput = {
    where: SocialMediaWhereUniqueInput
    data: XOR<SocialMediaUpdateWithoutUserInput, SocialMediaUncheckedUpdateWithoutUserInput>
  }

  export type SocialMediaUpdateManyWithWhereWithoutUserInput = {
    where: SocialMediaScalarWhereInput
    data: XOR<SocialMediaUpdateManyMutationInput, SocialMediaUncheckedUpdateManyWithoutUserInput>
  }

  export type SocialMediaScalarWhereInput = {
    AND?: SocialMediaScalarWhereInput | SocialMediaScalarWhereInput[]
    OR?: SocialMediaScalarWhereInput[]
    NOT?: SocialMediaScalarWhereInput | SocialMediaScalarWhereInput[]
    id?: StringFilter<"SocialMedia"> | string
    userId?: StringFilter<"SocialMedia"> | string
    platform?: StringFilter<"SocialMedia"> | string
    url?: StringFilter<"SocialMedia"> | string
    icon?: StringNullableFilter<"SocialMedia"> | string | null
    username?: StringFilter<"SocialMedia"> | string
  }

  export type DevStatsUpsertWithoutUserInput = {
    update: XOR<DevStatsUpdateWithoutUserInput, DevStatsUncheckedUpdateWithoutUserInput>
    create: XOR<DevStatsCreateWithoutUserInput, DevStatsUncheckedCreateWithoutUserInput>
    where?: DevStatsWhereInput
  }

  export type DevStatsUpdateToOneWithWhereWithoutUserInput = {
    where?: DevStatsWhereInput
    data: XOR<DevStatsUpdateWithoutUserInput, DevStatsUncheckedUpdateWithoutUserInput>
  }

  export type DevStatsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    repos?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    contributions?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    commits?: IntFieldUpdateOperationsInput | number
    prsOpened?: IntFieldUpdateOperationsInput | number
    issuesClosed?: IntFieldUpdateOperationsInput | number
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevStatsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    repos?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    contributions?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    commits?: IntFieldUpdateOperationsInput | number
    prsOpened?: IntFieldUpdateOperationsInput | number
    issuesClosed?: IntFieldUpdateOperationsInput | number
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContributionDataUpsertWithWhereUniqueWithoutUserInput = {
    where: ContributionDataWhereUniqueInput
    update: XOR<ContributionDataUpdateWithoutUserInput, ContributionDataUncheckedUpdateWithoutUserInput>
    create: XOR<ContributionDataCreateWithoutUserInput, ContributionDataUncheckedCreateWithoutUserInput>
  }

  export type ContributionDataUpdateWithWhereUniqueWithoutUserInput = {
    where: ContributionDataWhereUniqueInput
    data: XOR<ContributionDataUpdateWithoutUserInput, ContributionDataUncheckedUpdateWithoutUserInput>
  }

  export type ContributionDataUpdateManyWithWhereWithoutUserInput = {
    where: ContributionDataScalarWhereInput
    data: XOR<ContributionDataUpdateManyMutationInput, ContributionDataUncheckedUpdateManyWithoutUserInput>
  }

  export type ContributionDataScalarWhereInput = {
    AND?: ContributionDataScalarWhereInput | ContributionDataScalarWhereInput[]
    OR?: ContributionDataScalarWhereInput[]
    NOT?: ContributionDataScalarWhereInput | ContributionDataScalarWhereInput[]
    id?: StringFilter<"ContributionData"> | string
    userId?: StringFilter<"ContributionData"> | string
    year?: IntFilter<"ContributionData"> | number
    total?: IntFilter<"ContributionData"> | number
    startRange?: DateTimeFilter<"ContributionData"> | Date | string
    endRange?: DateTimeFilter<"ContributionData"> | Date | string
  }

  export type TimelineEventUpsertWithWhereUniqueWithoutUserInput = {
    where: TimelineEventWhereUniqueInput
    update: XOR<TimelineEventUpdateWithoutUserInput, TimelineEventUncheckedUpdateWithoutUserInput>
    create: XOR<TimelineEventCreateWithoutUserInput, TimelineEventUncheckedCreateWithoutUserInput>
  }

  export type TimelineEventUpdateWithWhereUniqueWithoutUserInput = {
    where: TimelineEventWhereUniqueInput
    data: XOR<TimelineEventUpdateWithoutUserInput, TimelineEventUncheckedUpdateWithoutUserInput>
  }

  export type TimelineEventUpdateManyWithWhereWithoutUserInput = {
    where: TimelineEventScalarWhereInput
    data: XOR<TimelineEventUpdateManyMutationInput, TimelineEventUncheckedUpdateManyWithoutUserInput>
  }

  export type TimelineEventScalarWhereInput = {
    AND?: TimelineEventScalarWhereInput | TimelineEventScalarWhereInput[]
    OR?: TimelineEventScalarWhereInput[]
    NOT?: TimelineEventScalarWhereInput | TimelineEventScalarWhereInput[]
    id?: StringFilter<"TimelineEvent"> | string
    userId?: StringFilter<"TimelineEvent"> | string
    date?: DateTimeFilter<"TimelineEvent"> | Date | string
    type?: StringFilter<"TimelineEvent"> | string
    title?: StringFilter<"TimelineEvent"> | string
    subtitle?: StringNullableFilter<"TimelineEvent"> | string | null
    description?: StringNullableFilter<"TimelineEvent"> | string | null
    icon?: StringNullableFilter<"TimelineEvent"> | string | null
    color?: StringNullableFilter<"TimelineEvent"> | string | null
  }

  export type UserCreateWithoutSkillsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceCreateNestedManyWithoutUserInput
    educations?: EducationCreateNestedManyWithoutUserInput
    certifications?: CertificationCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaCreateNestedManyWithoutUserInput
    devStats?: DevStatsCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSkillsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceUncheckedCreateNestedManyWithoutUserInput
    educations?: EducationUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaUncheckedCreateNestedManyWithoutUserInput
    devStats?: DevStatsUncheckedCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataUncheckedCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSkillsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSkillsInput, UserUncheckedCreateWithoutSkillsInput>
  }

  export type ProjectCreateWithoutSkillsInput = {
    id?: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    features?: ProjectFeatureCreateNestedManyWithoutProjectInput
    techStack?: ProjectTechStackCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    learnings?: ProjectLearningCreateNestedManyWithoutProjectInput
    testimonials?: ProjectTestimonialCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSkillsInput = {
    id?: string
    userId: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: ProjectFeatureUncheckedCreateNestedManyWithoutProjectInput
    techStack?: ProjectTechStackUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    learnings?: ProjectLearningUncheckedCreateNestedManyWithoutProjectInput
    testimonials?: ProjectTestimonialUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSkillsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput>
  }

  export type UserUpsertWithoutSkillsInput = {
    update: XOR<UserUpdateWithoutSkillsInput, UserUncheckedUpdateWithoutSkillsInput>
    create: XOR<UserCreateWithoutSkillsInput, UserUncheckedCreateWithoutSkillsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSkillsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSkillsInput, UserUncheckedUpdateWithoutSkillsInput>
  }

  export type UserUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUpdateManyWithoutUserNestedInput
    educations?: EducationUpdateManyWithoutUserNestedInput
    certifications?: CertificationUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUncheckedUpdateManyWithoutUserNestedInput
    educations?: EducationUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUncheckedUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUncheckedUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUncheckedUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithWhereUniqueWithoutSkillsInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutSkillsInput, ProjectUncheckedUpdateWithoutSkillsInput>
    create: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutSkillsInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutSkillsInput, ProjectUncheckedUpdateWithoutSkillsInput>
  }

  export type ProjectUpdateManyWithWhereWithoutSkillsInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutSkillsInput>
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceCreateNestedManyWithoutUserInput
    educations?: EducationCreateNestedManyWithoutUserInput
    certifications?: CertificationCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaCreateNestedManyWithoutUserInput
    devStats?: DevStatsCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillUncheckedCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceUncheckedCreateNestedManyWithoutUserInput
    educations?: EducationUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaUncheckedCreateNestedManyWithoutUserInput
    devStats?: DevStatsUncheckedCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataUncheckedCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectFeatureCreateWithoutProjectInput = {
    id?: string
    feature: string
  }

  export type ProjectFeatureUncheckedCreateWithoutProjectInput = {
    id?: string
    feature: string
  }

  export type ProjectFeatureCreateOrConnectWithoutProjectInput = {
    where: ProjectFeatureWhereUniqueInput
    create: XOR<ProjectFeatureCreateWithoutProjectInput, ProjectFeatureUncheckedCreateWithoutProjectInput>
  }

  export type ProjectFeatureCreateManyProjectInputEnvelope = {
    data: ProjectFeatureCreateManyProjectInput | ProjectFeatureCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectTechStackCreateWithoutProjectInput = {
    id?: string
    tech: string
  }

  export type ProjectTechStackUncheckedCreateWithoutProjectInput = {
    id?: string
    tech: string
  }

  export type ProjectTechStackCreateOrConnectWithoutProjectInput = {
    where: ProjectTechStackWhereUniqueInput
    create: XOR<ProjectTechStackCreateWithoutProjectInput, ProjectTechStackUncheckedCreateWithoutProjectInput>
  }

  export type ProjectTechStackCreateManyProjectInputEnvelope = {
    data: ProjectTechStackCreateManyProjectInput | ProjectTechStackCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCollaboratorCreateWithoutProjectInput = {
    id?: string
    name: string
    username: string
  }

  export type ProjectCollaboratorUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    username: string
  }

  export type ProjectCollaboratorCreateOrConnectWithoutProjectInput = {
    where: ProjectCollaboratorWhereUniqueInput
    create: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput>
  }

  export type ProjectCollaboratorCreateManyProjectInputEnvelope = {
    data: ProjectCollaboratorCreateManyProjectInput | ProjectCollaboratorCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectLearningCreateWithoutProjectInput = {
    id?: string
    learning: string
  }

  export type ProjectLearningUncheckedCreateWithoutProjectInput = {
    id?: string
    learning: string
  }

  export type ProjectLearningCreateOrConnectWithoutProjectInput = {
    where: ProjectLearningWhereUniqueInput
    create: XOR<ProjectLearningCreateWithoutProjectInput, ProjectLearningUncheckedCreateWithoutProjectInput>
  }

  export type ProjectLearningCreateManyProjectInputEnvelope = {
    data: ProjectLearningCreateManyProjectInput | ProjectLearningCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectTestimonialCreateWithoutProjectInput = {
    id?: string
    testimonial: TestimonialCreateNestedOneWithoutProjectTestimonialsInput
  }

  export type ProjectTestimonialUncheckedCreateWithoutProjectInput = {
    id?: string
    testimonialId: string
  }

  export type ProjectTestimonialCreateOrConnectWithoutProjectInput = {
    where: ProjectTestimonialWhereUniqueInput
    create: XOR<ProjectTestimonialCreateWithoutProjectInput, ProjectTestimonialUncheckedCreateWithoutProjectInput>
  }

  export type ProjectTestimonialCreateManyProjectInputEnvelope = {
    data: ProjectTestimonialCreateManyProjectInput | ProjectTestimonialCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type SkillCreateWithoutProjectsInput = {
    id?: string
    name: string
    percentage: number
    color?: string | null
    icon?: string | null
    category?: string | null
    description?: string | null
    years?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSkillsInput
  }

  export type SkillUncheckedCreateWithoutProjectsInput = {
    id?: string
    userId: string
    name: string
    percentage: number
    color?: string | null
    icon?: string | null
    category?: string | null
    description?: string | null
    years?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillCreateOrConnectWithoutProjectsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput>
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUpdateManyWithoutUserNestedInput
    educations?: EducationUpdateManyWithoutUserNestedInput
    certifications?: CertificationUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUncheckedUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUncheckedUpdateManyWithoutUserNestedInput
    educations?: EducationUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUncheckedUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUncheckedUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUncheckedUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectFeatureUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectFeatureWhereUniqueInput
    update: XOR<ProjectFeatureUpdateWithoutProjectInput, ProjectFeatureUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectFeatureCreateWithoutProjectInput, ProjectFeatureUncheckedCreateWithoutProjectInput>
  }

  export type ProjectFeatureUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectFeatureWhereUniqueInput
    data: XOR<ProjectFeatureUpdateWithoutProjectInput, ProjectFeatureUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectFeatureUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectFeatureScalarWhereInput
    data: XOR<ProjectFeatureUpdateManyMutationInput, ProjectFeatureUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectFeatureScalarWhereInput = {
    AND?: ProjectFeatureScalarWhereInput | ProjectFeatureScalarWhereInput[]
    OR?: ProjectFeatureScalarWhereInput[]
    NOT?: ProjectFeatureScalarWhereInput | ProjectFeatureScalarWhereInput[]
    id?: StringFilter<"ProjectFeature"> | string
    projectId?: StringFilter<"ProjectFeature"> | string
    feature?: StringFilter<"ProjectFeature"> | string
  }

  export type ProjectTechStackUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectTechStackWhereUniqueInput
    update: XOR<ProjectTechStackUpdateWithoutProjectInput, ProjectTechStackUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectTechStackCreateWithoutProjectInput, ProjectTechStackUncheckedCreateWithoutProjectInput>
  }

  export type ProjectTechStackUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectTechStackWhereUniqueInput
    data: XOR<ProjectTechStackUpdateWithoutProjectInput, ProjectTechStackUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectTechStackUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectTechStackScalarWhereInput
    data: XOR<ProjectTechStackUpdateManyMutationInput, ProjectTechStackUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectTechStackScalarWhereInput = {
    AND?: ProjectTechStackScalarWhereInput | ProjectTechStackScalarWhereInput[]
    OR?: ProjectTechStackScalarWhereInput[]
    NOT?: ProjectTechStackScalarWhereInput | ProjectTechStackScalarWhereInput[]
    id?: StringFilter<"ProjectTechStack"> | string
    projectId?: StringFilter<"ProjectTechStack"> | string
    tech?: StringFilter<"ProjectTechStack"> | string
  }

  export type ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectCollaboratorWhereUniqueInput
    update: XOR<ProjectCollaboratorUpdateWithoutProjectInput, ProjectCollaboratorUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput>
  }

  export type ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectCollaboratorWhereUniqueInput
    data: XOR<ProjectCollaboratorUpdateWithoutProjectInput, ProjectCollaboratorUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectCollaboratorScalarWhereInput
    data: XOR<ProjectCollaboratorUpdateManyMutationInput, ProjectCollaboratorUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCollaboratorScalarWhereInput = {
    AND?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
    OR?: ProjectCollaboratorScalarWhereInput[]
    NOT?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
    id?: StringFilter<"ProjectCollaborator"> | string
    projectId?: StringFilter<"ProjectCollaborator"> | string
    name?: StringFilter<"ProjectCollaborator"> | string
    username?: StringFilter<"ProjectCollaborator"> | string
  }

  export type ProjectLearningUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectLearningWhereUniqueInput
    update: XOR<ProjectLearningUpdateWithoutProjectInput, ProjectLearningUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectLearningCreateWithoutProjectInput, ProjectLearningUncheckedCreateWithoutProjectInput>
  }

  export type ProjectLearningUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectLearningWhereUniqueInput
    data: XOR<ProjectLearningUpdateWithoutProjectInput, ProjectLearningUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectLearningUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectLearningScalarWhereInput
    data: XOR<ProjectLearningUpdateManyMutationInput, ProjectLearningUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectLearningScalarWhereInput = {
    AND?: ProjectLearningScalarWhereInput | ProjectLearningScalarWhereInput[]
    OR?: ProjectLearningScalarWhereInput[]
    NOT?: ProjectLearningScalarWhereInput | ProjectLearningScalarWhereInput[]
    id?: StringFilter<"ProjectLearning"> | string
    projectId?: StringFilter<"ProjectLearning"> | string
    learning?: StringFilter<"ProjectLearning"> | string
  }

  export type ProjectTestimonialUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectTestimonialWhereUniqueInput
    update: XOR<ProjectTestimonialUpdateWithoutProjectInput, ProjectTestimonialUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectTestimonialCreateWithoutProjectInput, ProjectTestimonialUncheckedCreateWithoutProjectInput>
  }

  export type ProjectTestimonialUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectTestimonialWhereUniqueInput
    data: XOR<ProjectTestimonialUpdateWithoutProjectInput, ProjectTestimonialUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectTestimonialUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectTestimonialScalarWhereInput
    data: XOR<ProjectTestimonialUpdateManyMutationInput, ProjectTestimonialUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectTestimonialScalarWhereInput = {
    AND?: ProjectTestimonialScalarWhereInput | ProjectTestimonialScalarWhereInput[]
    OR?: ProjectTestimonialScalarWhereInput[]
    NOT?: ProjectTestimonialScalarWhereInput | ProjectTestimonialScalarWhereInput[]
    id?: StringFilter<"ProjectTestimonial"> | string
    projectId?: StringFilter<"ProjectTestimonial"> | string
    testimonialId?: StringFilter<"ProjectTestimonial"> | string
  }

  export type SkillUpsertWithWhereUniqueWithoutProjectsInput = {
    where: SkillWhereUniqueInput
    update: XOR<SkillUpdateWithoutProjectsInput, SkillUncheckedUpdateWithoutProjectsInput>
    create: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput>
  }

  export type SkillUpdateWithWhereUniqueWithoutProjectsInput = {
    where: SkillWhereUniqueInput
    data: XOR<SkillUpdateWithoutProjectsInput, SkillUncheckedUpdateWithoutProjectsInput>
  }

  export type SkillUpdateManyWithWhereWithoutProjectsInput = {
    where: SkillScalarWhereInput
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyWithoutProjectsInput>
  }

  export type ProjectCreateWithoutFeaturesInput = {
    id?: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    techStack?: ProjectTechStackCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    learnings?: ProjectLearningCreateNestedManyWithoutProjectInput
    testimonials?: ProjectTestimonialCreateNestedManyWithoutProjectInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutFeaturesInput = {
    id?: string
    userId: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    techStack?: ProjectTechStackUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    learnings?: ProjectLearningUncheckedCreateNestedManyWithoutProjectInput
    testimonials?: ProjectTestimonialUncheckedCreateNestedManyWithoutProjectInput
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutFeaturesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutFeaturesInput, ProjectUncheckedCreateWithoutFeaturesInput>
  }

  export type ProjectUpsertWithoutFeaturesInput = {
    update: XOR<ProjectUpdateWithoutFeaturesInput, ProjectUncheckedUpdateWithoutFeaturesInput>
    create: XOR<ProjectCreateWithoutFeaturesInput, ProjectUncheckedCreateWithoutFeaturesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutFeaturesInput, ProjectUncheckedUpdateWithoutFeaturesInput>
  }

  export type ProjectUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    techStack?: ProjectTechStackUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    learnings?: ProjectLearningUpdateManyWithoutProjectNestedInput
    testimonials?: ProjectTestimonialUpdateManyWithoutProjectNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techStack?: ProjectTechStackUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    learnings?: ProjectLearningUncheckedUpdateManyWithoutProjectNestedInput
    testimonials?: ProjectTestimonialUncheckedUpdateManyWithoutProjectNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectCreateWithoutTechStackInput = {
    id?: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    features?: ProjectFeatureCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    learnings?: ProjectLearningCreateNestedManyWithoutProjectInput
    testimonials?: ProjectTestimonialCreateNestedManyWithoutProjectInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutTechStackInput = {
    id?: string
    userId: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: ProjectFeatureUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    learnings?: ProjectLearningUncheckedCreateNestedManyWithoutProjectInput
    testimonials?: ProjectTestimonialUncheckedCreateNestedManyWithoutProjectInput
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutTechStackInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTechStackInput, ProjectUncheckedCreateWithoutTechStackInput>
  }

  export type ProjectUpsertWithoutTechStackInput = {
    update: XOR<ProjectUpdateWithoutTechStackInput, ProjectUncheckedUpdateWithoutTechStackInput>
    create: XOR<ProjectCreateWithoutTechStackInput, ProjectUncheckedCreateWithoutTechStackInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTechStackInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTechStackInput, ProjectUncheckedUpdateWithoutTechStackInput>
  }

  export type ProjectUpdateWithoutTechStackInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    features?: ProjectFeatureUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    learnings?: ProjectLearningUpdateManyWithoutProjectNestedInput
    testimonials?: ProjectTestimonialUpdateManyWithoutProjectNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTechStackInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: ProjectFeatureUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    learnings?: ProjectLearningUncheckedUpdateManyWithoutProjectNestedInput
    testimonials?: ProjectTestimonialUncheckedUpdateManyWithoutProjectNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectCreateWithoutCollaboratorsInput = {
    id?: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    features?: ProjectFeatureCreateNestedManyWithoutProjectInput
    techStack?: ProjectTechStackCreateNestedManyWithoutProjectInput
    learnings?: ProjectLearningCreateNestedManyWithoutProjectInput
    testimonials?: ProjectTestimonialCreateNestedManyWithoutProjectInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutCollaboratorsInput = {
    id?: string
    userId: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: ProjectFeatureUncheckedCreateNestedManyWithoutProjectInput
    techStack?: ProjectTechStackUncheckedCreateNestedManyWithoutProjectInput
    learnings?: ProjectLearningUncheckedCreateNestedManyWithoutProjectInput
    testimonials?: ProjectTestimonialUncheckedCreateNestedManyWithoutProjectInput
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutCollaboratorsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCollaboratorsInput, ProjectUncheckedCreateWithoutCollaboratorsInput>
  }

  export type ProjectUpsertWithoutCollaboratorsInput = {
    update: XOR<ProjectUpdateWithoutCollaboratorsInput, ProjectUncheckedUpdateWithoutCollaboratorsInput>
    create: XOR<ProjectCreateWithoutCollaboratorsInput, ProjectUncheckedCreateWithoutCollaboratorsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCollaboratorsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCollaboratorsInput, ProjectUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type ProjectUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    features?: ProjectFeatureUpdateManyWithoutProjectNestedInput
    techStack?: ProjectTechStackUpdateManyWithoutProjectNestedInput
    learnings?: ProjectLearningUpdateManyWithoutProjectNestedInput
    testimonials?: ProjectTestimonialUpdateManyWithoutProjectNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: ProjectFeatureUncheckedUpdateManyWithoutProjectNestedInput
    techStack?: ProjectTechStackUncheckedUpdateManyWithoutProjectNestedInput
    learnings?: ProjectLearningUncheckedUpdateManyWithoutProjectNestedInput
    testimonials?: ProjectTestimonialUncheckedUpdateManyWithoutProjectNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectCreateWithoutLearningsInput = {
    id?: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    features?: ProjectFeatureCreateNestedManyWithoutProjectInput
    techStack?: ProjectTechStackCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    testimonials?: ProjectTestimonialCreateNestedManyWithoutProjectInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutLearningsInput = {
    id?: string
    userId: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: ProjectFeatureUncheckedCreateNestedManyWithoutProjectInput
    techStack?: ProjectTechStackUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    testimonials?: ProjectTestimonialUncheckedCreateNestedManyWithoutProjectInput
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutLearningsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLearningsInput, ProjectUncheckedCreateWithoutLearningsInput>
  }

  export type ProjectUpsertWithoutLearningsInput = {
    update: XOR<ProjectUpdateWithoutLearningsInput, ProjectUncheckedUpdateWithoutLearningsInput>
    create: XOR<ProjectCreateWithoutLearningsInput, ProjectUncheckedCreateWithoutLearningsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutLearningsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutLearningsInput, ProjectUncheckedUpdateWithoutLearningsInput>
  }

  export type ProjectUpdateWithoutLearningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    features?: ProjectFeatureUpdateManyWithoutProjectNestedInput
    techStack?: ProjectTechStackUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    testimonials?: ProjectTestimonialUpdateManyWithoutProjectNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLearningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: ProjectFeatureUncheckedUpdateManyWithoutProjectNestedInput
    techStack?: ProjectTechStackUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    testimonials?: ProjectTestimonialUncheckedUpdateManyWithoutProjectNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type UserCreateWithoutWorkExperiencesInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    educations?: EducationCreateNestedManyWithoutUserInput
    certifications?: CertificationCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaCreateNestedManyWithoutUserInput
    devStats?: DevStatsCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkExperiencesInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    educations?: EducationUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaUncheckedCreateNestedManyWithoutUserInput
    devStats?: DevStatsUncheckedCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataUncheckedCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkExperiencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkExperiencesInput, UserUncheckedCreateWithoutWorkExperiencesInput>
  }

  export type WorkResponsibilityCreateWithoutWorkExperienceInput = {
    id?: string
    responsibility: string
  }

  export type WorkResponsibilityUncheckedCreateWithoutWorkExperienceInput = {
    id?: string
    responsibility: string
  }

  export type WorkResponsibilityCreateOrConnectWithoutWorkExperienceInput = {
    where: WorkResponsibilityWhereUniqueInput
    create: XOR<WorkResponsibilityCreateWithoutWorkExperienceInput, WorkResponsibilityUncheckedCreateWithoutWorkExperienceInput>
  }

  export type WorkResponsibilityCreateManyWorkExperienceInputEnvelope = {
    data: WorkResponsibilityCreateManyWorkExperienceInput | WorkResponsibilityCreateManyWorkExperienceInput[]
    skipDuplicates?: boolean
  }

  export type WorkTechnologyCreateWithoutWorkExperienceInput = {
    id?: string
    technology: string
  }

  export type WorkTechnologyUncheckedCreateWithoutWorkExperienceInput = {
    id?: string
    technology: string
  }

  export type WorkTechnologyCreateOrConnectWithoutWorkExperienceInput = {
    where: WorkTechnologyWhereUniqueInput
    create: XOR<WorkTechnologyCreateWithoutWorkExperienceInput, WorkTechnologyUncheckedCreateWithoutWorkExperienceInput>
  }

  export type WorkTechnologyCreateManyWorkExperienceInputEnvelope = {
    data: WorkTechnologyCreateManyWorkExperienceInput | WorkTechnologyCreateManyWorkExperienceInput[]
    skipDuplicates?: boolean
  }

  export type WorkAchievementCreateWithoutWorkExperienceInput = {
    id?: string
    achievement: string
  }

  export type WorkAchievementUncheckedCreateWithoutWorkExperienceInput = {
    id?: string
    achievement: string
  }

  export type WorkAchievementCreateOrConnectWithoutWorkExperienceInput = {
    where: WorkAchievementWhereUniqueInput
    create: XOR<WorkAchievementCreateWithoutWorkExperienceInput, WorkAchievementUncheckedCreateWithoutWorkExperienceInput>
  }

  export type WorkAchievementCreateManyWorkExperienceInputEnvelope = {
    data: WorkAchievementCreateManyWorkExperienceInput | WorkAchievementCreateManyWorkExperienceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWorkExperiencesInput = {
    update: XOR<UserUpdateWithoutWorkExperiencesInput, UserUncheckedUpdateWithoutWorkExperiencesInput>
    create: XOR<UserCreateWithoutWorkExperiencesInput, UserUncheckedCreateWithoutWorkExperiencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkExperiencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkExperiencesInput, UserUncheckedUpdateWithoutWorkExperiencesInput>
  }

  export type UserUpdateWithoutWorkExperiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    educations?: EducationUpdateManyWithoutUserNestedInput
    certifications?: CertificationUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkExperiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    educations?: EducationUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUncheckedUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUncheckedUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUncheckedUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkResponsibilityUpsertWithWhereUniqueWithoutWorkExperienceInput = {
    where: WorkResponsibilityWhereUniqueInput
    update: XOR<WorkResponsibilityUpdateWithoutWorkExperienceInput, WorkResponsibilityUncheckedUpdateWithoutWorkExperienceInput>
    create: XOR<WorkResponsibilityCreateWithoutWorkExperienceInput, WorkResponsibilityUncheckedCreateWithoutWorkExperienceInput>
  }

  export type WorkResponsibilityUpdateWithWhereUniqueWithoutWorkExperienceInput = {
    where: WorkResponsibilityWhereUniqueInput
    data: XOR<WorkResponsibilityUpdateWithoutWorkExperienceInput, WorkResponsibilityUncheckedUpdateWithoutWorkExperienceInput>
  }

  export type WorkResponsibilityUpdateManyWithWhereWithoutWorkExperienceInput = {
    where: WorkResponsibilityScalarWhereInput
    data: XOR<WorkResponsibilityUpdateManyMutationInput, WorkResponsibilityUncheckedUpdateManyWithoutWorkExperienceInput>
  }

  export type WorkResponsibilityScalarWhereInput = {
    AND?: WorkResponsibilityScalarWhereInput | WorkResponsibilityScalarWhereInput[]
    OR?: WorkResponsibilityScalarWhereInput[]
    NOT?: WorkResponsibilityScalarWhereInput | WorkResponsibilityScalarWhereInput[]
    id?: StringFilter<"WorkResponsibility"> | string
    experienceId?: StringFilter<"WorkResponsibility"> | string
    responsibility?: StringFilter<"WorkResponsibility"> | string
  }

  export type WorkTechnologyUpsertWithWhereUniqueWithoutWorkExperienceInput = {
    where: WorkTechnologyWhereUniqueInput
    update: XOR<WorkTechnologyUpdateWithoutWorkExperienceInput, WorkTechnologyUncheckedUpdateWithoutWorkExperienceInput>
    create: XOR<WorkTechnologyCreateWithoutWorkExperienceInput, WorkTechnologyUncheckedCreateWithoutWorkExperienceInput>
  }

  export type WorkTechnologyUpdateWithWhereUniqueWithoutWorkExperienceInput = {
    where: WorkTechnologyWhereUniqueInput
    data: XOR<WorkTechnologyUpdateWithoutWorkExperienceInput, WorkTechnologyUncheckedUpdateWithoutWorkExperienceInput>
  }

  export type WorkTechnologyUpdateManyWithWhereWithoutWorkExperienceInput = {
    where: WorkTechnologyScalarWhereInput
    data: XOR<WorkTechnologyUpdateManyMutationInput, WorkTechnologyUncheckedUpdateManyWithoutWorkExperienceInput>
  }

  export type WorkTechnologyScalarWhereInput = {
    AND?: WorkTechnologyScalarWhereInput | WorkTechnologyScalarWhereInput[]
    OR?: WorkTechnologyScalarWhereInput[]
    NOT?: WorkTechnologyScalarWhereInput | WorkTechnologyScalarWhereInput[]
    id?: StringFilter<"WorkTechnology"> | string
    experienceId?: StringFilter<"WorkTechnology"> | string
    technology?: StringFilter<"WorkTechnology"> | string
  }

  export type WorkAchievementUpsertWithWhereUniqueWithoutWorkExperienceInput = {
    where: WorkAchievementWhereUniqueInput
    update: XOR<WorkAchievementUpdateWithoutWorkExperienceInput, WorkAchievementUncheckedUpdateWithoutWorkExperienceInput>
    create: XOR<WorkAchievementCreateWithoutWorkExperienceInput, WorkAchievementUncheckedCreateWithoutWorkExperienceInput>
  }

  export type WorkAchievementUpdateWithWhereUniqueWithoutWorkExperienceInput = {
    where: WorkAchievementWhereUniqueInput
    data: XOR<WorkAchievementUpdateWithoutWorkExperienceInput, WorkAchievementUncheckedUpdateWithoutWorkExperienceInput>
  }

  export type WorkAchievementUpdateManyWithWhereWithoutWorkExperienceInput = {
    where: WorkAchievementScalarWhereInput
    data: XOR<WorkAchievementUpdateManyMutationInput, WorkAchievementUncheckedUpdateManyWithoutWorkExperienceInput>
  }

  export type WorkAchievementScalarWhereInput = {
    AND?: WorkAchievementScalarWhereInput | WorkAchievementScalarWhereInput[]
    OR?: WorkAchievementScalarWhereInput[]
    NOT?: WorkAchievementScalarWhereInput | WorkAchievementScalarWhereInput[]
    id?: StringFilter<"WorkAchievement"> | string
    experienceId?: StringFilter<"WorkAchievement"> | string
    achievement?: StringFilter<"WorkAchievement"> | string
  }

  export type WorkExperienceCreateWithoutResponsibilitiesInput = {
    id?: string
    company: string
    position: string
    period: string
    description?: string | null
    location?: string | null
    type?: string | null
    logo?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWorkExperiencesInput
    technologies?: WorkTechnologyCreateNestedManyWithoutWorkExperienceInput
    achievements?: WorkAchievementCreateNestedManyWithoutWorkExperienceInput
  }

  export type WorkExperienceUncheckedCreateWithoutResponsibilitiesInput = {
    id?: string
    userId: string
    company: string
    position: string
    period: string
    description?: string | null
    location?: string | null
    type?: string | null
    logo?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    technologies?: WorkTechnologyUncheckedCreateNestedManyWithoutWorkExperienceInput
    achievements?: WorkAchievementUncheckedCreateNestedManyWithoutWorkExperienceInput
  }

  export type WorkExperienceCreateOrConnectWithoutResponsibilitiesInput = {
    where: WorkExperienceWhereUniqueInput
    create: XOR<WorkExperienceCreateWithoutResponsibilitiesInput, WorkExperienceUncheckedCreateWithoutResponsibilitiesInput>
  }

  export type WorkExperienceUpsertWithoutResponsibilitiesInput = {
    update: XOR<WorkExperienceUpdateWithoutResponsibilitiesInput, WorkExperienceUncheckedUpdateWithoutResponsibilitiesInput>
    create: XOR<WorkExperienceCreateWithoutResponsibilitiesInput, WorkExperienceUncheckedCreateWithoutResponsibilitiesInput>
    where?: WorkExperienceWhereInput
  }

  export type WorkExperienceUpdateToOneWithWhereWithoutResponsibilitiesInput = {
    where?: WorkExperienceWhereInput
    data: XOR<WorkExperienceUpdateWithoutResponsibilitiesInput, WorkExperienceUncheckedUpdateWithoutResponsibilitiesInput>
  }

  export type WorkExperienceUpdateWithoutResponsibilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkExperiencesNestedInput
    technologies?: WorkTechnologyUpdateManyWithoutWorkExperienceNestedInput
    achievements?: WorkAchievementUpdateManyWithoutWorkExperienceNestedInput
  }

  export type WorkExperienceUncheckedUpdateWithoutResponsibilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    technologies?: WorkTechnologyUncheckedUpdateManyWithoutWorkExperienceNestedInput
    achievements?: WorkAchievementUncheckedUpdateManyWithoutWorkExperienceNestedInput
  }

  export type WorkExperienceCreateWithoutTechnologiesInput = {
    id?: string
    company: string
    position: string
    period: string
    description?: string | null
    location?: string | null
    type?: string | null
    logo?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWorkExperiencesInput
    responsibilities?: WorkResponsibilityCreateNestedManyWithoutWorkExperienceInput
    achievements?: WorkAchievementCreateNestedManyWithoutWorkExperienceInput
  }

  export type WorkExperienceUncheckedCreateWithoutTechnologiesInput = {
    id?: string
    userId: string
    company: string
    position: string
    period: string
    description?: string | null
    location?: string | null
    type?: string | null
    logo?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibilities?: WorkResponsibilityUncheckedCreateNestedManyWithoutWorkExperienceInput
    achievements?: WorkAchievementUncheckedCreateNestedManyWithoutWorkExperienceInput
  }

  export type WorkExperienceCreateOrConnectWithoutTechnologiesInput = {
    where: WorkExperienceWhereUniqueInput
    create: XOR<WorkExperienceCreateWithoutTechnologiesInput, WorkExperienceUncheckedCreateWithoutTechnologiesInput>
  }

  export type WorkExperienceUpsertWithoutTechnologiesInput = {
    update: XOR<WorkExperienceUpdateWithoutTechnologiesInput, WorkExperienceUncheckedUpdateWithoutTechnologiesInput>
    create: XOR<WorkExperienceCreateWithoutTechnologiesInput, WorkExperienceUncheckedCreateWithoutTechnologiesInput>
    where?: WorkExperienceWhereInput
  }

  export type WorkExperienceUpdateToOneWithWhereWithoutTechnologiesInput = {
    where?: WorkExperienceWhereInput
    data: XOR<WorkExperienceUpdateWithoutTechnologiesInput, WorkExperienceUncheckedUpdateWithoutTechnologiesInput>
  }

  export type WorkExperienceUpdateWithoutTechnologiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkExperiencesNestedInput
    responsibilities?: WorkResponsibilityUpdateManyWithoutWorkExperienceNestedInput
    achievements?: WorkAchievementUpdateManyWithoutWorkExperienceNestedInput
  }

  export type WorkExperienceUncheckedUpdateWithoutTechnologiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibilities?: WorkResponsibilityUncheckedUpdateManyWithoutWorkExperienceNestedInput
    achievements?: WorkAchievementUncheckedUpdateManyWithoutWorkExperienceNestedInput
  }

  export type WorkExperienceCreateWithoutAchievementsInput = {
    id?: string
    company: string
    position: string
    period: string
    description?: string | null
    location?: string | null
    type?: string | null
    logo?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWorkExperiencesInput
    responsibilities?: WorkResponsibilityCreateNestedManyWithoutWorkExperienceInput
    technologies?: WorkTechnologyCreateNestedManyWithoutWorkExperienceInput
  }

  export type WorkExperienceUncheckedCreateWithoutAchievementsInput = {
    id?: string
    userId: string
    company: string
    position: string
    period: string
    description?: string | null
    location?: string | null
    type?: string | null
    logo?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibilities?: WorkResponsibilityUncheckedCreateNestedManyWithoutWorkExperienceInput
    technologies?: WorkTechnologyUncheckedCreateNestedManyWithoutWorkExperienceInput
  }

  export type WorkExperienceCreateOrConnectWithoutAchievementsInput = {
    where: WorkExperienceWhereUniqueInput
    create: XOR<WorkExperienceCreateWithoutAchievementsInput, WorkExperienceUncheckedCreateWithoutAchievementsInput>
  }

  export type WorkExperienceUpsertWithoutAchievementsInput = {
    update: XOR<WorkExperienceUpdateWithoutAchievementsInput, WorkExperienceUncheckedUpdateWithoutAchievementsInput>
    create: XOR<WorkExperienceCreateWithoutAchievementsInput, WorkExperienceUncheckedCreateWithoutAchievementsInput>
    where?: WorkExperienceWhereInput
  }

  export type WorkExperienceUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: WorkExperienceWhereInput
    data: XOR<WorkExperienceUpdateWithoutAchievementsInput, WorkExperienceUncheckedUpdateWithoutAchievementsInput>
  }

  export type WorkExperienceUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkExperiencesNestedInput
    responsibilities?: WorkResponsibilityUpdateManyWithoutWorkExperienceNestedInput
    technologies?: WorkTechnologyUpdateManyWithoutWorkExperienceNestedInput
  }

  export type WorkExperienceUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibilities?: WorkResponsibilityUncheckedUpdateManyWithoutWorkExperienceNestedInput
    technologies?: WorkTechnologyUncheckedUpdateManyWithoutWorkExperienceNestedInput
  }

  export type UserCreateWithoutEducationsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceCreateNestedManyWithoutUserInput
    certifications?: CertificationCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaCreateNestedManyWithoutUserInput
    devStats?: DevStatsCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEducationsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaUncheckedCreateNestedManyWithoutUserInput
    devStats?: DevStatsUncheckedCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataUncheckedCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEducationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEducationsInput, UserUncheckedCreateWithoutEducationsInput>
  }

  export type EducationAchievementCreateWithoutEducationInput = {
    id?: string
    achievement: string
  }

  export type EducationAchievementUncheckedCreateWithoutEducationInput = {
    id?: string
    achievement: string
  }

  export type EducationAchievementCreateOrConnectWithoutEducationInput = {
    where: EducationAchievementWhereUniqueInput
    create: XOR<EducationAchievementCreateWithoutEducationInput, EducationAchievementUncheckedCreateWithoutEducationInput>
  }

  export type EducationAchievementCreateManyEducationInputEnvelope = {
    data: EducationAchievementCreateManyEducationInput | EducationAchievementCreateManyEducationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEducationsInput = {
    update: XOR<UserUpdateWithoutEducationsInput, UserUncheckedUpdateWithoutEducationsInput>
    create: XOR<UserCreateWithoutEducationsInput, UserUncheckedCreateWithoutEducationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEducationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEducationsInput, UserUncheckedUpdateWithoutEducationsInput>
  }

  export type UserUpdateWithoutEducationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUpdateManyWithoutUserNestedInput
    certifications?: CertificationUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEducationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUncheckedUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUncheckedUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUncheckedUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EducationAchievementUpsertWithWhereUniqueWithoutEducationInput = {
    where: EducationAchievementWhereUniqueInput
    update: XOR<EducationAchievementUpdateWithoutEducationInput, EducationAchievementUncheckedUpdateWithoutEducationInput>
    create: XOR<EducationAchievementCreateWithoutEducationInput, EducationAchievementUncheckedCreateWithoutEducationInput>
  }

  export type EducationAchievementUpdateWithWhereUniqueWithoutEducationInput = {
    where: EducationAchievementWhereUniqueInput
    data: XOR<EducationAchievementUpdateWithoutEducationInput, EducationAchievementUncheckedUpdateWithoutEducationInput>
  }

  export type EducationAchievementUpdateManyWithWhereWithoutEducationInput = {
    where: EducationAchievementScalarWhereInput
    data: XOR<EducationAchievementUpdateManyMutationInput, EducationAchievementUncheckedUpdateManyWithoutEducationInput>
  }

  export type EducationAchievementScalarWhereInput = {
    AND?: EducationAchievementScalarWhereInput | EducationAchievementScalarWhereInput[]
    OR?: EducationAchievementScalarWhereInput[]
    NOT?: EducationAchievementScalarWhereInput | EducationAchievementScalarWhereInput[]
    id?: StringFilter<"EducationAchievement"> | string
    educationId?: StringFilter<"EducationAchievement"> | string
    achievement?: StringFilter<"EducationAchievement"> | string
  }

  export type EducationCreateWithoutAchievementsInput = {
    id?: string
    institution: string
    degree: string
    field: string
    period: string
    description?: string | null
    gpa?: string | null
    location?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEducationsInput
  }

  export type EducationUncheckedCreateWithoutAchievementsInput = {
    id?: string
    userId: string
    institution: string
    degree: string
    field: string
    period: string
    description?: string | null
    gpa?: string | null
    location?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EducationCreateOrConnectWithoutAchievementsInput = {
    where: EducationWhereUniqueInput
    create: XOR<EducationCreateWithoutAchievementsInput, EducationUncheckedCreateWithoutAchievementsInput>
  }

  export type EducationUpsertWithoutAchievementsInput = {
    update: XOR<EducationUpdateWithoutAchievementsInput, EducationUncheckedUpdateWithoutAchievementsInput>
    create: XOR<EducationCreateWithoutAchievementsInput, EducationUncheckedCreateWithoutAchievementsInput>
    where?: EducationWhereInput
  }

  export type EducationUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: EducationWhereInput
    data: XOR<EducationUpdateWithoutAchievementsInput, EducationUncheckedUpdateWithoutAchievementsInput>
  }

  export type EducationUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEducationsNestedInput
  }

  export type EducationUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutCertificationsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceCreateNestedManyWithoutUserInput
    educations?: EducationCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaCreateNestedManyWithoutUserInput
    devStats?: DevStatsCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCertificationsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceUncheckedCreateNestedManyWithoutUserInput
    educations?: EducationUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaUncheckedCreateNestedManyWithoutUserInput
    devStats?: DevStatsUncheckedCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataUncheckedCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCertificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCertificationsInput, UserUncheckedCreateWithoutCertificationsInput>
  }

  export type CertificationSkillCreateWithoutCertificationInput = {
    id?: string
    skill: string
  }

  export type CertificationSkillUncheckedCreateWithoutCertificationInput = {
    id?: string
    skill: string
  }

  export type CertificationSkillCreateOrConnectWithoutCertificationInput = {
    where: CertificationSkillWhereUniqueInput
    create: XOR<CertificationSkillCreateWithoutCertificationInput, CertificationSkillUncheckedCreateWithoutCertificationInput>
  }

  export type CertificationSkillCreateManyCertificationInputEnvelope = {
    data: CertificationSkillCreateManyCertificationInput | CertificationSkillCreateManyCertificationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCertificationsInput = {
    update: XOR<UserUpdateWithoutCertificationsInput, UserUncheckedUpdateWithoutCertificationsInput>
    create: XOR<UserCreateWithoutCertificationsInput, UserUncheckedCreateWithoutCertificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCertificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCertificationsInput, UserUncheckedUpdateWithoutCertificationsInput>
  }

  export type UserUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUpdateManyWithoutUserNestedInput
    educations?: EducationUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUncheckedUpdateManyWithoutUserNestedInput
    educations?: EducationUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUncheckedUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUncheckedUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUncheckedUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CertificationSkillUpsertWithWhereUniqueWithoutCertificationInput = {
    where: CertificationSkillWhereUniqueInput
    update: XOR<CertificationSkillUpdateWithoutCertificationInput, CertificationSkillUncheckedUpdateWithoutCertificationInput>
    create: XOR<CertificationSkillCreateWithoutCertificationInput, CertificationSkillUncheckedCreateWithoutCertificationInput>
  }

  export type CertificationSkillUpdateWithWhereUniqueWithoutCertificationInput = {
    where: CertificationSkillWhereUniqueInput
    data: XOR<CertificationSkillUpdateWithoutCertificationInput, CertificationSkillUncheckedUpdateWithoutCertificationInput>
  }

  export type CertificationSkillUpdateManyWithWhereWithoutCertificationInput = {
    where: CertificationSkillScalarWhereInput
    data: XOR<CertificationSkillUpdateManyMutationInput, CertificationSkillUncheckedUpdateManyWithoutCertificationInput>
  }

  export type CertificationSkillScalarWhereInput = {
    AND?: CertificationSkillScalarWhereInput | CertificationSkillScalarWhereInput[]
    OR?: CertificationSkillScalarWhereInput[]
    NOT?: CertificationSkillScalarWhereInput | CertificationSkillScalarWhereInput[]
    id?: StringFilter<"CertificationSkill"> | string
    certificationId?: StringFilter<"CertificationSkill"> | string
    skill?: StringFilter<"CertificationSkill"> | string
  }

  export type CertificationCreateWithoutSkillsInput = {
    id?: string
    name: string
    issuer: string
    date: Date | string
    icon?: string | null
    credentialId?: string | null
    expiry?: Date | string | null
    description?: string | null
    verificationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCertificationsInput
  }

  export type CertificationUncheckedCreateWithoutSkillsInput = {
    id?: string
    userId: string
    name: string
    issuer: string
    date: Date | string
    icon?: string | null
    credentialId?: string | null
    expiry?: Date | string | null
    description?: string | null
    verificationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationCreateOrConnectWithoutSkillsInput = {
    where: CertificationWhereUniqueInput
    create: XOR<CertificationCreateWithoutSkillsInput, CertificationUncheckedCreateWithoutSkillsInput>
  }

  export type CertificationUpsertWithoutSkillsInput = {
    update: XOR<CertificationUpdateWithoutSkillsInput, CertificationUncheckedUpdateWithoutSkillsInput>
    create: XOR<CertificationCreateWithoutSkillsInput, CertificationUncheckedCreateWithoutSkillsInput>
    where?: CertificationWhereInput
  }

  export type CertificationUpdateToOneWithWhereWithoutSkillsInput = {
    where?: CertificationWhereInput
    data: XOR<CertificationUpdateWithoutSkillsInput, CertificationUncheckedUpdateWithoutSkillsInput>
  }

  export type CertificationUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type CertificationUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceCreateNestedManyWithoutUserInput
    educations?: EducationCreateNestedManyWithoutUserInput
    certifications?: CertificationCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaCreateNestedManyWithoutUserInput
    devStats?: DevStatsCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceUncheckedCreateNestedManyWithoutUserInput
    educations?: EducationUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaUncheckedCreateNestedManyWithoutUserInput
    devStats?: DevStatsUncheckedCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataUncheckedCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUpdateManyWithoutUserNestedInput
    educations?: EducationUpdateManyWithoutUserNestedInput
    certifications?: CertificationUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUncheckedUpdateManyWithoutUserNestedInput
    educations?: EducationUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUncheckedUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUncheckedUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUncheckedUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBlogPostsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceCreateNestedManyWithoutUserInput
    educations?: EducationCreateNestedManyWithoutUserInput
    certifications?: CertificationCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaCreateNestedManyWithoutUserInput
    devStats?: DevStatsCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogPostsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceUncheckedCreateNestedManyWithoutUserInput
    educations?: EducationUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaUncheckedCreateNestedManyWithoutUserInput
    devStats?: DevStatsUncheckedCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataUncheckedCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
  }

  export type BlogTagCreateWithoutBlogPostInput = {
    id?: string
    tag: string
  }

  export type BlogTagUncheckedCreateWithoutBlogPostInput = {
    id?: string
    tag: string
  }

  export type BlogTagCreateOrConnectWithoutBlogPostInput = {
    where: BlogTagWhereUniqueInput
    create: XOR<BlogTagCreateWithoutBlogPostInput, BlogTagUncheckedCreateWithoutBlogPostInput>
  }

  export type BlogTagCreateManyBlogPostInputEnvelope = {
    data: BlogTagCreateManyBlogPostInput | BlogTagCreateManyBlogPostInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBlogPostsInput = {
    update: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type UserUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUpdateManyWithoutUserNestedInput
    educations?: EducationUpdateManyWithoutUserNestedInput
    certifications?: CertificationUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUncheckedUpdateManyWithoutUserNestedInput
    educations?: EducationUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUncheckedUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUncheckedUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUncheckedUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogTagUpsertWithWhereUniqueWithoutBlogPostInput = {
    where: BlogTagWhereUniqueInput
    update: XOR<BlogTagUpdateWithoutBlogPostInput, BlogTagUncheckedUpdateWithoutBlogPostInput>
    create: XOR<BlogTagCreateWithoutBlogPostInput, BlogTagUncheckedCreateWithoutBlogPostInput>
  }

  export type BlogTagUpdateWithWhereUniqueWithoutBlogPostInput = {
    where: BlogTagWhereUniqueInput
    data: XOR<BlogTagUpdateWithoutBlogPostInput, BlogTagUncheckedUpdateWithoutBlogPostInput>
  }

  export type BlogTagUpdateManyWithWhereWithoutBlogPostInput = {
    where: BlogTagScalarWhereInput
    data: XOR<BlogTagUpdateManyMutationInput, BlogTagUncheckedUpdateManyWithoutBlogPostInput>
  }

  export type BlogTagScalarWhereInput = {
    AND?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
    OR?: BlogTagScalarWhereInput[]
    NOT?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
    id?: StringFilter<"BlogTag"> | string
    blogId?: StringFilter<"BlogTag"> | string
    tag?: StringFilter<"BlogTag"> | string
  }

  export type BlogPostCreateWithoutTagsInput = {
    id?: string
    slug: string
    title: string
    excerpt: string
    content: string
    date: Date | string
    readTime: number
    image?: string | null
    likes?: number
    comments?: number
    shares?: number
    views?: number
    category: string
    author: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBlogPostsInput
  }

  export type BlogPostUncheckedCreateWithoutTagsInput = {
    id?: string
    userId: string
    slug: string
    title: string
    excerpt: string
    content: string
    date: Date | string
    readTime: number
    image?: string | null
    likes?: number
    comments?: number
    shares?: number
    views?: number
    category: string
    author: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostCreateOrConnectWithoutTagsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
  }

  export type BlogPostUpsertWithoutTagsInput = {
    update: XOR<BlogPostUpdateWithoutTagsInput, BlogPostUncheckedUpdateWithoutTagsInput>
    create: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutTagsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutTagsInput, BlogPostUncheckedUpdateWithoutTagsInput>
  }

  export type BlogPostUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutTestimonialsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceCreateNestedManyWithoutUserInput
    educations?: EducationCreateNestedManyWithoutUserInput
    certifications?: CertificationCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaCreateNestedManyWithoutUserInput
    devStats?: DevStatsCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTestimonialsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceUncheckedCreateNestedManyWithoutUserInput
    educations?: EducationUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaUncheckedCreateNestedManyWithoutUserInput
    devStats?: DevStatsUncheckedCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataUncheckedCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTestimonialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestimonialsInput, UserUncheckedCreateWithoutTestimonialsInput>
  }

  export type ProjectTestimonialCreateWithoutTestimonialInput = {
    id?: string
    project: ProjectCreateNestedOneWithoutTestimonialsInput
  }

  export type ProjectTestimonialUncheckedCreateWithoutTestimonialInput = {
    id?: string
    projectId: string
  }

  export type ProjectTestimonialCreateOrConnectWithoutTestimonialInput = {
    where: ProjectTestimonialWhereUniqueInput
    create: XOR<ProjectTestimonialCreateWithoutTestimonialInput, ProjectTestimonialUncheckedCreateWithoutTestimonialInput>
  }

  export type ProjectTestimonialCreateManyTestimonialInputEnvelope = {
    data: ProjectTestimonialCreateManyTestimonialInput | ProjectTestimonialCreateManyTestimonialInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTestimonialsInput = {
    update: XOR<UserUpdateWithoutTestimonialsInput, UserUncheckedUpdateWithoutTestimonialsInput>
    create: XOR<UserCreateWithoutTestimonialsInput, UserUncheckedCreateWithoutTestimonialsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestimonialsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestimonialsInput, UserUncheckedUpdateWithoutTestimonialsInput>
  }

  export type UserUpdateWithoutTestimonialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUpdateManyWithoutUserNestedInput
    educations?: EducationUpdateManyWithoutUserNestedInput
    certifications?: CertificationUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTestimonialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUncheckedUpdateManyWithoutUserNestedInput
    educations?: EducationUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUncheckedUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUncheckedUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUncheckedUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectTestimonialUpsertWithWhereUniqueWithoutTestimonialInput = {
    where: ProjectTestimonialWhereUniqueInput
    update: XOR<ProjectTestimonialUpdateWithoutTestimonialInput, ProjectTestimonialUncheckedUpdateWithoutTestimonialInput>
    create: XOR<ProjectTestimonialCreateWithoutTestimonialInput, ProjectTestimonialUncheckedCreateWithoutTestimonialInput>
  }

  export type ProjectTestimonialUpdateWithWhereUniqueWithoutTestimonialInput = {
    where: ProjectTestimonialWhereUniqueInput
    data: XOR<ProjectTestimonialUpdateWithoutTestimonialInput, ProjectTestimonialUncheckedUpdateWithoutTestimonialInput>
  }

  export type ProjectTestimonialUpdateManyWithWhereWithoutTestimonialInput = {
    where: ProjectTestimonialScalarWhereInput
    data: XOR<ProjectTestimonialUpdateManyMutationInput, ProjectTestimonialUncheckedUpdateManyWithoutTestimonialInput>
  }

  export type UserCreateWithoutContactsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceCreateNestedManyWithoutUserInput
    educations?: EducationCreateNestedManyWithoutUserInput
    certifications?: CertificationCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaCreateNestedManyWithoutUserInput
    devStats?: DevStatsCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceUncheckedCreateNestedManyWithoutUserInput
    educations?: EducationUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaUncheckedCreateNestedManyWithoutUserInput
    devStats?: DevStatsUncheckedCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataUncheckedCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
  }

  export type UserUpsertWithoutContactsInput = {
    update: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
  }

  export type UserUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUpdateManyWithoutUserNestedInput
    educations?: EducationUpdateManyWithoutUserNestedInput
    certifications?: CertificationUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUncheckedUpdateManyWithoutUserNestedInput
    educations?: EducationUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUncheckedUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUncheckedUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUncheckedUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSocialMediaInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceCreateNestedManyWithoutUserInput
    educations?: EducationCreateNestedManyWithoutUserInput
    certifications?: CertificationCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    devStats?: DevStatsCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSocialMediaInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceUncheckedCreateNestedManyWithoutUserInput
    educations?: EducationUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    devStats?: DevStatsUncheckedCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataUncheckedCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSocialMediaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSocialMediaInput, UserUncheckedCreateWithoutSocialMediaInput>
  }

  export type UserUpsertWithoutSocialMediaInput = {
    update: XOR<UserUpdateWithoutSocialMediaInput, UserUncheckedUpdateWithoutSocialMediaInput>
    create: XOR<UserCreateWithoutSocialMediaInput, UserUncheckedCreateWithoutSocialMediaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSocialMediaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSocialMediaInput, UserUncheckedUpdateWithoutSocialMediaInput>
  }

  export type UserUpdateWithoutSocialMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUpdateManyWithoutUserNestedInput
    educations?: EducationUpdateManyWithoutUserNestedInput
    certifications?: CertificationUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSocialMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUncheckedUpdateManyWithoutUserNestedInput
    educations?: EducationUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUncheckedUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUncheckedUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDevStatsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceCreateNestedManyWithoutUserInput
    educations?: EducationCreateNestedManyWithoutUserInput
    certifications?: CertificationCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaCreateNestedManyWithoutUserInput
    contributionData?: ContributionDataCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDevStatsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceUncheckedCreateNestedManyWithoutUserInput
    educations?: EducationUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaUncheckedCreateNestedManyWithoutUserInput
    contributionData?: ContributionDataUncheckedCreateNestedManyWithoutUserInput
    timelineEvents?: TimelineEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDevStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDevStatsInput, UserUncheckedCreateWithoutDevStatsInput>
  }

  export type UserUpsertWithoutDevStatsInput = {
    update: XOR<UserUpdateWithoutDevStatsInput, UserUncheckedUpdateWithoutDevStatsInput>
    create: XOR<UserCreateWithoutDevStatsInput, UserUncheckedCreateWithoutDevStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDevStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDevStatsInput, UserUncheckedUpdateWithoutDevStatsInput>
  }

  export type UserUpdateWithoutDevStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUpdateManyWithoutUserNestedInput
    educations?: EducationUpdateManyWithoutUserNestedInput
    certifications?: CertificationUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUpdateManyWithoutUserNestedInput
    contributionData?: ContributionDataUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDevStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUncheckedUpdateManyWithoutUserNestedInput
    educations?: EducationUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUncheckedUpdateManyWithoutUserNestedInput
    contributionData?: ContributionDataUncheckedUpdateManyWithoutUserNestedInput
    timelineEvents?: TimelineEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutContributionDataInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceCreateNestedManyWithoutUserInput
    educations?: EducationCreateNestedManyWithoutUserInput
    certifications?: CertificationCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaCreateNestedManyWithoutUserInput
    devStats?: DevStatsCreateNestedOneWithoutUserInput
    timelineEvents?: TimelineEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContributionDataInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceUncheckedCreateNestedManyWithoutUserInput
    educations?: EducationUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaUncheckedCreateNestedManyWithoutUserInput
    devStats?: DevStatsUncheckedCreateNestedOneWithoutUserInput
    timelineEvents?: TimelineEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContributionDataInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContributionDataInput, UserUncheckedCreateWithoutContributionDataInput>
  }

  export type ContributionDayCreateWithoutContributionDataInput = {
    id?: string
    date: Date | string
    count: number
    level: number
  }

  export type ContributionDayUncheckedCreateWithoutContributionDataInput = {
    id?: string
    date: Date | string
    count: number
    level: number
  }

  export type ContributionDayCreateOrConnectWithoutContributionDataInput = {
    where: ContributionDayWhereUniqueInput
    create: XOR<ContributionDayCreateWithoutContributionDataInput, ContributionDayUncheckedCreateWithoutContributionDataInput>
  }

  export type ContributionDayCreateManyContributionDataInputEnvelope = {
    data: ContributionDayCreateManyContributionDataInput | ContributionDayCreateManyContributionDataInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutContributionDataInput = {
    update: XOR<UserUpdateWithoutContributionDataInput, UserUncheckedUpdateWithoutContributionDataInput>
    create: XOR<UserCreateWithoutContributionDataInput, UserUncheckedCreateWithoutContributionDataInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContributionDataInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContributionDataInput, UserUncheckedUpdateWithoutContributionDataInput>
  }

  export type UserUpdateWithoutContributionDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUpdateManyWithoutUserNestedInput
    educations?: EducationUpdateManyWithoutUserNestedInput
    certifications?: CertificationUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUpdateOneWithoutUserNestedInput
    timelineEvents?: TimelineEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContributionDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUncheckedUpdateManyWithoutUserNestedInput
    educations?: EducationUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUncheckedUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUncheckedUpdateOneWithoutUserNestedInput
    timelineEvents?: TimelineEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContributionDayUpsertWithWhereUniqueWithoutContributionDataInput = {
    where: ContributionDayWhereUniqueInput
    update: XOR<ContributionDayUpdateWithoutContributionDataInput, ContributionDayUncheckedUpdateWithoutContributionDataInput>
    create: XOR<ContributionDayCreateWithoutContributionDataInput, ContributionDayUncheckedCreateWithoutContributionDataInput>
  }

  export type ContributionDayUpdateWithWhereUniqueWithoutContributionDataInput = {
    where: ContributionDayWhereUniqueInput
    data: XOR<ContributionDayUpdateWithoutContributionDataInput, ContributionDayUncheckedUpdateWithoutContributionDataInput>
  }

  export type ContributionDayUpdateManyWithWhereWithoutContributionDataInput = {
    where: ContributionDayScalarWhereInput
    data: XOR<ContributionDayUpdateManyMutationInput, ContributionDayUncheckedUpdateManyWithoutContributionDataInput>
  }

  export type ContributionDayScalarWhereInput = {
    AND?: ContributionDayScalarWhereInput | ContributionDayScalarWhereInput[]
    OR?: ContributionDayScalarWhereInput[]
    NOT?: ContributionDayScalarWhereInput | ContributionDayScalarWhereInput[]
    id?: StringFilter<"ContributionDay"> | string
    contributionDataId?: StringFilter<"ContributionDay"> | string
    date?: DateTimeFilter<"ContributionDay"> | Date | string
    count?: IntFilter<"ContributionDay"> | number
    level?: IntFilter<"ContributionDay"> | number
  }

  export type ContributionDataCreateWithoutDaysInput = {
    id?: string
    year: number
    total: number
    startRange: Date | string
    endRange: Date | string
    user: UserCreateNestedOneWithoutContributionDataInput
  }

  export type ContributionDataUncheckedCreateWithoutDaysInput = {
    id?: string
    userId: string
    year: number
    total: number
    startRange: Date | string
    endRange: Date | string
  }

  export type ContributionDataCreateOrConnectWithoutDaysInput = {
    where: ContributionDataWhereUniqueInput
    create: XOR<ContributionDataCreateWithoutDaysInput, ContributionDataUncheckedCreateWithoutDaysInput>
  }

  export type ContributionDataUpsertWithoutDaysInput = {
    update: XOR<ContributionDataUpdateWithoutDaysInput, ContributionDataUncheckedUpdateWithoutDaysInput>
    create: XOR<ContributionDataCreateWithoutDaysInput, ContributionDataUncheckedCreateWithoutDaysInput>
    where?: ContributionDataWhereInput
  }

  export type ContributionDataUpdateToOneWithWhereWithoutDaysInput = {
    where?: ContributionDataWhereInput
    data: XOR<ContributionDataUpdateWithoutDaysInput, ContributionDataUncheckedUpdateWithoutDaysInput>
  }

  export type ContributionDataUpdateWithoutDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    startRange?: DateTimeFieldUpdateOperationsInput | Date | string
    endRange?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContributionDataNestedInput
  }

  export type ContributionDataUncheckedUpdateWithoutDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    startRange?: DateTimeFieldUpdateOperationsInput | Date | string
    endRange?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutTimelineEventsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceCreateNestedManyWithoutUserInput
    educations?: EducationCreateNestedManyWithoutUserInput
    certifications?: CertificationCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaCreateNestedManyWithoutUserInput
    devStats?: DevStatsCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTimelineEventsInput = {
    id?: string
    name: string
    username: string
    email: string
    phone?: string | null
    location?: string | null
    bio?: string | null
    website?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    workExperiences?: WorkExperienceUncheckedCreateNestedManyWithoutUserInput
    educations?: EducationUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    socialMedia?: SocialMediaUncheckedCreateNestedManyWithoutUserInput
    devStats?: DevStatsUncheckedCreateNestedOneWithoutUserInput
    contributionData?: ContributionDataUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTimelineEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTimelineEventsInput, UserUncheckedCreateWithoutTimelineEventsInput>
  }

  export type UserUpsertWithoutTimelineEventsInput = {
    update: XOR<UserUpdateWithoutTimelineEventsInput, UserUncheckedUpdateWithoutTimelineEventsInput>
    create: XOR<UserCreateWithoutTimelineEventsInput, UserUncheckedCreateWithoutTimelineEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTimelineEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTimelineEventsInput, UserUncheckedUpdateWithoutTimelineEventsInput>
  }

  export type UserUpdateWithoutTimelineEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUpdateManyWithoutUserNestedInput
    educations?: EducationUpdateManyWithoutUserNestedInput
    certifications?: CertificationUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTimelineEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    workExperiences?: WorkExperienceUncheckedUpdateManyWithoutUserNestedInput
    educations?: EducationUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    socialMedia?: SocialMediaUncheckedUpdateManyWithoutUserNestedInput
    devStats?: DevStatsUncheckedUpdateOneWithoutUserNestedInput
    contributionData?: ContributionDataUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutTestimonialsInput = {
    id?: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    features?: ProjectFeatureCreateNestedManyWithoutProjectInput
    techStack?: ProjectTechStackCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    learnings?: ProjectLearningCreateNestedManyWithoutProjectInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutTestimonialsInput = {
    id?: string
    userId: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: ProjectFeatureUncheckedCreateNestedManyWithoutProjectInput
    techStack?: ProjectTechStackUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    learnings?: ProjectLearningUncheckedCreateNestedManyWithoutProjectInput
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutTestimonialsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTestimonialsInput, ProjectUncheckedCreateWithoutTestimonialsInput>
  }

  export type TestimonialCreateWithoutProjectTestimonialsInput = {
    id?: string
    name: string
    position: string
    company: string
    text: string
    avatar?: string | null
    rating: number
    date: Date | string
    relation: string
    projectLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTestimonialsInput
  }

  export type TestimonialUncheckedCreateWithoutProjectTestimonialsInput = {
    id?: string
    userId: string
    name: string
    position: string
    company: string
    text: string
    avatar?: string | null
    rating: number
    date: Date | string
    relation: string
    projectLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialCreateOrConnectWithoutProjectTestimonialsInput = {
    where: TestimonialWhereUniqueInput
    create: XOR<TestimonialCreateWithoutProjectTestimonialsInput, TestimonialUncheckedCreateWithoutProjectTestimonialsInput>
  }

  export type ProjectUpsertWithoutTestimonialsInput = {
    update: XOR<ProjectUpdateWithoutTestimonialsInput, ProjectUncheckedUpdateWithoutTestimonialsInput>
    create: XOR<ProjectCreateWithoutTestimonialsInput, ProjectUncheckedCreateWithoutTestimonialsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTestimonialsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTestimonialsInput, ProjectUncheckedUpdateWithoutTestimonialsInput>
  }

  export type ProjectUpdateWithoutTestimonialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    features?: ProjectFeatureUpdateManyWithoutProjectNestedInput
    techStack?: ProjectTechStackUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    learnings?: ProjectLearningUpdateManyWithoutProjectNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTestimonialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: ProjectFeatureUncheckedUpdateManyWithoutProjectNestedInput
    techStack?: ProjectTechStackUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    learnings?: ProjectLearningUncheckedUpdateManyWithoutProjectNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type TestimonialUpsertWithoutProjectTestimonialsInput = {
    update: XOR<TestimonialUpdateWithoutProjectTestimonialsInput, TestimonialUncheckedUpdateWithoutProjectTestimonialsInput>
    create: XOR<TestimonialCreateWithoutProjectTestimonialsInput, TestimonialUncheckedCreateWithoutProjectTestimonialsInput>
    where?: TestimonialWhereInput
  }

  export type TestimonialUpdateToOneWithWhereWithoutProjectTestimonialsInput = {
    where?: TestimonialWhereInput
    data: XOR<TestimonialUpdateWithoutProjectTestimonialsInput, TestimonialUncheckedUpdateWithoutProjectTestimonialsInput>
  }

  export type TestimonialUpdateWithoutProjectTestimonialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relation?: StringFieldUpdateOperationsInput | string
    projectLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTestimonialsNestedInput
  }

  export type TestimonialUncheckedUpdateWithoutProjectTestimonialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relation?: StringFieldUpdateOperationsInput | string
    projectLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillCreateManyUserInput = {
    id?: string
    name: string
    percentage: number
    color?: string | null
    icon?: string | null
    category?: string | null
    description?: string | null
    years?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyUserInput = {
    id?: string
    title: string
    slug: string
    description: string
    longDescription: string
    category: string
    image?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    branches?: number | null
    stars?: number | null
    views?: number | null
    forks?: number | null
    issues?: number | null
    commits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkExperienceCreateManyUserInput = {
    id?: string
    company: string
    position: string
    period: string
    description?: string | null
    location?: string | null
    type?: string | null
    logo?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EducationCreateManyUserInput = {
    id?: string
    institution: string
    degree: string
    field: string
    period: string
    description?: string | null
    gpa?: string | null
    location?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationCreateManyUserInput = {
    id?: string
    name: string
    issuer: string
    date: Date | string
    icon?: string | null
    credentialId?: string | null
    expiry?: Date | string | null
    description?: string | null
    verificationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementCreateManyUserInput = {
    id?: string
    title: string
    date: Date | string
    description?: string | null
    icon?: string | null
    category?: string | null
    issuer?: string | null
    link?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostCreateManyUserInput = {
    id?: string
    slug: string
    title: string
    excerpt: string
    content: string
    date: Date | string
    readTime: number
    image?: string | null
    likes?: number
    comments?: number
    shares?: number
    views?: number
    category: string
    author: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialCreateManyUserInput = {
    id?: string
    name: string
    position: string
    company: string
    text: string
    avatar?: string | null
    rating: number
    date: Date | string
    relation: string
    projectLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyUserInput = {
    id?: string
    type: string
    value: string
    icon?: string | null
    isPublic?: boolean
    link?: string | null
  }

  export type SocialMediaCreateManyUserInput = {
    id?: string
    platform: string
    url: string
    icon?: string | null
    username: string
  }

  export type ContributionDataCreateManyUserInput = {
    id?: string
    year: number
    total: number
    startRange: Date | string
    endRange: Date | string
  }

  export type TimelineEventCreateManyUserInput = {
    id?: string
    date: Date | string
    type: string
    title: string
    subtitle?: string | null
    description?: string | null
    icon?: string | null
    color?: string | null
  }

  export type SkillUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    years?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutSkillsNestedInput
  }

  export type SkillUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    years?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutSkillsNestedInput
  }

  export type SkillUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    years?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: ProjectFeatureUpdateManyWithoutProjectNestedInput
    techStack?: ProjectTechStackUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    learnings?: ProjectLearningUpdateManyWithoutProjectNestedInput
    testimonials?: ProjectTestimonialUpdateManyWithoutProjectNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: ProjectFeatureUncheckedUpdateManyWithoutProjectNestedInput
    techStack?: ProjectTechStackUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    learnings?: ProjectLearningUncheckedUpdateManyWithoutProjectNestedInput
    testimonials?: ProjectTestimonialUncheckedUpdateManyWithoutProjectNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkExperienceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibilities?: WorkResponsibilityUpdateManyWithoutWorkExperienceNestedInput
    technologies?: WorkTechnologyUpdateManyWithoutWorkExperienceNestedInput
    achievements?: WorkAchievementUpdateManyWithoutWorkExperienceNestedInput
  }

  export type WorkExperienceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibilities?: WorkResponsibilityUncheckedUpdateManyWithoutWorkExperienceNestedInput
    technologies?: WorkTechnologyUncheckedUpdateManyWithoutWorkExperienceNestedInput
    achievements?: WorkAchievementUncheckedUpdateManyWithoutWorkExperienceNestedInput
  }

  export type WorkExperienceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: EducationAchievementUpdateManyWithoutEducationNestedInput
  }

  export type EducationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: EducationAchievementUncheckedUpdateManyWithoutEducationNestedInput
  }

  export type EducationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    degree?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: CertificationSkillUpdateManyWithoutCertificationNestedInput
  }

  export type CertificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: CertificationSkillUncheckedUpdateManyWithoutCertificationNestedInput
  }

  export type CertificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: BlogTagUpdateManyWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: BlogTagUncheckedUpdateManyWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relation?: StringFieldUpdateOperationsInput | string
    projectLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTestimonials?: ProjectTestimonialUpdateManyWithoutTestimonialNestedInput
  }

  export type TestimonialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relation?: StringFieldUpdateOperationsInput | string
    projectLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTestimonials?: ProjectTestimonialUncheckedUpdateManyWithoutTestimonialNestedInput
  }

  export type TestimonialUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relation?: StringFieldUpdateOperationsInput | string
    projectLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialMediaUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
  }

  export type SocialMediaUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
  }

  export type SocialMediaUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
  }

  export type ContributionDataUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    startRange?: DateTimeFieldUpdateOperationsInput | Date | string
    endRange?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ContributionDayUpdateManyWithoutContributionDataNestedInput
  }

  export type ContributionDataUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    startRange?: DateTimeFieldUpdateOperationsInput | Date | string
    endRange?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ContributionDayUncheckedUpdateManyWithoutContributionDataNestedInput
  }

  export type ContributionDataUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    startRange?: DateTimeFieldUpdateOperationsInput | Date | string
    endRange?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimelineEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimelineEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimelineEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    features?: ProjectFeatureUpdateManyWithoutProjectNestedInput
    techStack?: ProjectTechStackUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    learnings?: ProjectLearningUpdateManyWithoutProjectNestedInput
    testimonials?: ProjectTestimonialUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: ProjectFeatureUncheckedUpdateManyWithoutProjectNestedInput
    techStack?: ProjectTechStackUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    learnings?: ProjectLearningUncheckedUpdateManyWithoutProjectNestedInput
    testimonials?: ProjectTestimonialUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: NullableIntFieldUpdateOperationsInput | number | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    forks?: NullableIntFieldUpdateOperationsInput | number | null
    issues?: NullableIntFieldUpdateOperationsInput | number | null
    commits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFeatureCreateManyProjectInput = {
    id?: string
    feature: string
  }

  export type ProjectTechStackCreateManyProjectInput = {
    id?: string
    tech: string
  }

  export type ProjectCollaboratorCreateManyProjectInput = {
    id?: string
    name: string
    username: string
  }

  export type ProjectLearningCreateManyProjectInput = {
    id?: string
    learning: string
  }

  export type ProjectTestimonialCreateManyProjectInput = {
    id?: string
    testimonialId: string
  }

  export type ProjectFeatureUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectFeatureUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectFeatureUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTechStackUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    tech?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTechStackUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    tech?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTechStackUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    tech?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCollaboratorUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCollaboratorUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCollaboratorUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectLearningUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    learning?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectLearningUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    learning?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectLearningUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    learning?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTestimonialUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    testimonial?: TestimonialUpdateOneRequiredWithoutProjectTestimonialsNestedInput
  }

  export type ProjectTestimonialUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    testimonialId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTestimonialUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    testimonialId?: StringFieldUpdateOperationsInput | string
  }

  export type SkillUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    years?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type SkillUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    years?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateManyWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    years?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkResponsibilityCreateManyWorkExperienceInput = {
    id?: string
    responsibility: string
  }

  export type WorkTechnologyCreateManyWorkExperienceInput = {
    id?: string
    technology: string
  }

  export type WorkAchievementCreateManyWorkExperienceInput = {
    id?: string
    achievement: string
  }

  export type WorkResponsibilityUpdateWithoutWorkExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
  }

  export type WorkResponsibilityUncheckedUpdateWithoutWorkExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
  }

  export type WorkResponsibilityUncheckedUpdateManyWithoutWorkExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
  }

  export type WorkTechnologyUpdateWithoutWorkExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    technology?: StringFieldUpdateOperationsInput | string
  }

  export type WorkTechnologyUncheckedUpdateWithoutWorkExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    technology?: StringFieldUpdateOperationsInput | string
  }

  export type WorkTechnologyUncheckedUpdateManyWithoutWorkExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    technology?: StringFieldUpdateOperationsInput | string
  }

  export type WorkAchievementUpdateWithoutWorkExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
  }

  export type WorkAchievementUncheckedUpdateWithoutWorkExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
  }

  export type WorkAchievementUncheckedUpdateManyWithoutWorkExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
  }

  export type EducationAchievementCreateManyEducationInput = {
    id?: string
    achievement: string
  }

  export type EducationAchievementUpdateWithoutEducationInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
  }

  export type EducationAchievementUncheckedUpdateWithoutEducationInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
  }

  export type EducationAchievementUncheckedUpdateManyWithoutEducationInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievement?: StringFieldUpdateOperationsInput | string
  }

  export type CertificationSkillCreateManyCertificationInput = {
    id?: string
    skill: string
  }

  export type CertificationSkillUpdateWithoutCertificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type CertificationSkillUncheckedUpdateWithoutCertificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type CertificationSkillUncheckedUpdateManyWithoutCertificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type BlogTagCreateManyBlogPostInput = {
    id?: string
    tag: string
  }

  export type BlogTagUpdateWithoutBlogPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type BlogTagUncheckedUpdateWithoutBlogPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type BlogTagUncheckedUpdateManyWithoutBlogPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTestimonialCreateManyTestimonialInput = {
    id?: string
    projectId: string
  }

  export type ProjectTestimonialUpdateWithoutTestimonialInput = {
    id?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutTestimonialsNestedInput
  }

  export type ProjectTestimonialUncheckedUpdateWithoutTestimonialInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTestimonialUncheckedUpdateManyWithoutTestimonialInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ContributionDayCreateManyContributionDataInput = {
    id?: string
    date: Date | string
    count: number
    level: number
  }

  export type ContributionDayUpdateWithoutContributionDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type ContributionDayUncheckedUpdateWithoutContributionDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type ContributionDayUncheckedUpdateManyWithoutContributionDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}